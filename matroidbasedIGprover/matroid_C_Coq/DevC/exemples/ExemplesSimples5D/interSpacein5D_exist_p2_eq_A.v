Load "preamble5D.v".


(* dans la couche 0 *)
Lemma LAC : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AC requis par la preuve de (?)AC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et -4*)
assert(HACm2 : rk(A :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HACp2mtmp : rk(A :: C :: p2 :: nil) >= 2) by (solve_hyps_min HACp2eq HACp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: p2 :: nil) (A :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A :: p2 :: nil) ((A :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACp2mtmp;try rewrite HT2 in HACp2mtmp.
	assert(HT := rule_2 (A :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HACp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

assert(HACM : rk(A :: C ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max HACeq HACM2).
assert(HACm : rk(A :: C ::  nil) >= 1) by (solve_hyps_min HACeq HACm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCp1 *)
(* dans constructLemma(), requis par LCDEp1 *)
(* dans la couche 0 *)
Lemma LABCDEp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p1 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDEp1 requis par la preuve de (?)ABCDEp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCDp1 requis par la preuve de (?)ABCDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCDp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDp1 requis par la preuve de (?)ABCDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDp1M4 : rk(A :: B :: C :: D :: p1 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: p1 :: nil) (D :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: C :: p1 :: nil) ((D :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HDMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1 requis par la preuve de (?)ABCDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDEp1M5 : rk(A :: B :: C :: D :: E :: p1 :: nil) <= 5).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCDp1Mtmp : rk(A :: B :: C :: D :: p1 :: nil) <= 4) by (solve_hyps_max HABCDp1eq HABCDp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (E :: A :: B :: C :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: D :: p1 :: nil) (nil) 1 4 0 HEMtmp HABCDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1m5 : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

assert(HABCDEp1M : rk(A :: B :: C :: D :: E :: p1 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp1m : rk(A :: B :: C :: D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HABCDEp1eq HABCDEp1m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCDEp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(C :: D :: E :: p1 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CDEp1 requis par la preuve de (?)CDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour BCDEp1 requis par la preuve de (?)CDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour BCDEp1 requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEDpp1 requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEDpp1 requis par la preuve de (?)ABCDEDpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEDpp1m5 : rk(A :: B :: C :: D :: E :: Dp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour BCDEp1 requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BE requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABECp requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp requis par la preuve de (?)ABECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCDECpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCpm2 : rk(A :: B :: Cp :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Cp :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: Cp :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Cp :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_2 (A :: B :: Cp :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDECpp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABECp requis par la preuve de (?)ABECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: B :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HABECpm2 : rk(A :: B :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 2) by (solve_hyps_min HABCpeq HABCpm2).
	assert(Hincl : incl (A :: B :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: B :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: B :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: B :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: B :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: B :: E :: Cp :: nil) (A :: B :: Cp :: nil) 5 2 5 HABCDECpmtmp HABCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour BCDEp1 requis par la preuve de (?)BCDEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : B :: E ::  de rang :  1 et 2 	 A : A :: B :: E :: Cp ::   de rang : 2 et 4 *)
assert(HBCDEp1m2 : rk(B :: C :: D :: E :: p1 :: nil) >= 2).
{
	assert(HABECpMtmp : rk(A :: B :: E :: Cp :: nil) <= 4) by (solve_hyps_max HABECpeq HABECpM4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HBEmtmp : rk(B :: E :: nil) >= 1) by (solve_hyps_min HBEeq HBEm1).
	assert(Hincl : incl (B :: E :: nil) (list_inter (A :: B :: E :: Cp :: nil) (B :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (A :: B :: E :: Cp :: B :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: Cp :: B :: C :: D :: E :: p1 :: nil) ((A :: B :: E :: Cp :: nil) ++ (B :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (A :: B :: E :: Cp :: nil) (B :: C :: D :: E :: p1 :: nil) (B :: E :: nil) 5 1 4 HABCDECpp1mtmp HBEmtmp HABECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Dp :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : A :: Dp ::   de rang : 1 et 2 *)
assert(HBCDEp1m3 : rk(B :: C :: D :: E :: p1 :: nil) >= 3).
{
	assert(HADpMtmp : rk(A :: Dp :: nil) <= 2) by (solve_hyps_max HADpeq HADpM2).
	assert(HABCDEDpp1mtmp : rk(A :: B :: C :: D :: E :: Dp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEDpp1eq HABCDEDpp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Dp :: nil) (B :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Dp :: p1 :: nil) (A :: Dp :: B :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Dp :: B :: C :: D :: E :: p1 :: nil) ((A :: Dp :: nil) ++ (B :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEDpp1mtmp;try rewrite HT2 in HABCDEDpp1mtmp.
	assert(HT := rule_4 (A :: Dp :: nil) (B :: C :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEDpp1mtmp Hmtmp HADpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: p1 ::   de rang : 2 et 2 *)
assert(HBCDEp1m4 : rk(B :: C :: D :: E :: p1 :: nil) >= 4).
{
	assert(HAp1Mtmp : rk(A :: p1 :: nil) <= 2) by (solve_hyps_max HAp1eq HAp1M2).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: p1 :: nil) (B :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (A :: p1 :: B :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p1 :: B :: C :: D :: E :: p1 :: nil) ((A :: p1 :: nil) ++ (B :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_4 (A :: p1 :: nil) (B :: C :: D :: E :: p1 :: nil) (p1 :: nil) 5 1 2 HABCDEp1mtmp Hp1mtmp HAp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)CDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CDEp1 requis par la preuve de (?)CDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CDEp1 requis par la preuve de (?)CDEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : A :: B :: E :: Cp ::   de rang : 2 et 4 *)
assert(HCDEp1m2 : rk(C :: D :: E :: p1 :: nil) >= 2).
{
	assert(HABECpMtmp : rk(A :: B :: E :: Cp :: nil) <= 4) by (solve_hyps_max HABECpeq HABECpM4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (A :: B :: E :: Cp :: nil) (C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (A :: B :: E :: Cp :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: Cp :: C :: D :: E :: p1 :: nil) ((A :: B :: E :: Cp :: nil) ++ (C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (A :: B :: E :: Cp :: nil) (C :: D :: E :: p1 :: nil) (E :: nil) 5 1 4 HABCDECpp1mtmp HEmtmp HABECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : B :: C :: D :: E :: p1 ::  de rang :  4 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HCDEp1m3 : rk(C :: D :: E :: p1 :: nil) >= 3).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HBCDEp1mtmp : rk(B :: C :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HBCDEp1eq HBCDEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: p1 :: nil) (B :: p1 :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: C :: D :: E :: p1 :: nil) ((B :: p1 :: nil) ++ (C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCDEp1mtmp;try rewrite HT2 in HBCDEp1mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (C :: D :: E :: p1 :: nil) (p1 :: nil) 4 1 2 HBCDEp1mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HCDEp1m4 : rk(C :: D :: E :: p1 :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: B :: p1 :: nil) (C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (A :: B :: p1 :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: C :: D :: E :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (C :: D :: E :: p1 :: nil) (p1 :: nil) 5 1 2 HABCDEp1mtmp Hp1mtmp HABp1Mtmp Hincl); apply HT.
}

assert(HCDEp1M : rk(C :: D :: E :: p1 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HCDEp1eq HCDEp1M4).
assert(HCDEp1m : rk(C :: D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HCDEp1eq HCDEp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LCp1 *)
(* dans la couche 0 *)
Lemma LCp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(C :: p1 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour DEp1 requis par la preuve de (?)Cp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)DEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour DEp1 requis par la preuve de (?)DEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 ::  de rang :  3 et 4 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HDEp1m2 : rk(D :: E :: p1 :: nil) >= 2).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1mtmp : rk(A :: B :: D :: E :: p1 :: nil) >= 3) by (solve_hyps_min HABDEp1eq HABDEp1m3).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: B :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (A :: B :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: D :: E :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1mtmp;try rewrite HT2 in HABDEp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 3 1 2 HABDEp1mtmp Hp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cp1 requis par la preuve de (?)Cp1 pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 5*)
assert(HCp1m2 : rk(C :: p1 :: nil) >= 2).
{
	assert(HDEp1Mtmp : rk(D :: E :: p1 :: nil) <= 3) by (solve_hyps_max HDEp1eq HDEp1M3).
	assert(HCDEp1eq : rk(C :: D :: E :: p1 :: nil) = 4) by (apply LCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCDEp1mtmp : rk(C :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HCDEp1eq HCDEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: D :: E :: p1 :: nil) (C :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: D :: E :: p1 :: nil) ((C :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCDEp1mtmp;try rewrite HT2 in HCDEp1mtmp.
	assert(HT := rule_2 (C :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 4 1 3 HCDEp1mtmp Hp1mtmp HDEp1Mtmp Hincl);apply HT.
}

assert(HCp1M : rk(C :: p1 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max HCp1eq HCp1M2).
assert(HCp1m : rk(C :: p1 ::  nil) >= 1) by (solve_hyps_min HCp1eq HCp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LACp1 *)
(* dans la couche 0 *)
Lemma LACDEp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C :: D :: E :: p1 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1 requis par la preuve de (?)ABCDEApBpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp1 requis par la preuve de (?)ACDEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1m2 : rk(A :: C :: D :: E :: p1 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1eq HABCDEApBpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1mtmp;try rewrite HT2 in HABCDEApBpp1mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1m3 : rk(A :: C :: D :: E :: p1 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDECpp1mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1m4 : rk(A :: C :: D :: E :: p1 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: nil) (p1 :: nil) 5 1 2 HABCDEp1mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 5) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1m5 : rk(A :: C :: D :: E :: p1 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

assert(HACDEp1M : rk(A :: C :: D :: E :: p1 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HACDEp1eq HACDEp1M5).
assert(HACDEp1m : rk(A :: C :: D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HACDEp1eq HACDEp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LACp1 *)
(* dans la couche 0 *)
Lemma LDEp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(D :: E :: p1 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour DEp1 requis par la preuve de (?)DEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)DEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour DEp1 requis par la preuve de (?)DEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 ::  de rang :  3 et 4 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HDEp1m2 : rk(D :: E :: p1 :: nil) >= 2).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1mtmp : rk(A :: B :: D :: E :: p1 :: nil) >= 3) by (solve_hyps_min HABDEp1eq HABDEp1m3).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: B :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (A :: B :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: D :: E :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1mtmp;try rewrite HT2 in HABDEp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 3 1 2 HABDEp1mtmp Hp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : C :: D :: E :: p1 ::  de rang :  4 et 4 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HDEp1m3 : rk(D :: E :: p1 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HCDEp1eq : rk(C :: D :: E :: p1 :: nil) = 4) by (apply LCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCDEp1mtmp : rk(C :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HCDEp1eq HCDEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: D :: E :: p1 :: nil) (C :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: D :: E :: p1 :: nil) ((C :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCDEp1mtmp;try rewrite HT2 in HCDEp1mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 4 1 2 HCDEp1mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

assert(HDEp1M : rk(D :: E :: p1 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HDEp1eq HDEp1M3).
assert(HDEp1m : rk(D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HDEp1eq HDEp1m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C :: p1 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACp1 requis par la preuve de (?)ACp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACp1 requis par la preuve de (?)ACp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACp1m2 : rk(A :: C :: p1 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: C :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: C :: p1 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HACp1m3 : rk(A :: C :: p1 :: nil) >= 3).
{
	assert(HDEp1eq : rk(D :: E :: p1 :: nil) = 3) by (apply LDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDEp1Mtmp : rk(D :: E :: p1 :: nil) <= 3) by (solve_hyps_max HDEp1eq HDEp1M3).
	assert(HACDEp1eq : rk(A :: C :: D :: E :: p1 :: nil) = 5) by (apply LACDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACDEp1mtmp : rk(A :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HACDEp1eq HACDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: C :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: nil) (A :: C :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: p1 :: D :: E :: p1 :: nil) ((A :: C :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1mtmp;try rewrite HT2 in HACDEp1mtmp.
	assert(HT := rule_2 (A :: C :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 5 1 3 HACDEp1mtmp Hp1mtmp HDEp1Mtmp Hincl);apply HT.
}

assert(HACp1M : rk(A :: C :: p1 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HACp1eq HACp1M3).
assert(HACp1m : rk(A :: C :: p1 ::  nil) >= 1) by (solve_hyps_min HACp1eq HACp1m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: p1 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCp1m2 : rk(A :: B :: C :: p1 :: nil) >= 2).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (E :: Ap :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: p1 :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: p1 :: nil) (nil) 4 0 2 HABCEApp1mtmp Hmtmp HEApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HABCp1m3 : rk(A :: B :: C :: p1 :: nil) >= 3).
{
	assert(HDEp1eq : rk(D :: E :: p1 :: nil) = 3) by (apply LDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDEp1Mtmp : rk(D :: E :: p1 :: nil) <= 3) by (solve_hyps_max HDEp1eq HDEp1M3).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: B :: C :: p1 :: nil) (D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (A :: B :: C :: p1 :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p1 :: D :: E :: p1 :: nil) ((A :: B :: C :: p1 :: nil) ++ (D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_2 (A :: B :: C :: p1 :: nil) (D :: E :: p1 :: nil) (p1 :: nil) 5 1 3 HABCDEp1mtmp Hp1mtmp HDEp1Mtmp Hincl);apply HT.
}

assert(HABCp1M : rk(A :: B :: C :: p1 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HABCp1eq HABCp1M4).
assert(HABCp1m : rk(A :: B :: C :: p1 ::  nil) >= 1) by (solve_hyps_min HABCp1eq HABCp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LDp1 *)
(* dans la couche 0 *)
Lemma LADEp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: D :: E :: p1 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADEp1 requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADEp1 requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCECp requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCCp requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCCpm2 : rk(B :: C :: Cp :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_2 (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDECpp1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : B :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HBCECpm2 : rk(B :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HBCCpmtmp : rk(B :: C :: Cp :: nil) >= 2) by (solve_hyps_min HBCCpeq HBCCpm2).
	assert(Hincl : incl (B :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (B :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil) (B :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HBCCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCECpm3 : rk(B :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (B :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: B :: p1 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCECpp1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp1 requis par la preuve de (?)ADEp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HADEp1m2 : rk(A :: D :: E :: p1 :: nil) >= 2).
{
	assert(HBCECpMtmp : rk(B :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBCECpeq HBCECpM4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (B :: C :: E :: Cp :: A :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: D :: E :: p1 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: nil) (E :: nil) 5 1 4 HABCDECpp1mtmp HEmtmp HBCECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 ::  de rang :  3 et 4 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1m3 : rk(A :: D :: E :: p1 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1mtmp : rk(A :: B :: D :: E :: p1 :: nil) >= 3) by (solve_hyps_min HABDEp1eq HABDEp1m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1mtmp;try rewrite HT2 in HABDEp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1m4 : rk(A :: D :: E :: p1 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1eq : rk(A :: C :: D :: E :: p1 :: nil) = 5) by (apply LACDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACDEp1mtmp : rk(A :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HACDEp1eq HACDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: nil) (C :: p1 :: A :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1mtmp;try rewrite HT2 in HACDEp1mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: nil) (p1 :: nil) 5 1 2 HACDEp1mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

assert(HADEp1M : rk(A :: D :: E :: p1 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HADEp1eq HADEp1M4).
assert(HADEp1m : rk(A :: D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HADEp1eq HADEp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LDp1 *)
(* dans la couche 0 *)
Lemma LDp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(D :: p1 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AEp1 requis par la preuve de (?)Dp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AEp1 requis par la preuve de (?)AEp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAEp1m2 : rk(A :: E :: p1 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: E :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: E :: p1 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dp1 requis par la preuve de (?)Dp1 pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 5*)
assert(HDp1m2 : rk(D :: p1 :: nil) >= 2).
{
	assert(HAEp1Mtmp : rk(A :: E :: p1 :: nil) <= 3) by (solve_hyps_max HAEp1eq HAEp1M3).
	assert(HADEp1eq : rk(A :: D :: E :: p1 :: nil) = 4) by (apply LADEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADEp1mtmp : rk(A :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HADEp1eq HADEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: nil) (D :: p1 :: A :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: E :: p1 :: nil) ((D :: p1 :: nil) ++ (A :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1mtmp;try rewrite HT2 in HADEp1mtmp.
	assert(HT := rule_2 (D :: p1 :: nil) (A :: E :: p1 :: nil) (p1 :: nil) 4 1 3 HADEp1mtmp Hp1mtmp HAEp1Mtmp Hincl);apply HT.
}

assert(HDp1M : rk(D :: p1 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max HDp1eq HDp1M2).
assert(HDp1m : rk(D :: p1 ::  nil) >= 1) by (solve_hyps_min HDp1eq HDp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LADp1 *)
(* dans la couche 0 *)
Lemma LADp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: D :: p1 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ep1 requis par la preuve de (?)ADp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADp1 requis par la preuve de (?)ADp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp1 requis par la preuve de (?)ADp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HADp1m2 : rk(A :: D :: p1 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: D :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: D :: p1 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 5*)
assert(HADp1m3 : rk(A :: D :: p1 :: nil) >= 3).
{
	assert(HEp1Mtmp : rk(E :: p1 :: nil) <= 2) by (solve_hyps_max HEp1eq HEp1M2).
	assert(HADEp1eq : rk(A :: D :: E :: p1 :: nil) = 4) by (apply LADEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADEp1mtmp : rk(A :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HADEp1eq HADEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: D :: p1 :: nil) (E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: nil) (A :: D :: p1 :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p1 :: E :: p1 :: nil) ((A :: D :: p1 :: nil) ++ (E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1mtmp;try rewrite HT2 in HADEp1mtmp.
	assert(HT := rule_2 (A :: D :: p1 :: nil) (E :: p1 :: nil) (p1 :: nil) 4 1 2 HADEp1mtmp Hp1mtmp HEp1Mtmp Hincl);apply HT.
}

assert(HADp1M : rk(A :: D :: p1 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HADp1eq HADp1M3).
assert(HADp1m : rk(A :: D :: p1 ::  nil) >= 1) by (solve_hyps_min HADp1eq HADp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LABDp1 *)
(* dans la couche 0 *)
Lemma LABDEp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: D :: E :: p1 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HABDEp1m4 : rk(A :: B :: D :: E :: p1 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HABCDEp1eq : rk(A :: B :: C :: D :: E :: p1 :: nil) = 5) by (apply LABCDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1mtmp : rk(A :: B :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEp1eq HABCDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: nil) (C :: p1 :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: B :: D :: E :: p1 :: nil) ((C :: p1 :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1mtmp;try rewrite HT2 in HABCDEp1mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: B :: D :: E :: p1 :: nil) (p1 :: nil) 5 1 2 HABCDEp1mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

assert(HABDEp1M : rk(A :: B :: D :: E :: p1 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HABDEp1eq HABDEp1M5).
assert(HABDEp1m : rk(A :: B :: D :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HABDEp1eq HABDEp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LABDp1 *)
(* dans la couche 0 *)
Lemma LEp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(E :: p1 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ep1 requis par la preuve de (?)Ep1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 ::  de rang :  4 et 4 	 AiB : p1 ::  de rang :  1 et 1 	 A : A :: D :: p1 ::   de rang : 3 et 3 *)
assert(HEp1m2 : rk(E :: p1 :: nil) >= 2).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADp1Mtmp : rk(A :: D :: p1 :: nil) <= 3) by (solve_hyps_max HADp1eq HADp1M3).
	assert(HADEp1eq : rk(A :: D :: E :: p1 :: nil) = 4) by (apply LADEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADEp1mtmp : rk(A :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HADEp1eq HADEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: D :: p1 :: nil) (E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: nil) (A :: D :: p1 :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p1 :: E :: p1 :: nil) ((A :: D :: p1 :: nil) ++ (E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1mtmp;try rewrite HT2 in HADEp1mtmp.
	assert(HT := rule_4 (A :: D :: p1 :: nil) (E :: p1 :: nil) (p1 :: nil) 4 1 3 HADEp1mtmp Hp1mtmp HADp1Mtmp Hincl); apply HT.
}

assert(HEp1M : rk(E :: p1 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max HEp1eq HEp1M2).
assert(HEp1m : rk(E :: p1 ::  nil) >= 1) by (solve_hyps_min HEp1eq HEp1m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABDp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: D :: p1 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABDp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABDp1m2 : rk(A :: B :: D :: p1 :: nil) >= 2).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: Ap :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (E :: Ap :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: D :: p1 :: nil) ((E :: Ap :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: D :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HEApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HABDp1m3 : rk(A :: B :: D :: p1 :: nil) >= 3).
{
	assert(HEp1eq : rk(E :: p1 :: nil) = 2) by (apply LEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HEp1Mtmp : rk(E :: p1 :: nil) <= 2) by (solve_hyps_max HEp1eq HEp1M2).
	assert(HABDEp1eq : rk(A :: B :: D :: E :: p1 :: nil) = 4) by (apply LABDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABDEp1mtmp : rk(A :: B :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HABDEp1eq HABDEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: B :: D :: p1 :: nil) (E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (A :: B :: D :: p1 :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: p1 :: E :: p1 :: nil) ((A :: B :: D :: p1 :: nil) ++ (E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1mtmp;try rewrite HT2 in HABDEp1mtmp.
	assert(HT := rule_2 (A :: B :: D :: p1 :: nil) (E :: p1 :: nil) (p1 :: nil) 4 1 2 HABDEp1mtmp Hp1mtmp HEp1Mtmp Hincl);apply HT.
}

assert(HABDp1M : rk(A :: B :: D :: p1 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HABDp1eq HABDp1M4).
assert(HABDp1m : rk(A :: B :: D :: p1 ::  nil) >= 1) by (solve_hyps_min HABDp1eq HABDp1m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACDp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C :: D :: p1 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDp1 requis par la preuve de (?)ACDp1 pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCDp1 requis par la preuve de (?)ACDp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCDp1 requis par la preuve de (?)ABCDp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCDp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDp1 requis par la preuve de (?)ABCDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDp1M4 : rk(A :: B :: C :: D :: p1 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: p1 :: nil) (D :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: C :: p1 :: nil) ((D :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HDMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDp1m3 : rk(A :: B :: C :: D :: p1 :: nil) >= 3).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (E :: Ap :: A :: B :: C :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: p1 :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDp1 requis par la preuve de (?)ACDp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ACDp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABECp requis par la preuve de (?)ACDp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp requis par la preuve de (?)ABECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCDECpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCpm2 : rk(A :: B :: Cp :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Cp :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: Cp :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Cp :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_2 (A :: B :: Cp :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDECpp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABECp requis par la preuve de (?)ABECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: B :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HABECpm2 : rk(A :: B :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 2) by (solve_hyps_min HABCpeq HABCpm2).
	assert(Hincl : incl (A :: B :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: B :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: B :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: B :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: B :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: B :: E :: Cp :: nil) (A :: B :: Cp :: nil) 5 2 5 HABCDECpmtmp HABCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp1 requis par la preuve de (?)ACDp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B :: E :: Cp ::   de rang : 2 et 4 *)
assert(HACDp1m2 : rk(A :: C :: D :: p1 :: nil) >= 2).
{
	assert(HABECpMtmp : rk(A :: B :: E :: Cp :: nil) <= 4) by (solve_hyps_max HABECpeq HABECpM4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: E :: Cp :: nil) (A :: C :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (A :: B :: E :: Cp :: A :: C :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: Cp :: A :: C :: D :: p1 :: nil) ((A :: B :: E :: Cp :: nil) ++ (A :: C :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (A :: B :: E :: Cp :: nil) (A :: C :: D :: p1 :: nil) (A :: nil) 5 1 4 HABCDECpp1mtmp HAmtmp HABECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: p1 ::  de rang :  3 et 4 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDp1m3 : rk(A :: C :: D :: p1 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDp1mtmp : rk(A :: B :: C :: D :: p1 :: nil) >= 3) by (solve_hyps_min HABCDp1eq HABCDp1m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: p1 :: nil) (A :: B :: p1 :: A :: C :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: p1 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDp1mtmp;try rewrite HT2 in HABCDp1mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: p1 :: nil) (A :: p1 :: nil) 3 2 2 HABCDp1mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HACDp1m4 : rk(A :: C :: D :: p1 :: nil) >= 4).
{
	assert(HEp1eq : rk(E :: p1 :: nil) = 2) by (apply LEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HEp1Mtmp : rk(E :: p1 :: nil) <= 2) by (solve_hyps_max HEp1eq HEp1M2).
	assert(HACDEp1eq : rk(A :: C :: D :: E :: p1 :: nil) = 5) by (apply LACDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACDEp1mtmp : rk(A :: C :: D :: E :: p1 :: nil) >= 5) by (solve_hyps_min HACDEp1eq HACDEp1m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (A :: C :: D :: p1 :: nil) (E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: nil) (A :: C :: D :: p1 :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: p1 :: E :: p1 :: nil) ((A :: C :: D :: p1 :: nil) ++ (E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1mtmp;try rewrite HT2 in HACDEp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: p1 :: nil) (E :: p1 :: nil) (p1 :: nil) 5 1 2 HACDEp1mtmp Hp1mtmp HEp1Mtmp Hincl);apply HT.
}

assert(HACDp1M : rk(A :: C :: D :: p1 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HACDp1eq HACDp1M4).
assert(HACDp1m : rk(A :: C :: D :: p1 ::  nil) >= 1) by (solve_hyps_min HACDp1eq HACDp1m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABEp1 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: E :: p1 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 ::  de rang :  4 et 4 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HABEp1m3 : rk(A :: B :: E :: p1 :: nil) >= 3).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HABDEp1eq : rk(A :: B :: D :: E :: p1 :: nil) = 4) by (apply LABDEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABDEp1mtmp : rk(A :: B :: D :: E :: p1 :: nil) >= 4) by (solve_hyps_min HABDEp1eq HABDEp1m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (D :: p1 :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: B :: E :: p1 :: nil) ((D :: p1 :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1mtmp;try rewrite HT2 in HABDEp1mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: B :: E :: p1 :: nil) (p1 :: nil) 4 1 2 HABDEp1mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

assert(HABEp1M : rk(A :: B :: E :: p1 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HABEp1eq HABEp1M4).
assert(HABEp1m : rk(A :: B :: E :: p1 ::  nil) >= 1) by (solve_hyps_min HABEp1eq HABEp1m1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCp2 *)
(* dans constructLemma(), requis par LBCDEp2 *)
(* dans la couche 0 *)
Lemma LABCDEp2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p2 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDEp2 requis par la preuve de (?)ABCDEp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCDp2 requis par la preuve de (?)ABCDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCDp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDp2 requis par la preuve de (?)ABCDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDp2M4 : rk(A :: B :: C :: D :: p2 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: p2 :: nil) (D :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: C :: p2 :: nil) ((D :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HDMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp2 requis par la preuve de (?)ABCDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDEp2M5 : rk(A :: B :: C :: D :: E :: p2 :: nil) <= 5).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCDp2Mtmp : rk(A :: B :: C :: D :: p2 :: nil) <= 4) by (solve_hyps_max HABCDp2eq HABCDp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: nil) (E :: A :: B :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: D :: p2 :: nil) (nil) 1 4 0 HEMtmp HABCDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp2m5 : rk(A :: B :: C :: D :: E :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

assert(HABCDEp2M : rk(A :: B :: C :: D :: E :: p2 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp2m : rk(A :: B :: C :: D :: E :: p2 ::  nil) >= 1) by (solve_hyps_min HABCDEp2eq HABCDEp2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCDEp2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(B :: C :: D :: E :: p2 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour BCDEp2 requis par la preuve de (?)BCDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 5 pour ABCDEp1p2 requis par la preuve de (?)BCDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABCDEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2 requis par la preuve de (?)ABCDEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2 requis par la preuve de (?)ABCDEp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCDEp1p2M5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 2 4 1 HABp1Mtmp HACDEp2Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour BCDEp2 requis par la preuve de (?)BCDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEDpp2 requis par la preuve de (?)BCDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEDpp2 requis par la preuve de (?)ABCDEDpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEDpp2m5 : rk(A :: B :: C :: D :: E :: Dp :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp requis par la preuve de (?)BCDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour BCDEp2 requis par la preuve de (?)BCDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)BCDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCDECpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BE requis par la preuve de (?)BCDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABECp requis par la preuve de (?)BCDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABECpp2 requis par la preuve de (?)ABECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDECpp2 requis par la preuve de (?)ABECpp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)ABDECpp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABDECpp2 requis par la preuve de (?)ABDECpp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp requis par la preuve de (?)ABDECpp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCpm2 : rk(A :: B :: Cp :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Cp :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: Cp :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Cp :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_2 (A :: B :: Cp :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDECpp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDECpp2 requis par la preuve de (?)ABDECpp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp2 requis par la preuve de (?)ABDECpp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp2 requis par la preuve de (?)ABDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp2 requis par la preuve de (?)ABDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp2 requis par la preuve de (?)ABDp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABp2 requis par la preuve de (?)ABp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABp2M2 : rk(A :: B :: p2 :: nil) <= 2).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: p2 :: nil) (B :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: p2 :: nil) ((B :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: p2 :: nil) (nil) 1 1 0 HBMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp2 requis par la preuve de (?)ABDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDp2M3 : rk(A :: B :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp2Mtmp : rk(A :: B :: p2 :: nil) <= 2) by (solve_hyps_max HABp2eq HABp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p2 :: nil) (D :: A :: B :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p2 :: nil) ((D :: nil) ++ (A :: B :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p2 :: nil) (nil) 1 2 0 HDMtmp HABp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp2 requis par la preuve de (?)ABDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp2M4 : rk(A :: B :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp2Mtmp : rk(A :: B :: D :: p2 :: nil) <= 3) by (solve_hyps_max HABDp2eq HABDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p2 :: nil) (E :: A :: B :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p2 :: nil) ((E :: nil) ++ (A :: B :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HABDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp2m3 : rk(A :: B :: D :: E :: p2 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: B :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDECpp2 requis par la preuve de (?)ABDECpp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDECpp2M5 : rk(A :: B :: D :: E :: Cp :: p2 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABDEp2Mtmp : rk(A :: B :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABDEp2eq HABDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Cp :: p2 :: nil) (Cp :: A :: B :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: D :: E :: p2 :: nil) ((Cp :: nil) ++ (A :: B :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: D :: E :: p2 :: nil) (nil) 1 4 0 HCpMtmp HABDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABDECpp2m2 : rk(A :: B :: D :: E :: Cp :: p2 :: nil) >= 2).
{
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 2) by (solve_hyps_min HABCpeq HABCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (A :: B :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (A :: B :: D :: E :: Cp :: p2 :: nil) 2 2 HABCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : C :: Cp ::   de rang : 1 et 2 *)
assert(HABDECpp2m4 : rk(A :: B :: D :: E :: Cp :: p2 :: nil) >= 4).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (C :: Cp :: nil) (A :: B :: D :: E :: Cp :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (C :: Cp :: A :: B :: D :: E :: Cp :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: A :: B :: D :: E :: Cp :: p2 :: nil) ((C :: Cp :: nil) ++ (A :: B :: D :: E :: Cp :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_4 (C :: Cp :: nil) (A :: B :: D :: E :: Cp :: p2 :: nil) (Cp :: nil) 5 1 2 HABCDECpp2mtmp HCpmtmp HCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABECpp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABECpp2 requis par la preuve de (?)ABECpp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABECpp2 requis par la preuve de (?)ABECpp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp2 requis par la preuve de (?)ABECpp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp2 requis par la preuve de (?)ABEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABDEApp2 requis par la preuve de (?)ABDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABDEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp2 requis par la preuve de (?)ABDEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp2 requis par la preuve de (?)ABDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp2M5 : rk(A :: B :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp2Mtmp : rk(A :: B :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABDEp2eq HABDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABDEApp2m2 : rk(A :: B :: D :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: D :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp2m4 : rk(A :: B :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp2 requis par la preuve de (?)ABEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp2 requis par la preuve de (?)ABEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABEp2M3 : rk(A :: B :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp2Mtmp : rk(A :: B :: p2 :: nil) <= 2) by (solve_hyps_max HABp2eq HABp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p2 :: nil) (E :: A :: B :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p2 :: nil) ((E :: nil) ++ (A :: B :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p2 :: nil) (nil) 1 2 0 HEMtmp HABp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp2m2 : rk(A :: B :: E :: p2 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp2mtmp : rk(A :: B :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABDEApp2eq HABDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp2mtmp;try rewrite HT2 in HABDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p2 :: nil) (nil) 4 0 2 HABDEApp2mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABECpp2 requis par la preuve de (?)ABECpp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABECpp2M4 : rk(A :: B :: E :: Cp :: p2 :: nil) <= 4).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABEp2Mtmp : rk(A :: B :: E :: p2 :: nil) <= 3) by (solve_hyps_max HABEp2eq HABEp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: Cp :: p2 :: nil) (Cp :: A :: B :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: E :: p2 :: nil) ((Cp :: nil) ++ (A :: B :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: E :: p2 :: nil) (nil) 1 3 0 HCpMtmp HABEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABECpp2m2 : rk(A :: B :: E :: Cp :: p2 :: nil) >= 2).
{
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 2) by (solve_hyps_min HABCpeq HABCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (A :: B :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (A :: B :: E :: Cp :: p2 :: nil) 2 2 HABCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Cp :: p2 ::  de rang :  4 et 5 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABECpp2m3 : rk(A :: B :: E :: Cp :: p2 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABDECpp2mtmp : rk(A :: B :: D :: E :: Cp :: p2 :: nil) >= 4) by (solve_hyps_min HABDECpp2eq HABDECpp2m4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: E :: Cp :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Cp :: p2 :: nil) (D :: Cp :: A :: B :: E :: Cp :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: E :: Cp :: p2 :: nil) ((D :: Cp :: nil) ++ (A :: B :: E :: Cp :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDECpp2mtmp;try rewrite HT2 in HABDECpp2mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: E :: Cp :: p2 :: nil) (Cp :: nil) 4 1 2 HABDECpp2mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABECp requis par la preuve de (?)ABECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABECp requis par la preuve de (?)ABECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: B :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HABECpm2 : rk(A :: B :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 2) by (solve_hyps_min HABCpeq HABCpm2).
	assert(Hincl : incl (A :: B :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: B :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: B :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: B :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: B :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: B :: E :: Cp :: nil) (A :: B :: Cp :: nil) 5 2 5 HABCDECpmtmp HABCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABECpm3 : rk(A :: B :: E :: Cp :: nil) >= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABECpp2mtmp : rk(A :: B :: E :: Cp :: p2 :: nil) >= 3) by (solve_hyps_min HABECpp2eq HABECpp2m3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: E :: Cp :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: Cp :: p2 :: nil) (A :: B :: E :: Cp :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: Cp :: A :: p2 :: nil) ((A :: B :: E :: Cp :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABECpp2mtmp;try rewrite HT2 in HABECpp2mtmp.
	assert(HT := rule_2 (A :: B :: E :: Cp :: nil) (A :: p2 :: nil) (A :: nil) 3 1 1 HABECpp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour BCDEp2 requis par la preuve de (?)BCDEp2 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 ::  de rang :  5 et 6 	 AiB : B :: E ::  de rang :  1 et 2 	 A : A :: B :: E :: Cp ::   de rang : 3 et 4 *)
assert(HBCDEp2m2 : rk(B :: C :: D :: E :: p2 :: nil) >= 2).
{
	assert(HABECpMtmp : rk(A :: B :: E :: Cp :: nil) <= 4) by (solve_hyps_max HABECpeq HABECpM4).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HBEmtmp : rk(B :: E :: nil) >= 1) by (solve_hyps_min HBEeq HBEm1).
	assert(Hincl : incl (B :: E :: nil) (list_inter (A :: B :: E :: Cp :: nil) (B :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: E :: Cp :: B :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: Cp :: B :: C :: D :: E :: p2 :: nil) ((A :: B :: E :: Cp :: nil) ++ (B :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_4 (A :: B :: E :: Cp :: nil) (B :: C :: D :: E :: p2 :: nil) (B :: E :: nil) 5 1 4 HABCDECpp2mtmp HBEmtmp HABECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Dp :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : A :: Dp ::   de rang : 1 et 2 *)
assert(HBCDEp2m3 : rk(B :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HADpMtmp : rk(A :: Dp :: nil) <= 2) by (solve_hyps_max HADpeq HADpM2).
	assert(HABCDEDpp2mtmp : rk(A :: B :: C :: D :: E :: Dp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEDpp2eq HABCDEDpp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Dp :: nil) (B :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Dp :: p2 :: nil) (A :: Dp :: B :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Dp :: B :: C :: D :: E :: p2 :: nil) ((A :: Dp :: nil) ++ (B :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEDpp2mtmp;try rewrite HT2 in HABCDEDpp2mtmp.
	assert(HT := rule_4 (A :: Dp :: nil) (B :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEDpp2mtmp Hmtmp HADpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 ::  de rang :  5 et 5 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HBCDEp2m4 : rk(B :: C :: D :: E :: p2 :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2eq HABCDEp1p2m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: p1 :: nil) (B :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: nil) (A :: B :: p1 :: B :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: B :: C :: D :: E :: p2 :: nil) ((A :: B :: p1 :: nil) ++ (B :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2mtmp;try rewrite HT2 in HABCDEp1p2mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (B :: C :: D :: E :: p2 :: nil) (B :: nil) 5 1 2 HABCDEp1p2mtmp HBmtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 5) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p2 ::  de rang :  5 et 5 	 AiB : p2 ::  de rang :  1 et 1 	 A : A :: p2 ::   de rang : 1 et 1 *)
assert(HBCDEp2m5 : rk(B :: C :: D :: E :: p2 :: nil) >= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCDEp2eq : rk(A :: B :: C :: D :: E :: p2 :: nil) = 5) by (apply LABCDEp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp2mtmp : rk(A :: B :: C :: D :: E :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEp2eq HABCDEp2m5).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (A :: p2 :: nil) (B :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: nil) (A :: p2 :: B :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: B :: C :: D :: E :: p2 :: nil) ((A :: p2 :: nil) ++ (B :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp2mtmp;try rewrite HT2 in HABCDEp2mtmp.
	assert(HT := rule_4 (A :: p2 :: nil) (B :: C :: D :: E :: p2 :: nil) (p2 :: nil) 5 1 1 HABCDEp2mtmp Hp2mtmp HAp2Mtmp Hincl); apply HT.
}

assert(HBCDEp2M : rk(B :: C :: D :: E :: p2 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HBCDEp2eq HBCDEp2M5).
assert(HBCDEp2m : rk(B :: C :: D :: E :: p2 ::  nil) >= 1) by (solve_hyps_min HBCDEp2eq HBCDEp2m1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCp2 *)
(* dans constructLemma(), requis par LDEp2 *)
(* dans constructLemma(), requis par LADEp2 *)
(* dans constructLemma(), requis par LACDEp1p2 *)
(* dans constructLemma(), requis par LABCDEp1p2 *)
(* dans la couche 0 *)
Lemma LABCDEp1p2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p1 :: p2 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABCDEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2 requis par la preuve de (?)ABCDEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2 requis par la preuve de (?)ABCDEp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCDEp1p2M5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 2 4 1 HABp1Mtmp HACDEp2Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCDEp1p2M : rk(A :: B :: C :: D :: E :: p1 :: p2 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp1p2m : rk(A :: B :: C :: D :: E :: p1 :: p2 ::  nil) >= 1) by (solve_hyps_min HABCDEp1p2eq HABCDEp1p2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACDEp1p2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C :: D :: E :: p1 :: p2 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEp1p2 requis par la preuve de (?)ACDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2 requis par la preuve de (?)ACDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2 requis par la preuve de (?)ABCDEp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)ACDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEp1p2 requis par la preuve de (?)ACDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2 requis par la preuve de (?)ACDEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2 requis par la preuve de (?)ACDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2 requis par la preuve de (?)ABCDECpp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2 requis par la preuve de (?)ACDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p2 requis par la preuve de (?)ACDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p2 requis par la preuve de (?)ABCDEApBpp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p2m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2 requis par la preuve de (?)ACDEp1p2 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p2m2 : rk(A :: C :: D :: E :: p1 :: p2 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p2mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2eq HABCDEApBpp1p2m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2mtmp;try rewrite HT2 in HABCDEApBpp1p2mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p2m3 : rk(A :: C :: D :: E :: p1 :: p2 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2eq HABCDECpp1p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2mtmp;try rewrite HT2 in HABCDECpp1p2mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: nil) (nil) 5 0 2 HABCDECpp1p2mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp1p2M5 : rk(A :: C :: D :: E :: p1 :: p2 :: nil) <= 5).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: nil) (p1 :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: C :: D :: E :: p2 :: nil) ((p1 :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 Hp1Mtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p2m4 : rk(A :: C :: D :: E :: p1 :: p2 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2eq HABCDEp1p2m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2mtmp;try rewrite HT2 in HABCDEp1p2mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 5) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 ::  de rang :  5 et 5 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2m5 : rk(A :: C :: D :: E :: p1 :: p2 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2eq : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) = 5) by (apply LABCDEp1p2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1p2mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2eq HABCDEp1p2m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2mtmp;try rewrite HT2 in HABCDEp1p2mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

assert(HACDEp1p2M : rk(A :: C :: D :: E :: p1 :: p2 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HACDEp1p2m : rk(A :: C :: D :: E :: p1 :: p2 ::  nil) >= 1) by (solve_hyps_min HACDEp1p2eq HACDEp1p2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADEp2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: D :: E :: p2 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 ::  de rang :  5 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp2m3 : rk(A :: D :: E :: p2 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2eq : rk(A :: C :: D :: E :: p1 :: p2 :: nil) = 5) by (apply LACDEp1p2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACDEp1p2mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HACDEp1p2eq HACDEp1p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: nil) (C :: p1 :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p2 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2mtmp;try rewrite HT2 in HACDEp1p2mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p2 :: nil) (nil) 5 0 2 HACDEp1p2mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

assert(HADEp2M : rk(A :: D :: E :: p2 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HADEp2eq HADEp2M4).
assert(HADEp2m : rk(A :: D :: E :: p2 ::  nil) >= 1) by (solve_hyps_min HADEp2eq HADEp2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDEp2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(D :: E :: p2 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour DEp2 requis par la preuve de (?)DEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour DEp2 requis par la preuve de (?)DEp2 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 ::  de rang :  5 et 5 	 AiB :  de rang :  0 et 0 	 A : A :: C :: p1 ::   de rang : 3 et 3 *)
assert(HDEp2m2 : rk(D :: E :: p2 :: nil) >= 2).
{
	assert(HACp1eq : rk(A :: C :: p1 :: nil) = 3) by (apply LACp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1Mtmp : rk(A :: C :: p1 :: nil) <= 3) by (solve_hyps_max HACp1eq HACp1M3).
	assert(HACDEp1p2eq : rk(A :: C :: D :: E :: p1 :: p2 :: nil) = 5) by (apply LACDEp1p2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACDEp1p2mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HACDEp1p2eq HACDEp1p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: p1 :: nil) (D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: nil) (A :: C :: p1 :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: p1 :: D :: E :: p2 :: nil) ((A :: C :: p1 :: nil) ++ (D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2mtmp;try rewrite HT2 in HACDEp1p2mtmp.
	assert(HT := rule_4 (A :: C :: p1 :: nil) (D :: E :: p2 :: nil) (nil) 5 0 3 HACDEp1p2mtmp Hmtmp HACp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: D :: E :: p2 ::  de rang :  3 et 3 	 AiB : p2 ::  de rang :  1 et 1 	 A : A :: p2 ::   de rang : 1 et 1 *)
assert(HDEp2m3 : rk(D :: E :: p2 :: nil) >= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HADEp2eq : rk(A :: D :: E :: p2 :: nil) = 3) by (apply LADEp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADEp2mtmp : rk(A :: D :: E :: p2 :: nil) >= 3) by (solve_hyps_min HADEp2eq HADEp2m3).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (A :: p2 :: nil) (D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (A :: p2 :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: D :: E :: p2 :: nil) ((A :: p2 :: nil) ++ (D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp2mtmp;try rewrite HT2 in HADEp2mtmp.
	assert(HT := rule_4 (A :: p2 :: nil) (D :: E :: p2 :: nil) (p2 :: nil) 3 1 1 HADEp2mtmp Hp2mtmp HAp2Mtmp Hincl); apply HT.
}

assert(HDEp2M : rk(D :: E :: p2 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HDEp2eq HDEp2M3).
assert(HDEp2m : rk(D :: E :: p2 ::  nil) >= 1) by (solve_hyps_min HDEp2eq HDEp2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCp2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(B :: C :: p2 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCp2 requis par la preuve de (?)BCp2 pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCEp1p2 requis par la preuve de (?)BCp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp2 requis par la preuve de (?)ABCEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ACEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp2 requis par la preuve de (?)ACEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp2 requis par la preuve de (?)ACEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp2M3 : rk(A :: C :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p2 :: nil) (E :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: p2 :: nil) ((E :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HEMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HACEp2m2 : rk(A :: C :: E :: p2 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: C :: E :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: C :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp2m3 : rk(A :: B :: C :: E :: p2 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2 requis par la preuve de (?)ABCDECpp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p2 requis par la preuve de (?)ABCDEApBpp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p2m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp1p2m2 : rk(A :: B :: C :: E :: p1 :: p2 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp1p2mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2eq HABCDEApBpp1p2m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p2 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2mtmp;try rewrite HT2 in HABCDEApBpp1p2mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp1p2m3 : rk(A :: B :: C :: E :: p1 :: p2 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1p2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2eq HABCDECpp1p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) (D :: Cp :: A :: B :: C :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p1 :: p2 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2mtmp;try rewrite HT2 in HABCDECpp1p2mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil) (nil) 5 0 2 HABCDECpp1p2mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1p2M5 : rk(A :: B :: C :: E :: p1 :: p2 :: nil) <= 5).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p2 :: nil) (p1 :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: B :: C :: E :: p2 :: nil) ((p1 :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 Hp1Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCEp1p2M4 : rk(A :: B :: C :: E :: p1 :: p2 :: nil) <= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HACEp2Mtmp : rk(A :: C :: E :: p2 :: nil) <= 3) by (solve_hyps_max HACEp2eq HACEp2M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p2 :: nil) (A :: B :: p1 :: A :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: E :: p2 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: C :: E :: p2 :: nil) (A :: nil) 2 3 1 HABp1Mtmp HACEp2Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HABCEp1p2m4 : rk(A :: B :: C :: E :: p1 :: p2 :: nil) >= 4).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HABCDEp1p2eq : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) = 5) by (apply LABCDEp1p2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1p2mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2eq HABCDEp1p2m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: nil) (D :: p1 :: A :: B :: C :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: B :: C :: E :: p1 :: p2 :: nil) ((D :: p1 :: nil) ++ (A :: B :: C :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2mtmp;try rewrite HT2 in HABCDEp1p2mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCp2 requis par la preuve de (?)BCp2 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: E :: p1 :: p2 ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: E :: p1 ::   de rang : 3 et 3 *)
assert(HBCp2m2 : rk(B :: C :: p2 :: nil) >= 2).
{
	assert(HABEp1eq : rk(A :: B :: E :: p1 :: nil) = 3) by (apply LABEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCEp1p2mtmp : rk(A :: B :: C :: E :: p1 :: p2 :: nil) >= 4) by (solve_hyps_min HABCEp1p2eq HABCEp1p2m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: E :: p1 :: nil) (B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p2 :: nil) (A :: B :: E :: p1 :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: p1 :: B :: C :: p2 :: nil) ((A :: B :: E :: p1 :: nil) ++ (B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEp1p2mtmp;try rewrite HT2 in HABCEp1p2mtmp.
	assert(HT := rule_4 (A :: B :: E :: p1 :: nil) (B :: C :: p2 :: nil) (B :: nil) 4 1 3 HABCEp1p2mtmp HBmtmp HABEp1Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HBCp2m3 : rk(B :: C :: p2 :: nil) >= 3).
{
	assert(HDEp2eq : rk(D :: E :: p2 :: nil) = 3) by (apply LDEp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDEp2Mtmp : rk(D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HDEp2eq HDEp2M3).
	assert(HBCDEp2eq : rk(B :: C :: D :: E :: p2 :: nil) = 5) by (apply LBCDEp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HBCDEp2mtmp : rk(B :: C :: D :: E :: p2 :: nil) >= 5) by (solve_hyps_min HBCDEp2eq HBCDEp2m5).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (B :: C :: p2 :: nil) (D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: p2 :: nil) (B :: C :: p2 :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: p2 :: D :: E :: p2 :: nil) ((B :: C :: p2 :: nil) ++ (D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCDEp2mtmp;try rewrite HT2 in HBCDEp2mtmp.
	assert(HT := rule_2 (B :: C :: p2 :: nil) (D :: E :: p2 :: nil) (p2 :: nil) 5 1 3 HBCDEp2mtmp Hp2mtmp HDEp2Mtmp Hincl);apply HT.
}

assert(HBCp2M : rk(B :: C :: p2 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HBCp2eq HBCp2M3).
assert(HBCp2m : rk(B :: C :: p2 ::  nil) >= 1) by (solve_hyps_min HBCp2eq HBCp2m1).
intuition.
Qed.

(* dans constructLemma(), requis par LDp2 *)
(* dans constructLemma(), requis par LADp2 *)
(* dans la couche 0 *)
Lemma LADEp1p2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: D :: E :: p1 :: p2 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADEp1p2 requis par la preuve de (?)ADEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1p2 requis par la preuve de (?)ADEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABDEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABDEp1p2 requis par la preuve de (?)ABDEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp2 requis par la preuve de (?)ABDEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp2 requis par la preuve de (?)ABDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp2 requis par la preuve de (?)ABDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp2 requis par la preuve de (?)ABDp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABp2 requis par la preuve de (?)ABp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABp2M2 : rk(A :: B :: p2 :: nil) <= 2).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: p2 :: nil) (B :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: p2 :: nil) ((B :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: p2 :: nil) (nil) 1 1 0 HBMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp2 requis par la preuve de (?)ABDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDp2M3 : rk(A :: B :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp2Mtmp : rk(A :: B :: p2 :: nil) <= 2) by (solve_hyps_max HABp2eq HABp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p2 :: nil) (D :: A :: B :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p2 :: nil) ((D :: nil) ++ (A :: B :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p2 :: nil) (nil) 1 2 0 HDMtmp HABp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp2 requis par la preuve de (?)ABDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp2M4 : rk(A :: B :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp2Mtmp : rk(A :: B :: D :: p2 :: nil) <= 3) by (solve_hyps_max HABDp2eq HABDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p2 :: nil) (E :: A :: B :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p2 :: nil) ((E :: nil) ++ (A :: B :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HABDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp2m3 : rk(A :: B :: D :: E :: p2 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: B :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p2 requis par la preuve de (?)ABDEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEDpp1p2 requis par la preuve de (?)ABDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEDpp1p2 requis par la preuve de (?)ABCDEDpp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEDpp1p2m5 : rk(A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CDp requis par la preuve de (?)ABDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p2 requis par la preuve de (?)ABDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2 requis par la preuve de (?)ABDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2 requis par la preuve de (?)ABCDECpp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABDEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p2 requis par la preuve de (?)ABDEp1p2 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABDEp1p2m2 : rk(A :: B :: D :: E :: p1 :: p2 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCDECpp1p2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2eq HABCDECpp1p2m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: D :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) (A :: C :: E :: Cp :: A :: B :: D :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: D :: E :: p1 :: p2 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2mtmp;try rewrite HT2 in HABCDECpp1p2mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: D :: E :: p1 :: p2 :: nil) (A :: E :: nil) 5 1 4 HABCDECpp1p2mtmp HAEmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Dp :: p1 :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Dp ::   de rang : 1 et 2 *)
assert(HABDEp1p2m3 : rk(A :: B :: D :: E :: p1 :: p2 :: nil) >= 3).
{
	assert(HCDpMtmp : rk(C :: Dp :: nil) <= 2) by (solve_hyps_max HCDpeq HCDpM2).
	assert(HABCDEDpp1p2mtmp : rk(A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEDpp1p2eq HABCDEDpp1p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Dp :: nil) (A :: B :: D :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: nil) (C :: Dp :: A :: B :: D :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Dp :: A :: B :: D :: E :: p1 :: p2 :: nil) ((C :: Dp :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEDpp1p2mtmp;try rewrite HT2 in HABCDEDpp1p2mtmp.
	assert(HT := rule_4 (C :: Dp :: nil) (A :: B :: D :: E :: p1 :: p2 :: nil) (nil) 5 0 2 HABCDEDpp1p2mtmp Hmtmp HCDpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1p2M5 : rk(A :: B :: D :: E :: p1 :: p2 :: nil) <= 5).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HABDEp2Mtmp : rk(A :: B :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABDEp2eq HABDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: B :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: nil) (p1 :: A :: B :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: B :: D :: E :: p2 :: nil) ((p1 :: nil) ++ (A :: B :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: B :: D :: E :: p2 :: nil) (nil) 1 4 0 Hp1Mtmp HABDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABDEp1p2M4 : rk(A :: B :: D :: E :: p1 :: p2 :: nil) <= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: nil) (A :: B :: p1 :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p2 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 2 3 1 HABp1Mtmp HADEp2Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADEp1p2 requis par la preuve de (?)ADEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ADEp1p2 requis par la preuve de (?)ADEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCECp requis par la preuve de (?)ADEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCCp requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCCpm2 : rk(B :: C :: Cp :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_2 (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDECpp1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : B :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HBCECpm2 : rk(B :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HBCCpmtmp : rk(B :: C :: Cp :: nil) >= 2) by (solve_hyps_min HBCCpeq HBCCpm2).
	assert(Hincl : incl (B :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (B :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil) (B :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HBCCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCECpm3 : rk(B :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (B :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: B :: p1 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCECpp1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ADEp1p2 requis par la preuve de (?)ADEp1p2 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HADEp1p2m2 : rk(A :: D :: E :: p1 :: p2 :: nil) >= 2).
{
	assert(HBCECpMtmp : rk(B :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBCECpeq HBCECpM4).
	assert(HABCDECpp1p2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2eq HABCDECpp1p2m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) (B :: C :: E :: Cp :: A :: D :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: D :: E :: p1 :: p2 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: D :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2mtmp;try rewrite HT2 in HABCDECpp1p2mtmp.
	assert(HT := rule_4 (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: p2 :: nil) (E :: nil) 5 1 4 HABCDECpp1p2mtmp HEmtmp HBCECpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp1p2M4 : rk(A :: D :: E :: p1 :: p2 :: nil) <= 4).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: nil) (p1 :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: D :: E :: p2 :: nil) ((p1 :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: D :: E :: p2 :: nil) (nil) 1 3 0 Hp1Mtmp HADEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p2 ::  de rang :  3 et 4 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2m3 : rk(A :: D :: E :: p1 :: p2 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p2mtmp : rk(A :: B :: D :: E :: p1 :: p2 :: nil) >= 3) by (solve_hyps_min HABDEp1p2eq HABDEp1p2m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p2mtmp;try rewrite HT2 in HABDEp1p2mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p2mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2m4 : rk(A :: D :: E :: p1 :: p2 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2eq : rk(A :: C :: D :: E :: p1 :: p2 :: nil) = 5) by (apply LACDEp1p2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACDEp1p2mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HACDEp1p2eq HACDEp1p2m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p2 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2mtmp;try rewrite HT2 in HACDEp1p2mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

assert(HADEp1p2M : rk(A :: D :: E :: p1 :: p2 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HADEp1p2eq HADEp1p2M5).
assert(HADEp1p2m : rk(A :: D :: E :: p1 :: p2 ::  nil) >= 1) by (solve_hyps_min HADEp1p2eq HADEp1p2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADp2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: D :: p2 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : E :: p1 ::   de rang : 2 et 2 *)
assert(HADp2m2 : rk(A :: D :: p2 :: nil) >= 2).
{
	assert(HEp1eq : rk(E :: p1 :: nil) = 2) by (apply LEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HEp1Mtmp : rk(E :: p1 :: nil) <= 2) by (solve_hyps_max HEp1eq HEp1M2).
	assert(HADEp1p2eq : rk(A :: D :: E :: p1 :: p2 :: nil) = 4) by (apply LADEp1p2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADEp1p2mtmp : rk(A :: D :: E :: p1 :: p2 :: nil) >= 4) by (solve_hyps_min HADEp1p2eq HADEp1p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: p1 :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: nil) (E :: p1 :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: p1 :: A :: D :: p2 :: nil) ((E :: p1 :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2mtmp;try rewrite HT2 in HADEp1p2mtmp.
	assert(HT := rule_4 (E :: p1 :: nil) (A :: D :: p2 :: nil) (nil) 4 0 2 HADEp1p2mtmp Hmtmp HEp1Mtmp Hincl); apply HT.
}

assert(HADp2M : rk(A :: D :: p2 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HADp2eq HADp2M3).
assert(HADp2m : rk(A :: D :: p2 ::  nil) >= 1) by (solve_hyps_min HADp2eq HADp2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDp2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(D :: p2 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dp2 requis par la preuve de (?)Dp2 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: D :: p2 ::  de rang :  2 et 2 	 AiB : p2 ::  de rang :  1 et 1 	 A : A :: p2 ::   de rang : 1 et 1 *)
assert(HDp2m2 : rk(D :: p2 :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HADp2eq : rk(A :: D :: p2 :: nil) = 2) by (apply LADp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADp2mtmp : rk(A :: D :: p2 :: nil) >= 2) by (solve_hyps_min HADp2eq HADp2m2).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (A :: p2 :: nil) (D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (A :: p2 :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: D :: p2 :: nil) ((A :: p2 :: nil) ++ (D :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADp2mtmp;try rewrite HT2 in HADp2mtmp.
	assert(HT := rule_4 (A :: p2 :: nil) (D :: p2 :: nil) (p2 :: nil) 2 1 1 HADp2mtmp Hp2mtmp HAp2Mtmp Hincl); apply HT.
}

assert(HDp2M : rk(D :: p2 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max HDp2eq HDp2M2).
assert(HDp2m : rk(D :: p2 ::  nil) >= 1) by (solve_hyps_min HDp2eq HDp2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAEp2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: E :: p2 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AEp2 requis par la preuve de (?)AEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AEp2 requis par la preuve de (?)AEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAEp2M2 : rk(A :: E :: p2 :: nil) <= 2).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: nil) (E :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: p2 :: nil) ((E :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: p2 :: nil) (nil) 1 1 0 HEMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HAEp2m2 : rk(A :: E :: p2 :: nil) >= 2).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HADEp1p2eq : rk(A :: D :: E :: p1 :: p2 :: nil) = 4) by (apply LADEp1p2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADEp1p2mtmp : rk(A :: D :: E :: p1 :: p2 :: nil) >= 4) by (solve_hyps_min HADEp1p2eq HADEp1p2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: p1 :: nil) (A :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: nil) (D :: p1 :: A :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: E :: p2 :: nil) ((D :: p1 :: nil) ++ (A :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2mtmp;try rewrite HT2 in HADEp1p2mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: E :: p2 :: nil) (nil) 4 0 2 HADEp1p2mtmp Hmtmp HDp1Mtmp Hincl); apply HT.
}

assert(HAEp2M : rk(A :: E :: p2 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HAEp2eq HAEp2M3).
assert(HAEp2m : rk(A :: E :: p2 ::  nil) >= 1) by (solve_hyps_min HAEp2eq HAEp2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpCpDpEpp2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour AApBpCpDpEpp2 requis par la preuve de (?)AApBpCpDpEpp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour AApBpCpDpEpp2 requis par la preuve de (?)AApBpCpDpEpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpCpDpEpp2m5 : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAApBpCpDpEpp2M5 : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HApBpCpDpEpp2Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp2eq HApBpCpDpEpp2M5).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (A :: p2 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) (A :: p2 :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) ((A :: p2 :: nil) ++ (Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) (p2 :: nil) 1 5 1 HAp2Mtmp HApBpCpDpEpp2Mtmp Hp2mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAApBpCpDpEpp2M : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HAApBpCpDpEpp2m : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) >= 1) by (solve_hyps_min HAApBpCpDpEpp2eq HAApBpCpDpEpp2m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCEp1p2 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: E :: p1 :: p2 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp2 requis par la preuve de (?)ABCEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ACEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp2 requis par la preuve de (?)ACEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp2 requis par la preuve de (?)ACEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp2M3 : rk(A :: C :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p2 :: nil) (E :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: p2 :: nil) ((E :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HEMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HACEp2m2 : rk(A :: C :: E :: p2 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: C :: E :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: C :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp2m3 : rk(A :: B :: C :: E :: p2 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2 requis par la preuve de (?)ABCDECpp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p2 requis par la preuve de (?)ABCDEApBpp1p2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p2m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp1p2 requis par la preuve de (?)ABCEp1p2 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp1p2m2 : rk(A :: B :: C :: E :: p1 :: p2 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp1p2mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2eq HABCDEApBpp1p2m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p2 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2mtmp;try rewrite HT2 in HABCDEApBpp1p2mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp1p2m3 : rk(A :: B :: C :: E :: p1 :: p2 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1p2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2eq HABCDECpp1p2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: nil) (D :: Cp :: A :: B :: C :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p1 :: p2 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2mtmp;try rewrite HT2 in HABCDECpp1p2mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil) (nil) 5 0 2 HABCDECpp1p2mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1p2M5 : rk(A :: B :: C :: E :: p1 :: p2 :: nil) <= 5).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p2 :: nil) (p1 :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: B :: C :: E :: p2 :: nil) ((p1 :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 Hp1Mtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCEp1p2M4 : rk(A :: B :: C :: E :: p1 :: p2 :: nil) <= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HACEp2Mtmp : rk(A :: C :: E :: p2 :: nil) <= 3) by (solve_hyps_max HACEp2eq HACEp2M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p2 :: nil) (A :: B :: p1 :: A :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: E :: p2 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: C :: E :: p2 :: nil) (A :: nil) 2 3 1 HABp1Mtmp HACEp2Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HABCEp1p2m4 : rk(A :: B :: C :: E :: p1 :: p2 :: nil) >= 4).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HABCDEp1p2eq : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) = 5) by (apply LABCDEp1p2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1p2mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2eq HABCDEp1p2m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: nil) (D :: p1 :: A :: B :: C :: E :: p1 :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: B :: C :: E :: p1 :: p2 :: nil) ((D :: p1 :: nil) ++ (A :: B :: C :: E :: p1 :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2mtmp;try rewrite HT2 in HABCDEp1p2mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p2 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

assert(HABCEp1p2M : rk(A :: B :: C :: E :: p1 :: p2 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCEp1p2m : rk(A :: B :: C :: E :: p1 :: p2 ::  nil) >= 1) by (solve_hyps_min HABCEp1p2eq HABCEp1p2m1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCp3 *)
(* dans constructLemma(), requis par LABCDp3 *)
(* dans constructLemma(), requis par LABCDEp2p3 *)
(* dans la couche 0 *)
Lemma LABCDEp3 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p3 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDEp3 requis par la preuve de (?)ABCDEp3 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCDp3 requis par la preuve de (?)ABCDEp3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCDp3 requis par la preuve de (?)ABCDp3 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp3 requis par la preuve de (?)ABCDp3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp3 requis par la preuve de (?)ABDp3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp3M3 : rk(A :: B :: D :: p3 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p3 :: nil) (B :: A :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: D :: p3 :: nil) ((B :: nil) ++ (A :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: D :: p3 :: nil) (nil) 1 2 0 HBMtmp HADp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDp3 requis par la preuve de (?)ABCDp3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDp3M4 : rk(A :: B :: C :: D :: p3 :: nil) <= 4).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABDp3Mtmp : rk(A :: B :: D :: p3 :: nil) <= 3) by (solve_hyps_max HABDp3eq HABDp3M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: p3 :: nil) (C :: A :: B :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: D :: p3 :: nil) ((C :: nil) ++ (A :: B :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: D :: p3 :: nil) (nil) 1 3 0 HCMtmp HABDp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCDp3m2 : rk(A :: B :: C :: D :: p3 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: D :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: D :: p3 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp3 requis par la preuve de (?)ABCDEp3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDEp3M5 : rk(A :: B :: C :: D :: E :: p3 :: nil) <= 5).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCDp3Mtmp : rk(A :: B :: C :: D :: p3 :: nil) <= 4) by (solve_hyps_max HABCDp3eq HABCDp3M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p3 :: nil) (E :: A :: B :: C :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: D :: p3 :: nil) ((E :: nil) ++ (A :: B :: C :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: D :: p3 :: nil) (nil) 1 4 0 HEMtmp HABCDp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp3m5 : rk(A :: B :: C :: D :: E :: p3 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p3 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

assert(HABCDEp3M : rk(A :: B :: C :: D :: E :: p3 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp3m : rk(A :: B :: C :: D :: E :: p3 ::  nil) >= 1) by (solve_hyps_min HABCDEp3eq HABCDEp3m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCDEp2p3 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p2 :: p3 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp2p3 requis par la preuve de (?)ABCDEp2p3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp2p3 requis par la preuve de (?)ABCDEp2p3 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp2p3m5 : rk(A :: B :: C :: D :: E :: p2 :: p3 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p2 :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p2 :: p3 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -2*)
assert(HABCDEp2p3M5 : rk(A :: B :: C :: D :: E :: p2 :: p3 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCDEp3eq : rk(A :: B :: C :: D :: E :: p3 :: nil) = 5) by (apply LABCDEp3 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp3Mtmp : rk(A :: B :: C :: D :: E :: p3 :: nil) <= 5) by (solve_hyps_max HABCDEp3eq HABCDEp3M5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: B :: C :: D :: E :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: p3 :: nil) (A :: p2 :: A :: B :: C :: D :: E :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: B :: C :: D :: E :: p3 :: nil) ((A :: p2 :: nil) ++ (A :: B :: C :: D :: E :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: B :: C :: D :: E :: p3 :: nil) (A :: nil) 1 5 1 HAp2Mtmp HABCDEp3Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCDEp2p3M : rk(A :: B :: C :: D :: E :: p2 :: p3 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp2p3m : rk(A :: B :: C :: D :: E :: p2 :: p3 ::  nil) >= 1) by (solve_hyps_min HABCDEp2p3eq HABCDEp2p3m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCDp3 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: p3 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCDp3 requis par la preuve de (?)ABCDp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp3 requis par la preuve de (?)ABCDp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp3 requis par la preuve de (?)ABCDEApp3 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp3m5 : rk(A :: B :: C :: D :: E :: Ap :: p3 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p3 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCDp3 requis par la preuve de (?)ABCDp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCDp3 requis par la preuve de (?)ABCDp3 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp3 requis par la preuve de (?)ABCDp3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp3 requis par la preuve de (?)ABDp3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp3M3 : rk(A :: B :: D :: p3 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p3 :: nil) (B :: A :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: D :: p3 :: nil) ((B :: nil) ++ (A :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: D :: p3 :: nil) (nil) 1 2 0 HBMtmp HADp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDp3 requis par la preuve de (?)ABCDp3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDp3M4 : rk(A :: B :: C :: D :: p3 :: nil) <= 4).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABDp3Mtmp : rk(A :: B :: D :: p3 :: nil) <= 3) by (solve_hyps_max HABDp3eq HABDp3M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: p3 :: nil) (C :: A :: B :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: D :: p3 :: nil) ((C :: nil) ++ (A :: B :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: D :: p3 :: nil) (nil) 1 3 0 HCMtmp HABDp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCDp3m2 : rk(A :: B :: C :: D :: p3 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: D :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: D :: p3 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p3 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDp3m3 : rk(A :: B :: C :: D :: p3 :: nil) >= 3).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApp3mtmp : rk(A :: B :: C :: D :: E :: Ap :: p3 :: nil) >= 5) by (solve_hyps_min HABCDEApp3eq HABCDEApp3m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p3 :: nil) (E :: Ap :: A :: B :: C :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: p3 :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp3mtmp;try rewrite HT2 in HABCDEApp3mtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: p3 :: nil) (nil) 5 0 2 HABCDEApp3mtmp Hmtmp HEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p2 :: p3 ::  de rang :  5 et 5 	 AiB : A ::  de rang :  1 et 1 	 A : A :: E :: p2 ::   de rang : 2 et 2 *)
assert(HABCDp3m4 : rk(A :: B :: C :: D :: p3 :: nil) >= 4).
{
	assert(HAEp2eq : rk(A :: E :: p2 :: nil) = 2) by (apply LAEp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAEp2Mtmp : rk(A :: E :: p2 :: nil) <= 2) by (solve_hyps_max HAEp2eq HAEp2M2).
	assert(HABCDEp2p3eq : rk(A :: B :: C :: D :: E :: p2 :: p3 :: nil) = 5) by (apply LABCDEp2p3 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp2p3mtmp : rk(A :: B :: C :: D :: E :: p2 :: p3 :: nil) >= 5) by (solve_hyps_min HABCDEp2p3eq HABCDEp2p3m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: E :: p2 :: nil) (A :: B :: C :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: p3 :: nil) (A :: E :: p2 :: A :: B :: C :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p2 :: A :: B :: C :: D :: p3 :: nil) ((A :: E :: p2 :: nil) ++ (A :: B :: C :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp2p3mtmp;try rewrite HT2 in HABCDEp2p3mtmp.
	assert(HT := rule_4 (A :: E :: p2 :: nil) (A :: B :: C :: D :: p3 :: nil) (A :: nil) 5 1 2 HABCDEp2p3mtmp HAmtmp HAEp2Mtmp Hincl); apply HT.
}

assert(HABCDp3M : rk(A :: B :: C :: D :: p3 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HABCDp3eq HABCDp3M5).
assert(HABCDp3m : rk(A :: B :: C :: D :: p3 ::  nil) >= 1) by (solve_hyps_min HABCDp3eq HABCDp3m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCp3 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(B :: C :: p3 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCp3 requis par la preuve de (?)BCp3 pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEp1p3 requis par la preuve de (?)BCp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 5 pour ABCDEp1p3 requis par la preuve de (?)ABCEp1p3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp3 requis par la preuve de (?)ABCDEp1p3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp3 requis par la preuve de (?)ACDEp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp3 requis par la preuve de (?)ABCDEApp3 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp3m5 : rk(A :: B :: C :: D :: E :: Ap :: p3 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p3 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp3 requis par la preuve de (?)ACDEp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACDp3 requis par la preuve de (?)ACDEp3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp3 requis par la preuve de (?)ACDp3 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp3 requis par la preuve de (?)ACDp3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp3M3 : rk(A :: C :: D :: p3 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p3 :: nil) (C :: A :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: D :: p3 :: nil) ((C :: nil) ++ (A :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: D :: p3 :: nil) (nil) 1 2 0 HCMtmp HADp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDp3m2 : rk(A :: C :: D :: p3 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: D :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: D :: p3 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp3 requis par la preuve de (?)ACDEp3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp3M4 : rk(A :: C :: D :: E :: p3 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp3Mtmp : rk(A :: C :: D :: p3 :: nil) <= 3) by (solve_hyps_max HACDp3eq HACDp3M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p3 :: nil) (E :: A :: C :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p3 :: nil) ((E :: nil) ++ (A :: C :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p3 :: nil) (nil) 1 3 0 HEMtmp HACDp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p3 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp3m3 : rk(A :: C :: D :: E :: p3 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp3mtmp : rk(A :: B :: C :: D :: E :: Ap :: p3 :: nil) >= 5) by (solve_hyps_min HABCDEApp3eq HABCDEApp3m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p3 :: nil) (B :: Ap :: A :: C :: D :: E :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p3 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p3 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp3mtmp;try rewrite HT2 in HABCDEApp3mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p3 :: nil) (nil) 5 0 2 HABCDEApp3mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p3 requis par la preuve de (?)ABCDEp1p3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p3 requis par la preuve de (?)ABCDEp1p3 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p3m5 : rk(A :: B :: C :: D :: E :: p1 :: p3 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCDEp1p3M5 : rk(A :: B :: C :: D :: E :: p1 :: p3 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HACDEp3Mtmp : rk(A :: C :: D :: E :: p3 :: nil) <= 4) by (solve_hyps_max HACDEp3eq HACDEp3M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p3 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p3 :: nil) (A :: nil) 2 4 1 HABp1Mtmp HACDEp3Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEp1p3 requis par la preuve de (?)ABCEp1p3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CEp3 requis par la preuve de (?)ABCEp1p3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp1p3 requis par la preuve de (?)ABCEp1p3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p3 requis par la preuve de (?)ABCEp1p3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p3 requis par la preuve de (?)ABCDECpp1p3 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p3m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCEp1p3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp1p3 requis par la preuve de (?)ABCEp1p3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p3 requis par la preuve de (?)ABCEp1p3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p3 requis par la preuve de (?)ABCDEApBpp1p3 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p3m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCEp1p3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp1p3 requis par la preuve de (?)ABCEp1p3 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp1p3m2 : rk(A :: B :: C :: E :: p1 :: p3 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp1p3mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p3eq HABCDEApBpp1p3m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p3 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p1 :: p3 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p3mtmp;try rewrite HT2 in HABCDEApBpp1p3mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p3 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p3mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p3 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp1p3m3 : rk(A :: B :: C :: E :: p1 :: p3 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1p3mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p3eq HABCDECpp1p3m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: nil) (D :: Cp :: A :: B :: C :: E :: p1 :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p1 :: p3 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p1 :: p3 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p3mtmp;try rewrite HT2 in HABCDECpp1p3mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p3 :: nil) (nil) 5 0 2 HABCDECpp1p3mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HABCEp1p3M5 : rk(A :: B :: C :: E :: p1 :: p3 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HCEp3Mtmp : rk(C :: E :: p3 :: nil) <= 3) by (solve_hyps_max HCEp3eq HCEp3M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: p1 :: nil) (C :: E :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p3 :: nil) (A :: B :: p1 :: C :: E :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: C :: E :: p3 :: nil) ((A :: B :: p1 :: nil) ++ (C :: E :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (C :: E :: p3 :: nil) (nil) 2 3 0 HABp1Mtmp HCEp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 ::  de rang :  5 et 5 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HABCEp1p3m4 : rk(A :: B :: C :: E :: p1 :: p3 :: nil) >= 4).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HABCDEp1p3mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3eq HABCDEp1p3m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: nil) (D :: p1 :: A :: B :: C :: E :: p1 :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: B :: C :: E :: p1 :: p3 :: nil) ((D :: p1 :: nil) ++ (A :: B :: C :: E :: p1 :: p3 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3mtmp;try rewrite HT2 in HABCDEp1p3mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p3 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p3mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCp3 requis par la preuve de (?)BCp3 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: E :: p1 :: p3 ::  de rang :  4 et 5 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: E :: p1 ::   de rang : 3 et 3 *)
assert(HBCp3m2 : rk(B :: C :: p3 :: nil) >= 2).
{
	assert(HABEp1eq : rk(A :: B :: E :: p1 :: nil) = 3) by (apply LABEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCEp1p3mtmp : rk(A :: B :: C :: E :: p1 :: p3 :: nil) >= 4) by (solve_hyps_min HABCEp1p3eq HABCEp1p3m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: E :: p1 :: nil) (B :: C :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p3 :: nil) (A :: B :: E :: p1 :: B :: C :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: p1 :: B :: C :: p3 :: nil) ((A :: B :: E :: p1 :: nil) ++ (B :: C :: p3 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEp1p3mtmp;try rewrite HT2 in HABCEp1p3mtmp.
	assert(HT := rule_4 (A :: B :: E :: p1 :: nil) (B :: C :: p3 :: nil) (B :: nil) 4 1 3 HABCEp1p3mtmp HBmtmp HABEp1Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HBCp3m3 : rk(B :: C :: p3 :: nil) >= 3).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HABCDp3eq : rk(A :: B :: C :: D :: p3 :: nil) = 4) by (apply LABCDp3 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDp3mtmp : rk(A :: B :: C :: D :: p3 :: nil) >= 4) by (solve_hyps_min HABCDp3eq HABCDp3m4).
	assert(Hp3mtmp : rk(p3 :: nil) >= 1) by (solve_hyps_min Hp3eq Hp3m1).
	assert(Hincl : incl (p3 :: nil) (list_inter (B :: C :: p3 :: nil) (A :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: p3 :: nil) (B :: C :: p3 :: A :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: p3 :: A :: D :: p3 :: nil) ((B :: C :: p3 :: nil) ++ (A :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDp3mtmp;try rewrite HT2 in HABCDp3mtmp.
	assert(HT := rule_2 (B :: C :: p3 :: nil) (A :: D :: p3 :: nil) (p3 :: nil) 4 1 2 HABCDp3mtmp Hp3mtmp HADp3Mtmp Hincl);apply HT.
}

assert(HBCp3M : rk(B :: C :: p3 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HBCp3eq HBCp3M3).
assert(HBCp3m : rk(B :: C :: p3 ::  nil) >= 1) by (solve_hyps_min HBCp3eq HBCp3m1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCDEp1p3 *)
(* dans la couche 0 *)
Lemma LABCDEp1p3 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p1 :: p3 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp3 requis par la preuve de (?)ABCDEp1p3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp3 requis par la preuve de (?)ACDEp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp3 requis par la preuve de (?)ABCDEApp3 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp3m5 : rk(A :: B :: C :: D :: E :: Ap :: p3 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p3 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp3 requis par la preuve de (?)ACDEp3 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACDp3 requis par la preuve de (?)ACDEp3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp3 requis par la preuve de (?)ACDp3 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp3 requis par la preuve de (?)ACDp3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp3M3 : rk(A :: C :: D :: p3 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p3 :: nil) (C :: A :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: D :: p3 :: nil) ((C :: nil) ++ (A :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: D :: p3 :: nil) (nil) 1 2 0 HCMtmp HADp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDp3m2 : rk(A :: C :: D :: p3 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: D :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: D :: p3 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp3 requis par la preuve de (?)ACDEp3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp3M4 : rk(A :: C :: D :: E :: p3 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp3Mtmp : rk(A :: C :: D :: p3 :: nil) <= 3) by (solve_hyps_max HACDp3eq HACDp3M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p3 :: nil) (E :: A :: C :: D :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p3 :: nil) ((E :: nil) ++ (A :: C :: D :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p3 :: nil) (nil) 1 3 0 HEMtmp HACDp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p3 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp3m3 : rk(A :: C :: D :: E :: p3 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp3mtmp : rk(A :: B :: C :: D :: E :: Ap :: p3 :: nil) >= 5) by (solve_hyps_min HABCDEApp3eq HABCDEApp3m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p3 :: nil) (B :: Ap :: A :: C :: D :: E :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p3 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p3 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp3mtmp;try rewrite HT2 in HABCDEApp3mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p3 :: nil) (nil) 5 0 2 HABCDEApp3mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p3 requis par la preuve de (?)ABCDEp1p3 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p3 requis par la preuve de (?)ABCDEp1p3 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p3m5 : rk(A :: B :: C :: D :: E :: p1 :: p3 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCDEp1p3M5 : rk(A :: B :: C :: D :: E :: p1 :: p3 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HACDEp3Mtmp : rk(A :: C :: D :: E :: p3 :: nil) <= 4) by (solve_hyps_max HACDEp3eq HACDEp3M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p3 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p3 :: nil) (A :: nil) 2 4 1 HABp1Mtmp HACDEp3Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCDEp1p3M : rk(A :: B :: C :: D :: E :: p1 :: p3 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp1p3m : rk(A :: B :: C :: D :: E :: p1 :: p3 ::  nil) >= 1) by (solve_hyps_min HABCDEp1p3eq HABCDEp1p3m1).
intuition.
Qed.

(* dans constructLemma(), requis par Lp2p3 *)
(* dans constructLemma(), requis par LAEp2p3p4 *)
(* dans constructLemma(), requis par LADEp2p3p4 *)
(* dans la couche 0 *)
Lemma LAEp2p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: E :: p2 :: p4 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AEp2p4 requis par la preuve de (?)AEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AEp2p4 requis par la preuve de (?)AEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)AEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ABCDEp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2p4 requis par la preuve de (?)ABCDECpp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p2p4 requis par la preuve de (?)ABCDEApBpp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p2p4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p2p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p2p4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2p4eq HABCDEApBpp1p2p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2p4mtmp;try rewrite HT2 in HABCDEApBpp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2p4mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p2p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p4eq HABCDECpp1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p4mtmp;try rewrite HT2 in HABCDECpp1p2p4mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDECpp1p2p4mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEDpp1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEDpp1p2p4 requis par la preuve de (?)ABCDEDpp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEDpp1p2p4m5 : rk(A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CDp requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p2p4 requis par la preuve de (?)ABDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABDEp1p2p4m2 : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCDECpp1p2p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p4eq HABCDECpp1p2p4m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) (A :: C :: E :: Cp :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p4mtmp;try rewrite HT2 in HABCDECpp1p2p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: E :: nil) 5 1 4 HABCDECpp1p2p4mtmp HAEmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Dp ::   de rang : 1 et 2 *)
assert(HABDEp1p2p4m3 : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HCDpMtmp : rk(C :: Dp :: nil) <= 2) by (solve_hyps_max HCDpeq HCDpM2).
	assert(HABCDEDpp1p2p4mtmp : rk(A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEDpp1p2p4eq HABCDEDpp1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Dp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p4 :: nil) (C :: Dp :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Dp :: A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) ((C :: Dp :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEDpp1p2p4mtmp;try rewrite HT2 in HABCDEDpp1p2p4mtmp.
	assert(HT := rule_4 (C :: Dp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDEDpp1p2p4mtmp Hmtmp HCDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCECp requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCCp requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCCpm2 : rk(B :: C :: Cp :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_2 (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDECpp1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : B :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HBCECpm2 : rk(B :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HBCCpmtmp : rk(B :: C :: Cp :: nil) >= 2) by (solve_hyps_min HBCCpeq HBCCpm2).
	assert(Hincl : incl (B :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (B :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil) (B :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HBCCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCECpm3 : rk(B :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (B :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: B :: p1 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCECpp1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p2p4 requis par la preuve de (?)ADEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HADEp1p2p4m2 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HBCECpMtmp : rk(B :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBCECpeq HBCECpM4).
	assert(HABCDECpp1p2p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p4eq HABCDECpp1p2p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) (B :: C :: E :: Cp :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p4mtmp;try rewrite HT2 in HABCDECpp1p2p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (E :: nil) 5 1 4 HABCDECpp1p2p4mtmp HEmtmp HBCECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p2 :: p4 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p4m3 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p2p4mtmp : rk(A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3) by (solve_hyps_min HABDEp1p2p4eq HABDEp1p2p4m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p2p4mtmp;try rewrite HT2 in HABDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p4m4 : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p4eq HACDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p2 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p4mtmp;try rewrite HT2 in HACDEp1p2p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2p4mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AEp2p4 requis par la preuve de (?)AEp2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 :: p4 ::  de rang :  4 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: D :: p1 ::   de rang : 3 et 3 *)
assert(HAEp2p4m2 : rk(A :: E :: p2 :: p4 :: nil) >= 2).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADp1Mtmp : rk(A :: D :: p1 :: nil) <= 3) by (solve_hyps_max HADp1eq HADp1M3).
	assert(HADEp1p2p4mtmp : rk(A :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4) by (solve_hyps_min HADEp1p2p4eq HADEp1p2p4m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p1 :: nil) (A :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: D :: p1 :: A :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p1 :: A :: E :: p2 :: p4 :: nil) ((A :: D :: p1 :: nil) ++ (A :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2p4mtmp;try rewrite HT2 in HADEp1p2p4mtmp.
	assert(HT := rule_4 (A :: D :: p1 :: nil) (A :: E :: p2 :: p4 :: nil) (A :: nil) 4 1 3 HADEp1p2p4mtmp HAmtmp HADp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAEp2p4M3 : rk(A :: E :: p2 :: p4 :: nil) <= 3).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: p4 :: nil) (p2 :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: E :: p4 :: nil) ((p2 :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 Hp2Mtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HAEp2p4M2 : rk(A :: E :: p2 :: p4 :: nil) <= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: p4 :: nil) (A :: p2 :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: E :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: E :: p4 :: nil) (A :: nil) 1 2 1 HAp2Mtmp HAEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAEp2p4M : rk(A :: E :: p2 :: p4 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HAEp2p4eq HAEp2p4M4).
assert(HAEp2p4m : rk(A :: E :: p2 :: p4 ::  nil) >= 1) by (solve_hyps_min HAEp2p4eq HAEp2p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADEp2p3p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: D :: E :: p2 :: p3 :: p4 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADEp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ADEp2p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 5 pour ACDEp1p4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 5 pour ABCDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ABCDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ABCDEApp4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp4m5 : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp4M3 : rk(A :: C :: E :: p4 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p4 :: nil) (C :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: E :: p4 :: nil) ((C :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HCMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACEp4m2 : rk(A :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp4M4 : rk(A :: C :: D :: E :: p4 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACEp4Mtmp : rk(A :: C :: E :: p4 :: nil) <= 3) by (solve_hyps_max HACEp4eq HACEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p4 :: nil) (D :: A :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: E :: p4 :: nil) ((D :: nil) ++ (A :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: E :: p4 :: nil) (nil) 1 3 0 HDMtmp HACEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp4m3 : rk(A :: C :: D :: E :: p4 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp4mtmp : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApp4eq HABCDEApp4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p4 :: nil) (B :: Ap :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p4 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp4mtmp;try rewrite HT2 in HABCDEApp4mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 5 0 2 HABCDEApp4mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ABCDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ABCDEp1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCDEp1p4M5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p4 :: nil) (A :: nil) 2 4 1 HABp1Mtmp HACDEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p4 requis par la preuve de (?)ABCDECpp1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p4 requis par la preuve de (?)ABCDEApBpp1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p4m2 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p4eq HABCDEApBpp1p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p4 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p4mtmp;try rewrite HT2 in HABCDEApBpp1p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p4mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p4m3 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p4eq HABCDECpp1p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p4 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p4mtmp;try rewrite HT2 in HABCDECpp1p4mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (nil) 5 0 2 HABCDECpp1p4mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp1p4M5 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) <= 5).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p4 :: nil) (p1 :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: C :: D :: E :: p4 :: nil) ((p1 :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 1 4 0 Hp1Mtmp HACDEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p4m4 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p4eq HABCDEp1p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p4mtmp;try rewrite HT2 in HABCDEp1p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 5) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 5 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p4m5 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p4eq HABCDEp1p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p4mtmp;try rewrite HT2 in HABCDEp1p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp4 requis par la preuve de (?)ACDEApp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp4 requis par la preuve de (?)ACDEApp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp4M5 : rk(A :: C :: D :: E :: Ap :: p4 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p4 :: nil) (Ap :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p4 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 1 4 0 HApMtmp HACDEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p4 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp4m4 : rk(A :: C :: D :: E :: Ap :: p4 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp4mtmp : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApp4eq HABCDEApp4m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p4 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p4 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp4mtmp;try rewrite HT2 in HABCDEApp4mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p4 :: nil) (Ap :: nil) 5 1 2 HABCDEApp4mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADEp4M3 : rk(A :: D :: E :: p4 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p4 :: nil) (D :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: E :: p4 :: nil) ((D :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HDMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p4 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp4m2 : rk(A :: D :: E :: p4 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp4mtmp : rk(A :: C :: D :: E :: Ap :: p4 :: nil) >= 4) by (solve_hyps_min HACDEApp4eq HACDEApp4m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p4 :: nil) (C :: Ap :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p4 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp4mtmp;try rewrite HT2 in HACDEApp4mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p4 :: nil) (nil) 4 0 2 HACDEApp4mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp4m3 : rk(A :: D :: E :: p4 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p4mtmp : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p4eq HACDEp1p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p4mtmp;try rewrite HT2 in HACDEp1p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p4 :: nil) (nil) 5 0 2 HACDEp1p4mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ABCDEp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2p4 requis par la preuve de (?)ABCDECpp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p2p4 requis par la preuve de (?)ABCDEApBpp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p2p4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p2p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p2p4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2p4eq HABCDEApBpp1p2p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2p4mtmp;try rewrite HT2 in HABCDEApBpp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2p4mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p2p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p4eq HABCDECpp1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p4mtmp;try rewrite HT2 in HABCDECpp1p2p4mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDECpp1p2p4mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2p4 requis par la preuve de (?)ABCDECpp2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCECp requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCCp requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCCpm2 : rk(B :: C :: Cp :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_2 (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDECpp1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : B :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HBCECpm2 : rk(B :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HBCCpmtmp : rk(B :: C :: Cp :: nil) >= 2) by (solve_hyps_min HBCCpeq HBCCpm2).
	assert(Hincl : incl (B :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (B :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil) (B :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HBCCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCECpm3 : rk(B :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (B :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: B :: p1 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCECpp1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HADEp2p4m2 : rk(A :: D :: E :: p2 :: p4 :: nil) >= 2).
{
	assert(HBCECpMtmp : rk(B :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBCECpeq HBCECpM4).
	assert(HABCDECpp2p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp2p4eq HABCDECpp2p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: D :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) (B :: C :: E :: Cp :: A :: D :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: D :: E :: p2 :: p4 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: D :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2p4mtmp;try rewrite HT2 in HABCDECpp2p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: Cp :: nil) (A :: D :: E :: p2 :: p4 :: nil) (E :: nil) 5 1 4 HABCDECpp2p4mtmp HEmtmp HBCECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp2p4m3 : rk(A :: D :: E :: p2 :: p4 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p4eq HACDEp1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p2 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p4mtmp;try rewrite HT2 in HACDEp1p2p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p2 :: p4 :: nil) (nil) 5 0 2 HACDEp1p2p4mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2p4M4 : rk(A :: D :: E :: p2 :: p4 :: nil) <= 4).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HADEp4Mtmp : rk(A :: D :: E :: p4 :: nil) <= 3) by (solve_hyps_max HADEp4eq HADEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p4 :: nil) (p2 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: D :: E :: p4 :: nil) ((p2 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: D :: E :: p4 :: nil) (nil) 1 3 0 Hp2Mtmp HADEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HADEp2p4M3 : rk(A :: D :: E :: p2 :: p4 :: nil) <= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HADEp4Mtmp : rk(A :: D :: E :: p4 :: nil) <= 3) by (solve_hyps_max HADEp4eq HADEp4M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p4 :: nil) (A :: p2 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: D :: E :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: D :: E :: p4 :: nil) (A :: nil) 1 3 1 HAp2Mtmp HADEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADEp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour DEp3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)DEp3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p3p4 requis par la preuve de (?)ABCDEp1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p3p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p3p4 requis par la preuve de (?)ABCDECpp1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p3p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p3p4 requis par la preuve de (?)ABCDEApBpp1p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p3p4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p3p4 requis par la preuve de (?)ACDEp1p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p3p4m2 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p3p4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p3p4eq HABCDEApBpp1p3p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p3p4mtmp;try rewrite HT2 in HABCDEApBpp1p3p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p3p4mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p3p4m3 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p3p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p3p4eq HABCDECpp1p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p3p4mtmp;try rewrite HT2 in HABCDECpp1p3p4mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDECpp1p3p4mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p3p4m4 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3p4eq HABCDEp1p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3p4mtmp;try rewrite HT2 in HABCDEp1p3p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p3p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p3p4m5 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3p4eq HABCDEp1p3p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3p4mtmp;try rewrite HT2 in HABCDEp1p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour DEp3p4 requis par la preuve de (?)DEp3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : A :: C :: p1 ::   de rang : 3 et 3 *)
assert(HDEp3p4m2 : rk(D :: E :: p3 :: p4 :: nil) >= 2).
{
	assert(HACp1eq : rk(A :: C :: p1 :: nil) = 3) by (apply LACp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1Mtmp : rk(A :: C :: p1 :: nil) <= 3) by (solve_hyps_max HACp1eq HACp1M3).
	assert(HACDEp1p3p4mtmp : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p3p4eq HACDEp1p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: p1 :: nil) (D :: E :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p3 :: p4 :: nil) (A :: C :: p1 :: D :: E :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: p1 :: D :: E :: p3 :: p4 :: nil) ((A :: C :: p1 :: nil) ++ (D :: E :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p3p4mtmp;try rewrite HT2 in HACDEp1p3p4mtmp.
	assert(HT := rule_4 (A :: C :: p1 :: nil) (D :: E :: p3 :: p4 :: nil) (nil) 5 0 3 HACDEp1p3p4mtmp Hmtmp HACp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ABCDEp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2p3p4 requis par la preuve de (?)ABCDECpp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p2p3p4 requis par la preuve de (?)ABCDEApBpp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p2p3p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2p3p4eq HABCDEApBpp1p2p3p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2p3p4mtmp;try rewrite HT2 in HABCDEApBpp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2p3p4mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4eq HABCDECpp1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4mtmp;try rewrite HT2 in HABCDECpp1p2p3p4mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDECpp1p2p3p4mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p3p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2p3p4 requis par la preuve de (?)ABCDECpp2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2p3p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp2p3p4 requis par la preuve de (?)ADEp2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HADEp2p3p4m2 : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HBCECpMtmp : rk(B :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBCECpeq HBCECpM4).
	assert(HABCDECpp2p3p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp2p3p4eq HABCDECpp2p3p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: D :: E :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: p3 :: p4 :: nil) (B :: C :: E :: Cp :: A :: D :: E :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: D :: E :: p2 :: p3 :: p4 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: D :: E :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2p3p4mtmp;try rewrite HT2 in HABCDECpp2p3p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: Cp :: nil) (A :: D :: E :: p2 :: p3 :: p4 :: nil) (E :: nil) 5 1 4 HABCDECpp2p3p4mtmp HEmtmp HBCECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp2p3p4m3 : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p3p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p3p4eq HACDEp1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p2 :: p3 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p3p4mtmp;try rewrite HT2 in HACDEp1p2p3p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HACDEp1p2p3p4mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HADEp2p3p4M5 : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HDEp3p4Mtmp : rk(D :: E :: p3 :: p4 :: nil) <= 4) by (solve_hyps_max HDEp3p4eq HDEp3p4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (D :: E :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p3 :: p4 :: nil) (A :: p2 :: D :: E :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: D :: E :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (D :: E :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (D :: E :: p3 :: p4 :: nil) (nil) 1 4 0 HAp2Mtmp HDEp3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2p3p4M4 : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) <= 4).
{
	assert(Hp3Mtmp : rk(p3 :: nil) <= 1) by (solve_hyps_max Hp3eq Hp3M1).
	assert(HADEp2p4Mtmp : rk(A :: D :: E :: p2 :: p4 :: nil) <= 3) by (solve_hyps_max HADEp2p4eq HADEp2p4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p3 :: nil) (A :: D :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p3 :: p4 :: nil) (p3 :: A :: D :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p3 :: A :: D :: E :: p2 :: p4 :: nil) ((p3 :: nil) ++ (A :: D :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p3 :: nil) (A :: D :: E :: p2 :: p4 :: nil) (nil) 1 3 0 Hp3Mtmp HADEp2p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -2*)
assert(HADEp2p3p4M3 : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) <= 3).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HAEp2p4eq : rk(A :: E :: p2 :: p4 :: nil) = 2) by (apply LAEp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAEp2p4Mtmp : rk(A :: E :: p2 :: p4 :: nil) <= 2) by (solve_hyps_max HAEp2p4eq HAEp2p4M2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p3 :: nil) (A :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p3 :: p4 :: nil) (A :: D :: p3 :: A :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: E :: p2 :: p4 :: nil) ((A :: D :: p3 :: nil) ++ (A :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: p3 :: nil) (A :: E :: p2 :: p4 :: nil) (A :: nil) 2 2 1 HADp3Mtmp HAEp2p4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HADEp2p3p4M : rk(A :: D :: E :: p2 :: p3 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HADEp2p3p4m : rk(A :: D :: E :: p2 :: p3 :: p4 ::  nil) >= 1) by (solve_hyps_min HADEp2p3p4eq HADEp2p3p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAEp2p3p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: E :: p2 :: p3 :: p4 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AEp2p3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AEp2p3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Ep3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour AEp2p3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p3p4 requis par la preuve de (?)ABCDEp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2p3p4 requis par la preuve de (?)ABCDECpp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p2p3p4 requis par la preuve de (?)ABCDEApBpp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p3p4 requis par la preuve de (?)ACDEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p2p3p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2p3p4eq HABCDEApBpp1p2p3p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2p3p4mtmp;try rewrite HT2 in HABCDEApBpp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2p3p4mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4eq HABCDECpp1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4mtmp;try rewrite HT2 in HABCDECpp1p2p3p4mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDECpp1p2p3p4mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p3p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4eq HABCDEp1p2p3p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4mtmp;try rewrite HT2 in HABCDEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEDpp1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEDpp1p2p3p4 requis par la preuve de (?)ABCDEDpp1p2p3p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEDpp1p2p3p4m5 : rk(A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CDp requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p2p3p4 requis par la preuve de (?)ABDEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABDEp1p2p3p4m2 : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCDECpp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4eq HABCDECpp1p2p3p4m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) (A :: C :: E :: Cp :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4mtmp;try rewrite HT2 in HABCDECpp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: E :: nil) 5 1 4 HABCDECpp1p2p3p4mtmp HAEmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Dp ::   de rang : 1 et 2 *)
assert(HABDEp1p2p3p4m3 : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HCDpMtmp : rk(C :: Dp :: nil) <= 2) by (solve_hyps_max HCDpeq HCDpM2).
	assert(HABCDEDpp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEDpp1p2p3p4eq HABCDEDpp1p2p3p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Dp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: nil) (C :: Dp :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Dp :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((C :: Dp :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEDpp1p2p3p4mtmp;try rewrite HT2 in HABCDEDpp1p2p3p4mtmp.
	assert(HT := rule_4 (C :: Dp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (nil) 5 0 2 HABCDEDpp1p2p3p4mtmp Hmtmp HCDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCECp requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCCp requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCCpm2 : rk(B :: C :: Cp :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_2 (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDECpp1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : B :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HBCECpm2 : rk(B :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HBCCpmtmp : rk(B :: C :: Cp :: nil) >= 2) by (solve_hyps_min HBCCpeq HBCCpm2).
	assert(Hincl : incl (B :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (B :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil) (B :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HBCCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCECpm3 : rk(B :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (B :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: B :: p1 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCECpp1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p2p3p4 requis par la preuve de (?)ADEp1p2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HADEp1p2p3p4m2 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HBCECpMtmp : rk(B :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBCECpeq HBCECpM4).
	assert(HABCDECpp1p2p3p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4eq HABCDECpp1p2p3p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: nil) (B :: C :: E :: Cp :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4mtmp;try rewrite HT2 in HABCDECpp1p2p3p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (E :: nil) 5 1 4 HABCDECpp1p2p3p4mtmp HEmtmp HBCECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p3p4m3 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p2p3p4mtmp : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HABDEp1p2p3p4eq HABDEp1p2p3p4m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p2p3p4mtmp;try rewrite HT2 in HABDEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p2p3p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p3p4m4 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p3p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p3p4eq HACDEp1p2p3p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p3p4mtmp;try rewrite HT2 in HACDEp1p2p3p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2p3p4mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour AEp2p3p4 requis par la preuve de (?)AEp2p3p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 :: p3 :: p4 ::  de rang :  4 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: D :: p1 ::   de rang : 3 et 3 *)
assert(HAEp2p3p4m2 : rk(A :: E :: p2 :: p3 :: p4 :: nil) >= 2).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADp1Mtmp : rk(A :: D :: p1 :: nil) <= 3) by (solve_hyps_max HADp1eq HADp1M3).
	assert(HADEp1p2p3p4mtmp : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) >= 4) by (solve_hyps_min HADEp1p2p3p4eq HADEp1p2p3p4m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p1 :: nil) (A :: E :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: nil) (A :: D :: p1 :: A :: E :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p1 :: A :: E :: p2 :: p3 :: p4 :: nil) ((A :: D :: p1 :: nil) ++ (A :: E :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2p3p4mtmp;try rewrite HT2 in HADEp1p2p3p4mtmp.
	assert(HT := rule_4 (A :: D :: p1 :: nil) (A :: E :: p2 :: p3 :: p4 :: nil) (A :: nil) 4 1 3 HADEp1p2p3p4mtmp HAmtmp HADp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAEp2p3p4M4 : rk(A :: E :: p2 :: p3 :: p4 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HEp3p4Mtmp : rk(E :: p3 :: p4 :: nil) <= 3) by (solve_hyps_max HEp3p4eq HEp3p4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (E :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: p3 :: p4 :: nil) (A :: p2 :: E :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: E :: p3 :: p4 :: nil) ((A :: p2 :: nil) ++ (E :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (E :: p3 :: p4 :: nil) (nil) 1 3 0 HAp2Mtmp HEp3p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 4 et 5*)
assert(HAEp2p3p4M3 : rk(A :: E :: p2 :: p3 :: p4 :: nil) <= 3).
{
	assert(Hp3Mtmp : rk(p3 :: nil) <= 1) by (solve_hyps_max Hp3eq Hp3M1).
	assert(HAEp2p4eq : rk(A :: E :: p2 :: p4 :: nil) = 2) by (apply LAEp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAEp2p4Mtmp : rk(A :: E :: p2 :: p4 :: nil) <= 2) by (solve_hyps_max HAEp2p4eq HAEp2p4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p3 :: nil) (A :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: p3 :: p4 :: nil) (p3 :: A :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p3 :: A :: E :: p2 :: p4 :: nil) ((p3 :: nil) ++ (A :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p3 :: nil) (A :: E :: p2 :: p4 :: nil) (nil) 1 2 0 Hp3Mtmp HAEp2p4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: D :: E :: p2 :: p3 :: p4 ::  de rang :  3 et 3 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HAEp2p3p4m3 : rk(A :: E :: p2 :: p3 :: p4 :: nil) >= 3).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HADEp2p3p4eq : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) = 3) by (apply LADEp2p3p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADEp2p3p4mtmp : rk(A :: D :: E :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HADEp2p3p4eq HADEp2p3p4m3).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: E :: p2 :: p3 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p3 :: p4 :: nil) (A :: D :: p3 :: A :: E :: p2 :: p3 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: E :: p2 :: p3 :: p4 :: nil) ((A :: D :: p3 :: nil) ++ (A :: E :: p2 :: p3 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp2p3p4mtmp;try rewrite HT2 in HADEp2p3p4mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: E :: p2 :: p3 :: p4 :: nil) (A :: p3 :: nil) 3 2 2 HADEp2p3p4mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

assert(HAEp2p3p4M : rk(A :: E :: p2 :: p3 :: p4 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HAEp2p3p4eq HAEp2p3p4M5).
assert(HAEp2p3p4m : rk(A :: E :: p2 :: p3 :: p4 ::  nil) >= 1) by (solve_hyps_min HAEp2p3p4eq HAEp2p3p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lp2p3 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(p2 :: p3 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour p2p3 requis par la preuve de (?)p2p3 pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(Hp2p3m2 : rk(p2 :: p3 :: nil) >= 2).
{
	assert(HAEp2p4eq : rk(A :: E :: p2 :: p4 :: nil) = 2) by (apply LAEp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAEp2p4Mtmp : rk(A :: E :: p2 :: p4 :: nil) <= 2) by (solve_hyps_max HAEp2p4eq HAEp2p4M2).
	assert(HAEp2p3p4eq : rk(A :: E :: p2 :: p3 :: p4 :: nil) = 3) by (apply LAEp2p3p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAEp2p3p4mtmp : rk(A :: E :: p2 :: p3 :: p4 :: nil) >= 3) by (solve_hyps_min HAEp2p3p4eq HAEp2p3p4m3).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (p2 :: p3 :: nil) (A :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p2 :: p3 :: p4 :: nil) (p2 :: p3 :: A :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: p3 :: A :: E :: p2 :: p4 :: nil) ((p2 :: p3 :: nil) ++ (A :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAEp2p3p4mtmp;try rewrite HT2 in HAEp2p3p4mtmp.
	assert(HT := rule_2 (p2 :: p3 :: nil) (A :: E :: p2 :: p4 :: nil) (p2 :: nil) 3 1 2 HAEp2p3p4mtmp Hp2mtmp HAEp2p4Mtmp Hincl);apply HT.
}

assert(Hp2p3M : rk(p2 :: p3 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max Hp2p3eq Hp2p3M2).
assert(Hp2p3m : rk(p2 :: p3 ::  nil) >= 1) by (solve_hyps_min Hp2p3eq Hp2p3m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp2p3 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: p2 :: p3 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ap2p3 requis par la preuve de (?)Ap2p3 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Ap2p3 requis par la preuve de (?)Ap2p3 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAp2p3M2 : rk(A :: p2 :: p3 :: nil) <= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp3Mtmp : rk(p3 :: nil) <= 1) by (solve_hyps_max Hp3eq Hp3M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p3 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p2 :: p3 :: nil) (A :: p2 :: p3 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p3 :: nil) ((A :: p2 :: nil) ++ (p3 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p3 :: nil) (nil) 1 1 0 HAp2Mtmp Hp3Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp2p3m2 : rk(A :: p2 :: p3 :: nil) >= 2).
{
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p3 :: nil) (A :: p2 :: p3 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p3 :: nil) (A :: p2 :: p3 :: nil) 2 2 HAp3mtmp Hcomp Hincl);apply HT.
}

assert(HAp2p3M : rk(A :: p2 :: p3 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HAp2p3eq HAp2p3M3).
assert(HAp2p3m : rk(A :: p2 :: p3 ::  nil) >= 1) by (solve_hyps_min HAp2p3eq HAp2p3m1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCp4 *)
(* dans constructLemma(), requis par LABCEp4 *)
(* dans constructLemma(), requis par LABCDEp2p4 *)
(* dans la couche 0 *)
Lemma LABCDEp4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p4 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDEp4 requis par la preuve de (?)ABCDEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp4 requis par la preuve de (?)ABCEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp4 requis par la preuve de (?)ABEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp4M3 : rk(A :: B :: E :: p4 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p4 :: nil) (B :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: E :: p4 :: nil) ((B :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HBMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp4M4 : rk(A :: B :: C :: E :: p4 :: nil) <= 4).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABEp4Mtmp : rk(A :: B :: E :: p4 :: nil) <= 3) by (solve_hyps_max HABEp4eq HABEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p4 :: nil) (C :: A :: B :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: E :: p4 :: nil) ((C :: nil) ++ (A :: B :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: E :: p4 :: nil) (nil) 1 3 0 HCMtmp HABEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCEp4m2 : rk(A :: B :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp4 requis par la preuve de (?)ABCDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCDEp4M5 : rk(A :: B :: C :: D :: E :: p4 :: nil) <= 5).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABCEp4Mtmp : rk(A :: B :: C :: E :: p4 :: nil) <= 4) by (solve_hyps_max HABCEp4eq HABCEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p4 :: nil) (D :: A :: B :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: C :: E :: p4 :: nil) ((D :: nil) ++ (A :: B :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: C :: E :: p4 :: nil) (nil) 1 4 0 HDMtmp HABCEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp4m5 : rk(A :: B :: C :: D :: E :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

assert(HABCDEp4M : rk(A :: B :: C :: D :: E :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp4m : rk(A :: B :: C :: D :: E :: p4 ::  nil) >= 1) by (solve_hyps_min HABCDEp4eq HABCDEp4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCDEp2p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p2 :: p4 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp2p4 requis par la preuve de (?)ABCDEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp2p4 requis par la preuve de (?)ABCDEp2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp2p4m5 : rk(A :: B :: C :: D :: E :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -2*)
assert(HABCDEp2p4M5 : rk(A :: B :: C :: D :: E :: p2 :: p4 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCDEp4eq : rk(A :: B :: C :: D :: E :: p4 :: nil) = 5) by (apply LABCDEp4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp4Mtmp : rk(A :: B :: C :: D :: E :: p4 :: nil) <= 5) by (solve_hyps_max HABCDEp4eq HABCDEp4M5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: B :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: p4 :: nil) (A :: p2 :: A :: B :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: B :: C :: D :: E :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: B :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: B :: C :: D :: E :: p4 :: nil) (A :: nil) 1 5 1 HAp2Mtmp HABCDEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCDEp2p4M : rk(A :: B :: C :: D :: E :: p2 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp2p4m : rk(A :: B :: C :: D :: E :: p2 :: p4 ::  nil) >= 1) by (solve_hyps_min HABCDEp2p4eq HABCDEp2p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCEp4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: E :: p4 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ABCEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ABCDEApp4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp4m5 : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp4 requis par la preuve de (?)ABCEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp4 requis par la preuve de (?)ABEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp4M3 : rk(A :: B :: E :: p4 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p4 :: nil) (B :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: E :: p4 :: nil) ((B :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HBMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp4M4 : rk(A :: B :: C :: E :: p4 :: nil) <= 4).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABEp4Mtmp : rk(A :: B :: E :: p4 :: nil) <= 3) by (solve_hyps_max HABEp4eq HABEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p4 :: nil) (C :: A :: B :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: E :: p4 :: nil) ((C :: nil) ++ (A :: B :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: E :: p4 :: nil) (nil) 1 3 0 HCMtmp HABEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCEp4m2 : rk(A :: B :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp4m3 : rk(A :: B :: C :: E :: p4 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp4mtmp : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApp4eq HABCDEApp4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p4 :: nil) (D :: Ap :: A :: B :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p4 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp4mtmp;try rewrite HT2 in HABCDEApp4mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p4 :: nil) (nil) 5 0 2 HABCDEApp4mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p2 :: p4 ::  de rang :  5 et 5 	 AiB : A ::  de rang :  1 et 1 	 A : A :: D :: p2 ::   de rang : 2 et 2 *)
assert(HABCEp4m4 : rk(A :: B :: C :: E :: p4 :: nil) >= 4).
{
	assert(HADp2eq : rk(A :: D :: p2 :: nil) = 2) by (apply LADp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(HABCDEp2p4eq : rk(A :: B :: C :: D :: E :: p2 :: p4 :: nil) = 5) by (apply LABCDEp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp2p4mtmp : rk(A :: B :: C :: D :: E :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp2p4eq HABCDEp2p4m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p2 :: nil) (A :: B :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: p4 :: nil) (A :: D :: p2 :: A :: B :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p2 :: A :: B :: C :: E :: p4 :: nil) ((A :: D :: p2 :: nil) ++ (A :: B :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp2p4mtmp;try rewrite HT2 in HABCDEp2p4mtmp.
	assert(HT := rule_4 (A :: D :: p2 :: nil) (A :: B :: C :: E :: p4 :: nil) (A :: nil) 5 1 2 HABCDEp2p4mtmp HAmtmp HADp2Mtmp Hincl); apply HT.
}

assert(HABCEp4M : rk(A :: B :: C :: E :: p4 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HABCEp4eq HABCEp4M5).
assert(HABCEp4m : rk(A :: B :: C :: E :: p4 ::  nil) >= 1) by (solve_hyps_min HABCEp4eq HABCEp4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCp4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: p4 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCp4 requis par la preuve de (?)ABCp4 pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCEp2p4 requis par la preuve de (?)ABCp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ABCEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ABCDEApp4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp4m5 : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp4 requis par la preuve de (?)ABCEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp4 requis par la preuve de (?)ABEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp4M3 : rk(A :: B :: E :: p4 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p4 :: nil) (B :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: E :: p4 :: nil) ((B :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HBMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp4M4 : rk(A :: B :: C :: E :: p4 :: nil) <= 4).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABEp4Mtmp : rk(A :: B :: E :: p4 :: nil) <= 3) by (solve_hyps_max HABEp4eq HABEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p4 :: nil) (C :: A :: B :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: E :: p4 :: nil) ((C :: nil) ++ (A :: B :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: E :: p4 :: nil) (nil) 1 3 0 HCMtmp HABEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCEp4m2 : rk(A :: B :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp4m3 : rk(A :: B :: C :: E :: p4 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp4mtmp : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApp4eq HABCDEApp4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p4 :: nil) (D :: Ap :: A :: B :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p4 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp4mtmp;try rewrite HT2 in HABCDEApp4mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p4 :: nil) (nil) 5 0 2 HABCDEApp4mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2p4 requis par la preuve de (?)ABCDECpp2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp2p4 requis par la preuve de (?)ABCDEApBpp2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp2p4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp2p4m2 : rk(A :: B :: C :: E :: p2 :: p4 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp2p4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp2p4eq HABCDEApBpp2p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p2 :: p4 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp2p4mtmp;try rewrite HT2 in HABCDEApBpp2p4mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp2p4mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp2p4m3 : rk(A :: B :: C :: E :: p2 :: p4 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp2p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp2p4eq HABCDECpp2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) (D :: Cp :: A :: B :: C :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p2 :: p4 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2p4mtmp;try rewrite HT2 in HABCDECpp2p4mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDECpp2p4mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2p4M5 : rk(A :: B :: C :: E :: p2 :: p4 :: nil) <= 5).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HABCEp4Mtmp : rk(A :: B :: C :: E :: p4 :: nil) <= 4) by (solve_hyps_max HABCEp4eq HABCEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: B :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: p4 :: nil) (p2 :: A :: B :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: B :: C :: E :: p4 :: nil) ((p2 :: nil) ++ (A :: B :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: B :: C :: E :: p4 :: nil) (nil) 1 4 0 Hp2Mtmp HABCEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCEp2p4M4 : rk(A :: B :: C :: E :: p2 :: p4 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEp4Mtmp : rk(A :: B :: C :: E :: p4 :: nil) <= 4) by (solve_hyps_max HABCEp4eq HABCEp4M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: B :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: p4 :: nil) (A :: p2 :: A :: B :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: B :: C :: E :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: B :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: B :: C :: E :: p4 :: nil) (A :: nil) 1 4 1 HAp2Mtmp HABCEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p2 :: p4 ::  de rang :  5 et 5 	 AiB : p2 ::  de rang :  1 et 1 	 A : D :: p2 ::   de rang : 2 et 2 *)
assert(HABCEp2p4m4 : rk(A :: B :: C :: E :: p2 :: p4 :: nil) >= 4).
{
	assert(HDp2eq : rk(D :: p2 :: nil) = 2) by (apply LDp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp2Mtmp : rk(D :: p2 :: nil) <= 2) by (solve_hyps_max HDp2eq HDp2M2).
	assert(HABCDEp2p4eq : rk(A :: B :: C :: D :: E :: p2 :: p4 :: nil) = 5) by (apply LABCDEp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp2p4mtmp : rk(A :: B :: C :: D :: E :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp2p4eq HABCDEp2p4m5).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (D :: p2 :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: p4 :: nil) (D :: p2 :: A :: B :: C :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p2 :: A :: B :: C :: E :: p2 :: p4 :: nil) ((D :: p2 :: nil) ++ (A :: B :: C :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp2p4mtmp;try rewrite HT2 in HABCDEp2p4mtmp.
	assert(HT := rule_4 (D :: p2 :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil) (p2 :: nil) 5 1 2 HABCDEp2p4mtmp Hp2mtmp HDp2Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCp4 requis par la preuve de (?)ABCp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp4 requis par la preuve de (?)ABCp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp4 requis par la preuve de (?)ABCECpp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp4 requis par la preuve de (?)ABCDECpp4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp4m5 : rk(A :: B :: C :: D :: E :: Cp :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCECpp4 requis par la preuve de (?)ABCECpp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCECpp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCDECpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDECpm2 : rk(A :: C :: D :: E :: Cp :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDECpm4 : rk(A :: C :: D :: E :: Cp :: nil) >= 4).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (B :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: Cp :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HBCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCCpm2 : rk(A :: B :: C :: Cp :: nil) >= 2).
{
	assert(HACDECpMtmp : rk(A :: C :: D :: E :: Cp :: nil) <= 5) by (solve_hyps_max HACDECpeq HACDECpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HACDECpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCCpm3 : rk(A :: B :: C :: Cp :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDECpp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp4 requis par la preuve de (?)ABCECpp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp4 requis par la preuve de (?)ABCECpp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp4 requis par la preuve de (?)ABCECpp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp4 requis par la preuve de (?)ABCDEApBpCpp4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp4 requis par la preuve de (?)ABCECpp4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp4m2 : rk(A :: B :: C :: E :: Cp :: p4 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp4eq HABCDEApBpCpp4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p4 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p4 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp4mtmp;try rewrite HT2 in HABCDEApBpCpp4mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp4mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp4M5 : rk(A :: B :: C :: E :: Cp :: p4 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp4Mtmp : rk(A :: B :: C :: E :: p4 :: nil) <= 4) by (solve_hyps_max HABCEp4eq HABCEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p4 :: nil) (Cp :: A :: B :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p4 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p4 :: nil) (nil) 1 4 0 HCpMtmp HABCEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCECpp4m3 : rk(A :: B :: C :: E :: Cp :: p4 :: nil) >= 3).
{
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 3) by (solve_hyps_min HABCCpeq HABCCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p4 :: nil) 3 3 HABCCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p4 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp4m4 : rk(A :: B :: C :: E :: Cp :: p4 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp4eq HABCDECpp4m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p4 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p4 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp4mtmp;try rewrite HT2 in HABCDECpp4mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p4 :: nil) (Cp :: nil) 5 1 2 HABCDECpp4mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABCp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp4 requis par la preuve de (?)ABCp4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Cp :: p4 ::  de rang :  4 et 5 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABCp4m2 : rk(A :: B :: C :: p4 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCECpp4mtmp : rk(A :: B :: C :: E :: Cp :: p4 :: nil) >= 4) by (solve_hyps_min HABCECpp4eq HABCECpp4m4).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: C :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p4 :: nil) (A :: C :: E :: Cp :: A :: B :: C :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: C :: p4 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: C :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp4mtmp;try rewrite HT2 in HABCECpp4mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: C :: p4 :: nil) (A :: C :: nil) 4 2 4 HABCECpp4mtmp HACmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: E :: p2 :: p4 ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: E :: p2 ::   de rang : 2 et 2 *)
assert(HABCp4m3 : rk(A :: B :: C :: p4 :: nil) >= 3).
{
	assert(HAEp2eq : rk(A :: E :: p2 :: nil) = 2) by (apply LAEp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAEp2Mtmp : rk(A :: E :: p2 :: nil) <= 2) by (solve_hyps_max HAEp2eq HAEp2M2).
	assert(HABCEp2p4mtmp : rk(A :: B :: C :: E :: p2 :: p4 :: nil) >= 4) by (solve_hyps_min HABCEp2p4eq HABCEp2p4m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: E :: p2 :: nil) (A :: B :: C :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: p4 :: nil) (A :: E :: p2 :: A :: B :: C :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p2 :: A :: B :: C :: p4 :: nil) ((A :: E :: p2 :: nil) ++ (A :: B :: C :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEp2p4mtmp;try rewrite HT2 in HABCEp2p4mtmp.
	assert(HT := rule_4 (A :: E :: p2 :: nil) (A :: B :: C :: p4 :: nil) (A :: nil) 4 1 2 HABCEp2p4mtmp HAmtmp HAEp2Mtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et -4*)
assert(HABCp4m4 : rk(A :: B :: C :: p4 :: nil) >= 4).
{
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HABCEp4eq : rk(A :: B :: C :: E :: p4 :: nil) = 4) by (apply LABCEp4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCEp4mtmp : rk(A :: B :: C :: E :: p4 :: nil) >= 4) by (solve_hyps_min HABCEp4eq HABCEp4m4).
	assert(HAp4mtmp : rk(A :: p4 :: nil) >= 2) by (solve_hyps_min HAp4eq HAp4m2).
	assert(Hincl : incl (A :: p4 :: nil) (list_inter (A :: B :: C :: p4 :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p4 :: nil) (A :: B :: C :: p4 :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p4 :: A :: E :: p4 :: nil) ((A :: B :: C :: p4 :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEp4mtmp;try rewrite HT2 in HABCEp4mtmp.
	assert(HT := rule_2 (A :: B :: C :: p4 :: nil) (A :: E :: p4 :: nil) (A :: p4 :: nil) 4 2 2 HABCEp4mtmp HAp4mtmp HAEp4Mtmp Hincl);apply HT.
}

assert(HABCp4M : rk(A :: B :: C :: p4 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HABCp4eq HABCp4M4).
assert(HABCp4m : rk(A :: B :: C :: p4 ::  nil) >= 1) by (solve_hyps_min HABCp4eq HABCp4m1).
intuition.
Qed.

(* dans constructLemma(), requis par LADEp4 *)
(* dans constructLemma(), requis par LACDEp1p4 *)
(* dans constructLemma(), requis par LABCDEp1p4 *)
(* dans la couche 0 *)
Lemma LABCDEp1p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p1 :: p4 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ABCDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ABCDEApp4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp4m5 : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp4M3 : rk(A :: C :: E :: p4 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p4 :: nil) (C :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: E :: p4 :: nil) ((C :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HCMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACEp4m2 : rk(A :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp4M4 : rk(A :: C :: D :: E :: p4 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACEp4Mtmp : rk(A :: C :: E :: p4 :: nil) <= 3) by (solve_hyps_max HACEp4eq HACEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p4 :: nil) (D :: A :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: E :: p4 :: nil) ((D :: nil) ++ (A :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: E :: p4 :: nil) (nil) 1 3 0 HDMtmp HACEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp4m3 : rk(A :: C :: D :: E :: p4 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp4mtmp : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApp4eq HABCDEApp4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p4 :: nil) (B :: Ap :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p4 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp4mtmp;try rewrite HT2 in HABCDEApp4mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 5 0 2 HABCDEApp4mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ABCDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ABCDEp1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCDEp1p4M5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p4 :: nil) (A :: nil) 2 4 1 HABp1Mtmp HACDEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCDEp1p4M : rk(A :: B :: C :: D :: E :: p1 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp1p4m : rk(A :: B :: C :: D :: E :: p1 :: p4 ::  nil) >= 1) by (solve_hyps_min HABCDEp1p4eq HABCDEp1p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACDEp1p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C :: D :: E :: p1 :: p4 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p4 requis par la preuve de (?)ABCDEp1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ABCDEApp4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp4m5 : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp4M3 : rk(A :: C :: E :: p4 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p4 :: nil) (C :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: E :: p4 :: nil) ((C :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HCMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACEp4m2 : rk(A :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp4M4 : rk(A :: C :: D :: E :: p4 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACEp4Mtmp : rk(A :: C :: E :: p4 :: nil) <= 3) by (solve_hyps_max HACEp4eq HACEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p4 :: nil) (D :: A :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: E :: p4 :: nil) ((D :: nil) ++ (A :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: E :: p4 :: nil) (nil) 1 3 0 HDMtmp HACEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp4m3 : rk(A :: C :: D :: E :: p4 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp4mtmp : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApp4eq HABCDEApp4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p4 :: nil) (B :: Ap :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p4 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp4mtmp;try rewrite HT2 in HABCDEApp4mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 5 0 2 HABCDEApp4mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p4 requis par la preuve de (?)ABCDECpp1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p4 requis par la preuve de (?)ABCDEApBpp1p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p4 requis par la preuve de (?)ACDEp1p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p4m2 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p4eq HABCDEApBpp1p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p4 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p4mtmp;try rewrite HT2 in HABCDEApBpp1p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p4mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p4m3 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p4eq HABCDECpp1p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p4 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p4mtmp;try rewrite HT2 in HABCDECpp1p4mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (nil) 5 0 2 HABCDECpp1p4mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp1p4M5 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) <= 5).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p4 :: nil) (p1 :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: C :: D :: E :: p4 :: nil) ((p1 :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 1 4 0 Hp1Mtmp HACDEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p4m4 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p4eq HABCDEp1p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p4mtmp;try rewrite HT2 in HABCDEp1p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 5) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 5 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p4m5 : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p4eq : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) = 5) by (apply LABCDEp1p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p4eq HABCDEp1p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p4mtmp;try rewrite HT2 in HABCDEp1p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

assert(HACDEp1p4M : rk(A :: C :: D :: E :: p1 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HACDEp1p4m : rk(A :: C :: D :: E :: p1 :: p4 ::  nil) >= 1) by (solve_hyps_min HACDEp1p4eq HACDEp1p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADEp4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: D :: E :: p4 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ACDEApp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ABCDEApp4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp4m5 : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp4 requis par la preuve de (?)ACDEApp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp4 requis par la preuve de (?)ACDEApp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEp4 requis par la preuve de (?)ACEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACEp4M3 : rk(A :: C :: E :: p4 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p4 :: nil) (C :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: E :: p4 :: nil) ((C :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HCMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACEp4m2 : rk(A :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp4 requis par la preuve de (?)ACDEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp4M4 : rk(A :: C :: D :: E :: p4 :: nil) <= 4).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACEp4Mtmp : rk(A :: C :: E :: p4 :: nil) <= 3) by (solve_hyps_max HACEp4eq HACEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p4 :: nil) (D :: A :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: E :: p4 :: nil) ((D :: nil) ++ (A :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: E :: p4 :: nil) (nil) 1 3 0 HDMtmp HACEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp4 requis par la preuve de (?)ACDEApp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp4M5 : rk(A :: C :: D :: E :: Ap :: p4 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp4Mtmp : rk(A :: C :: D :: E :: p4 :: nil) <= 4) by (solve_hyps_max HACDEp4eq HACDEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p4 :: nil) (Ap :: A :: C :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p4 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p4 :: nil) (nil) 1 4 0 HApMtmp HACDEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p4 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp4m4 : rk(A :: C :: D :: E :: Ap :: p4 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp4mtmp : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApp4eq HABCDEApp4m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p4 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p4 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp4mtmp;try rewrite HT2 in HABCDEApp4mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p4 :: nil) (Ap :: nil) 5 1 2 HABCDEApp4mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp4 requis par la preuve de (?)ADEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADEp4M3 : rk(A :: D :: E :: p4 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p4 :: nil) (D :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: E :: p4 :: nil) ((D :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HDMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p4 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp4m2 : rk(A :: D :: E :: p4 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp4mtmp : rk(A :: C :: D :: E :: Ap :: p4 :: nil) >= 4) by (solve_hyps_min HACDEApp4eq HACDEApp4m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p4 :: nil) (C :: Ap :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p4 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp4mtmp;try rewrite HT2 in HACDEApp4mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p4 :: nil) (nil) 4 0 2 HACDEApp4mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p4 ::  de rang :  5 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp4m3 : rk(A :: D :: E :: p4 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p4eq : rk(A :: C :: D :: E :: p1 :: p4 :: nil) = 5) by (apply LACDEp1p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACDEp1p4mtmp : rk(A :: C :: D :: E :: p1 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p4eq HACDEp1p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p4mtmp;try rewrite HT2 in HACDEp1p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p4 :: nil) (nil) 5 0 2 HACDEp1p4mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

assert(HADEp4M : rk(A :: D :: E :: p4 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HADEp4eq HADEp4M4).
assert(HADEp4m : rk(A :: D :: E :: p4 ::  nil) >= 1) by (solve_hyps_min HADEp4eq HADEp4m1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApBpCpDpEpp4 *)
(* dans la couche 0 *)
Lemma LAApBpCpDpEpp2p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour AApBpCpDpEpp2p4 requis par la preuve de (?)AApBpCpDpEpp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour AApBpCpDpEpp2p4 requis par la preuve de (?)AApBpCpDpEpp2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpCpDpEpp2p4m5 : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et -4*)
assert(HAApBpCpDpEpp2p4M5 : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 :: nil) <= 5).
{
	assert(HAApBpCpDpEpp2eq : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) = 5) by (apply LAApBpCpDpEpp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAApBpCpDpEpp2Mtmp : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) <= 5) by (solve_hyps_max HAApBpCpDpEpp2eq HAApBpCpDpEpp2M5).
	assert(HApBpCpDpEpp4Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp4eq HApBpCpDpEpp4M5).
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (list_inter (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 :: nil) (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) ((A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) ++ (Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 5 HAApBpCpDpEpp2Mtmp HApBpCpDpEpp4Mtmp HApBpCpDpEpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAApBpCpDpEpp2p4M : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HAApBpCpDpEpp2p4m : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 ::  nil) >= 1) by (solve_hyps_min HAApBpCpDpEpp2p4eq HAApBpCpDpEpp2p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpCpDpEpp4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour AApBpCpDpEpp4 requis par la preuve de (?)AApBpCpDpEpp4 pour la règle 6  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour AApBpCpDpEpp4 requis par la preuve de (?)AApBpCpDpEpp4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpCpDpEpp4m5 : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpDpEpp4M5 : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) <= 5).
{
	assert(HAApBpCpDpEpp2p4eq : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 :: nil) = 5) by (apply LAApBpCpDpEpp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAApBpCpDpEpp2p4Mtmp : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 :: nil) <= 5) by (solve_hyps_max HAApBpCpDpEpp2p4eq HAApBpCpDpEpp2p4M5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: p4 :: nil) 5 5 HAApBpCpDpEpp2p4Mtmp Hcomp Hincl);apply HT.
}

assert(HAApBpCpDpEpp4M : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HAApBpCpDpEpp4m : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) >= 1) by (solve_hyps_min HAApBpCpDpEpp4eq HAApBpCpDpEpp4m1).
intuition.
Qed.

(* dans constructLemma(), requis par Lp2p4 *)
(* dans la couche 0 *)
Lemma LABCp2p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: p2 :: p4 :: p5 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCp2p4p5 requis par la preuve de (?)ABCp2p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABCp2p5 requis par la preuve de (?)ABCp2p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2p5 requis par la preuve de (?)ABCp2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCp2p5 requis par la preuve de (?)ABCp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp5 requis par la preuve de (?)ABCp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp5M3 : rk(A :: B :: C :: p5 :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p5 :: nil) (A :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p5 :: nil) ((A :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HAMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp5m2 : rk(A :: B :: C :: p5 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p5 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCp2p5 requis par la preuve de (?)ABCp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCECpp2p5 requis par la preuve de (?)ABCp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2p5 requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2p5 requis par la preuve de (?)ABCDECpp2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCECpp2p5 requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCECpp2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCDECpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDECpm2 : rk(A :: C :: D :: E :: Cp :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDECpm4 : rk(A :: C :: D :: E :: Cp :: nil) >= 4).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (B :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: Cp :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HBCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCCpm2 : rk(A :: B :: C :: Cp :: nil) >= 2).
{
	assert(HACDECpMtmp : rk(A :: C :: D :: E :: Cp :: nil) <= 5) by (solve_hyps_max HACDECpeq HACDECpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HACDECpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCCpm3 : rk(A :: B :: C :: Cp :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDECpp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp2p5 requis par la preuve de (?)ABCECpp2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp2p5 requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp2p5 requis par la preuve de (?)ABCDEApBpCpp2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp2p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp2p5 requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp2p5m2 : rk(A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp2p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp2p5eq HABCDEApBpCpp2p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp2p5mtmp;try rewrite HT2 in HABCDEApBpCpp2p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp2p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCECpp2p5m3 : rk(A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) >= 3).
{
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 3) by (solve_hyps_min HABCCpeq HABCCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) 3 3 HABCCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 :: p5 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp2p5m4 : rk(A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp2p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp2p5eq HABCDECpp2p5m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2p5mtmp;try rewrite HT2 in HABCDECpp2p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) (Cp :: nil) 5 1 2 HABCDECpp2p5mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABCp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCp2p5 requis par la preuve de (?)ABCp2p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Cp :: p2 :: p5 ::  de rang :  4 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABCp2p5m2 : rk(A :: B :: C :: p2 :: p5 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCECpp2p5mtmp : rk(A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) >= 4) by (solve_hyps_min HABCECpp2p5eq HABCECpp2p5m4).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: C :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) (A :: C :: E :: Cp :: A :: B :: C :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: C :: p2 :: p5 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: C :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp2p5mtmp;try rewrite HT2 in HABCECpp2p5mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: C :: p2 :: p5 :: nil) (A :: C :: nil) 4 2 4 HABCECpp2p5mtmp HACmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCp2p5M4 : rk(A :: B :: C :: p2 :: p5 :: nil) <= 4).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HABCp5Mtmp : rk(A :: B :: C :: p5 :: nil) <= 3) by (solve_hyps_max HABCp5eq HABCp5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: p5 :: nil) (p2 :: A :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: B :: C :: p5 :: nil) ((p2 :: nil) ++ (A :: B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: B :: C :: p5 :: nil) (nil) 1 3 0 Hp2Mtmp HABCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et 5*)
assert(HABCp2p5M3 : rk(A :: B :: C :: p2 :: p5 :: nil) <= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: p5 :: nil) (A :: p2 :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: B :: C :: p5 :: nil) ((A :: p2 :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HAp2Mtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2p5m3 : rk(A :: B :: C :: p2 :: p5 :: nil) >= 3).
{
	assert(HBCp2eq : rk(B :: C :: p2 :: nil) = 3) by (apply LBCp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HBCp2mtmp : rk(B :: C :: p2 :: nil) >= 3) by (solve_hyps_min HBCp2eq HBCp2m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: p2 :: nil) (A :: B :: C :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: p2 :: nil) (A :: B :: C :: p2 :: p5 :: nil) 3 3 HBCp2mtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCp2p4p5 requis par la preuve de (?)ABCp2p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCp2p4p5 requis par la preuve de (?)ABCp2p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCp4p5 requis par la preuve de (?)ABCp2p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEp1p4p5 requis par la preuve de (?)BCp4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p4p5 requis par la preuve de (?)ABCEp1p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p4p5 requis par la preuve de (?)ABCDEp1p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p4p5m5 : rk(A :: B :: C :: D :: E :: p1 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp1p4p5 requis par la preuve de (?)ABCEp1p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p4p5 requis par la preuve de (?)ABCEp1p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p4p5 requis par la preuve de (?)ABCDECpp1p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p4p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp1p4p5 requis par la preuve de (?)ABCEp1p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p4p5 requis par la preuve de (?)ABCEp1p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p4p5 requis par la preuve de (?)ABCDEApBpp1p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp1p4p5 requis par la preuve de (?)ABCEp1p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp1p4p5m2 : rk(A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp1p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p4p5eq HABCDEApBpp1p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p4 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p1 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p4p5mtmp;try rewrite HT2 in HABCDEApBpp1p4p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p4p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp1p4p5m3 : rk(A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p4p5eq HABCDECpp1p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p4 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: p1 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p1 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p4p5mtmp;try rewrite HT2 in HABCDECpp1p4p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) (nil) 5 0 2 HABCDECpp1p4p5mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HABCEp1p4p5m4 : rk(A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) >= 4).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HABCDEp1p4p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p4p5eq HABCDEp1p4p5m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p4 :: p5 :: nil) (D :: p1 :: A :: B :: C :: E :: p1 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) ((D :: p1 :: nil) ++ (A :: B :: C :: E :: p1 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p4p5mtmp;try rewrite HT2 in HABCDEp1p4p5mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p4p5mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCp4p5 requis par la preuve de (?)BCp4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: E :: p1 :: p4 :: p5 ::  de rang :  4 et 6 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: E :: p1 ::   de rang : 3 et 3 *)
assert(HBCp4p5m2 : rk(B :: C :: p4 :: p5 :: nil) >= 2).
{
	assert(HABEp1eq : rk(A :: B :: E :: p1 :: nil) = 3) by (apply LABEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCEp1p4p5mtmp : rk(A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HABCEp1p4p5eq HABCEp1p4p5m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: E :: p1 :: nil) (B :: C :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p4 :: p5 :: nil) (A :: B :: E :: p1 :: B :: C :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: p1 :: B :: C :: p4 :: p5 :: nil) ((A :: B :: E :: p1 :: nil) ++ (B :: C :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEp1p4p5mtmp;try rewrite HT2 in HABCEp1p4p5mtmp.
	assert(HT := rule_4 (A :: B :: E :: p1 :: nil) (B :: C :: p4 :: p5 :: nil) (B :: nil) 4 1 3 HABCEp1p4p5mtmp HBmtmp HABEp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCp2p4p5 requis par la preuve de (?)ABCp2p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCECpp2p4p5 requis par la preuve de (?)ABCp2p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2p4p5 requis par la preuve de (?)ABCECpp2p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2p4p5 requis par la preuve de (?)ABCDECpp2p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2p4p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCECpp2p4p5 requis par la preuve de (?)ABCECpp2p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp2p4p5 requis par la preuve de (?)ABCECpp2p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp2p4p5 requis par la preuve de (?)ABCECpp2p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp2p4p5 requis par la preuve de (?)ABCDEApBpCpp2p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp2p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp2p4p5 requis par la preuve de (?)ABCECpp2p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp2p4p5m2 : rk(A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp2p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp2p4p5eq HABCDEApBpCpp2p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p4 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp2p4p5mtmp;try rewrite HT2 in HABCDEApBpCpp2p4p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp2p4p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCECpp2p4p5m3 : rk(A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil) >= 3).
{
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 3) by (solve_hyps_min HABCCpeq HABCCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil) 3 3 HABCCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp2p4p5m4 : rk(A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp2p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp2p4p5eq HABCDECpp2p4p5m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2p4p5mtmp;try rewrite HT2 in HABCDECpp2p4p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil) (Cp :: nil) 5 1 2 HABCDECpp2p4p5mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCp2p4p5 requis par la preuve de (?)ABCp2p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 ::  de rang :  4 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABCp2p4p5m2 : rk(A :: B :: C :: p2 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCECpp2p4p5mtmp : rk(A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HABCECpp2p4p5eq HABCECpp2p4p5m4).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: C :: p2 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p2 :: p4 :: p5 :: nil) (A :: C :: E :: Cp :: A :: B :: C :: p2 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: C :: p2 :: p4 :: p5 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: C :: p2 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp2p4p5mtmp;try rewrite HT2 in HABCECpp2p4p5mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: C :: p2 :: p4 :: p5 :: nil) (A :: C :: nil) 4 2 4 HABCECpp2p4p5mtmp HACmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HABCp2p4p5M5 : rk(A :: B :: C :: p2 :: p4 :: p5 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HBCp4p5Mtmp : rk(B :: C :: p4 :: p5 :: nil) <= 4) by (solve_hyps_max HBCp4p5eq HBCp4p5M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (B :: C :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: p4 :: p5 :: nil) (A :: p2 :: B :: C :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: B :: C :: p4 :: p5 :: nil) ((A :: p2 :: nil) ++ (B :: C :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (B :: C :: p4 :: p5 :: nil) (nil) 1 4 0 HAp2Mtmp HBCp4p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2p4p5m3 : rk(A :: B :: C :: p2 :: p4 :: p5 :: nil) >= 3).
{
	assert(HBCp2eq : rk(B :: C :: p2 :: nil) = 3) by (apply LBCp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HBCp2mtmp : rk(B :: C :: p2 :: nil) >= 3) by (solve_hyps_min HBCp2eq HBCp2m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: p2 :: nil) (A :: B :: C :: p2 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: p2 :: nil) (A :: B :: C :: p2 :: p4 :: p5 :: nil) 3 3 HBCp2mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCp2p4p5M4 : rk(A :: B :: C :: p2 :: p4 :: p5 :: nil) <= 4).
{
	assert(Hp4Mtmp : rk(p4 :: nil) <= 1) by (solve_hyps_max Hp4eq Hp4M1).
	assert(HABCp2p5Mtmp : rk(A :: B :: C :: p2 :: p5 :: nil) <= 3) by (solve_hyps_max HABCp2p5eq HABCp2p5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p4 :: nil) (A :: B :: C :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: p4 :: p5 :: nil) (p4 :: A :: B :: C :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p4 :: A :: B :: C :: p2 :: p5 :: nil) ((p4 :: nil) ++ (A :: B :: C :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p4 :: nil) (A :: B :: C :: p2 :: p5 :: nil) (nil) 1 3 0 Hp4Mtmp HABCp2p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2p4p5m4 : rk(A :: B :: C :: p2 :: p4 :: p5 :: nil) >= 4).
{
	assert(HABCp4eq : rk(A :: B :: C :: p4 :: nil) = 4) by (apply LABCp4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp4mtmp : rk(A :: B :: C :: p4 :: nil) >= 4) by (solve_hyps_min HABCp4eq HABCp4m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: p4 :: nil) (A :: B :: C :: p2 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: p4 :: nil) (A :: B :: C :: p2 :: p4 :: p5 :: nil) 4 4 HABCp4mtmp Hcomp Hincl);apply HT.
}

assert(HABCp2p4p5M : rk(A :: B :: C :: p2 :: p4 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCp2p4p5m : rk(A :: B :: C :: p2 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min HABCp2p4p5eq HABCp2p4p5m1).
intuition.
Qed.

(* dans constructLemma(), requis par Lp2p4 *)
(* dans la couche 0 *)
Lemma LABCp2p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: p2 :: p5 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2p5 requis par la preuve de (?)ABCp2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCp2p5 requis par la preuve de (?)ABCp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp5 requis par la preuve de (?)ABCp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp5M3 : rk(A :: B :: C :: p5 :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p5 :: nil) (A :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p5 :: nil) ((A :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HAMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp5m2 : rk(A :: B :: C :: p5 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p5 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCp2p5 requis par la preuve de (?)ABCp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCECpp2p5 requis par la preuve de (?)ABCp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2p5 requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2p5 requis par la preuve de (?)ABCDECpp2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCECpp2p5 requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCECpp2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCDECpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDECpm2 : rk(A :: C :: D :: E :: Cp :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDECpm4 : rk(A :: C :: D :: E :: Cp :: nil) >= 4).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (B :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: Cp :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HBCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCCpm2 : rk(A :: B :: C :: Cp :: nil) >= 2).
{
	assert(HACDECpMtmp : rk(A :: C :: D :: E :: Cp :: nil) <= 5) by (solve_hyps_max HACDECpeq HACDECpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HACDECpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCCpm3 : rk(A :: B :: C :: Cp :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDECpp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp2p5 requis par la preuve de (?)ABCECpp2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp2p5 requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp2p5 requis par la preuve de (?)ABCDEApBpCpp2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp2p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp2p5 requis par la preuve de (?)ABCECpp2p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp2p5m2 : rk(A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp2p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp2p5eq HABCDEApBpCpp2p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p2 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp2p5mtmp;try rewrite HT2 in HABCDEApBpCpp2p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp2p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCECpp2p5m3 : rk(A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) >= 3).
{
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 3) by (solve_hyps_min HABCCpeq HABCCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) 3 3 HABCCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 :: p5 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp2p5m4 : rk(A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp2p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp2p5eq HABCDECpp2p5m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2p5mtmp;try rewrite HT2 in HABCDECpp2p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) (Cp :: nil) 5 1 2 HABCDECpp2p5mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABCp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCp2p5 requis par la preuve de (?)ABCp2p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Cp :: p2 :: p5 ::  de rang :  4 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABCp2p5m2 : rk(A :: B :: C :: p2 :: p5 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCECpp2p5mtmp : rk(A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) >= 4) by (solve_hyps_min HABCECpp2p5eq HABCECpp2p5m4).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: C :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p2 :: p5 :: nil) (A :: C :: E :: Cp :: A :: B :: C :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: C :: p2 :: p5 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: C :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp2p5mtmp;try rewrite HT2 in HABCECpp2p5mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: C :: p2 :: p5 :: nil) (A :: C :: nil) 4 2 4 HABCECpp2p5mtmp HACmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCp2p5M4 : rk(A :: B :: C :: p2 :: p5 :: nil) <= 4).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HABCp5Mtmp : rk(A :: B :: C :: p5 :: nil) <= 3) by (solve_hyps_max HABCp5eq HABCp5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: p5 :: nil) (p2 :: A :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: B :: C :: p5 :: nil) ((p2 :: nil) ++ (A :: B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: B :: C :: p5 :: nil) (nil) 1 3 0 Hp2Mtmp HABCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et 5*)
assert(HABCp2p5M3 : rk(A :: B :: C :: p2 :: p5 :: nil) <= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: p5 :: nil) (A :: p2 :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: B :: C :: p5 :: nil) ((A :: p2 :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HAp2Mtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2p5m3 : rk(A :: B :: C :: p2 :: p5 :: nil) >= 3).
{
	assert(HBCp2eq : rk(B :: C :: p2 :: nil) = 3) by (apply LBCp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HBCp2mtmp : rk(B :: C :: p2 :: nil) >= 3) by (solve_hyps_min HBCp2eq HBCp2m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: p2 :: nil) (A :: B :: C :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: p2 :: nil) (A :: B :: C :: p2 :: p5 :: nil) 3 3 HBCp2mtmp Hcomp Hincl);apply HT.
}

assert(HABCp2p5M : rk(A :: B :: C :: p2 :: p5 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HABCp2p5eq HABCp2p5M5).
assert(HABCp2p5m : rk(A :: B :: C :: p2 :: p5 ::  nil) >= 1) by (solve_hyps_min HABCp2p5eq HABCp2p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lp2p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(p2 :: p4 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour p2p4 requis par la preuve de (?)p2p4 pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(Hp2p4m2 : rk(p2 :: p4 :: nil) >= 2).
{
	assert(HABCp2p5eq : rk(A :: B :: C :: p2 :: p5 :: nil) = 3) by (apply LABCp2p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp2p5Mtmp : rk(A :: B :: C :: p2 :: p5 :: nil) <= 3) by (solve_hyps_max HABCp2p5eq HABCp2p5M3).
	assert(HABCp2p4p5eq : rk(A :: B :: C :: p2 :: p4 :: p5 :: nil) = 4) by (apply LABCp2p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp2p4p5mtmp : rk(A :: B :: C :: p2 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HABCp2p4p5eq HABCp2p4p5m4).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (p2 :: p4 :: nil) (A :: B :: C :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: p4 :: p5 :: nil) (p2 :: p4 :: A :: B :: C :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: p4 :: A :: B :: C :: p2 :: p5 :: nil) ((p2 :: p4 :: nil) ++ (A :: B :: C :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2p4p5mtmp;try rewrite HT2 in HABCp2p4p5mtmp.
	assert(HT := rule_2 (p2 :: p4 :: nil) (A :: B :: C :: p2 :: p5 :: nil) (p2 :: nil) 4 1 3 HABCp2p4p5mtmp Hp2mtmp HABCp2p5Mtmp Hincl);apply HT.
}

assert(Hp2p4M : rk(p2 :: p4 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max Hp2p4eq Hp2p4M2).
assert(Hp2p4m : rk(p2 :: p4 ::  nil) >= 1) by (solve_hyps_min Hp2p4eq Hp2p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp2p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: p2 :: p4 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ap2p4 requis par la preuve de (?)Ap2p4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Ap2p4 requis par la preuve de (?)Ap2p4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAp2p4M2 : rk(A :: p2 :: p4 :: nil) <= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp4Mtmp : rk(p4 :: nil) <= 1) by (solve_hyps_max Hp4eq Hp4M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p2 :: p4 :: nil) (A :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p4 :: nil) ((A :: p2 :: nil) ++ (p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p4 :: nil) (nil) 1 1 0 HAp2Mtmp Hp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp2p4m2 : rk(A :: p2 :: p4 :: nil) >= 2).
{
	assert(HAp4mtmp : rk(A :: p4 :: nil) >= 2) by (solve_hyps_min HAp4eq HAp4m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p4 :: nil) (A :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p4 :: nil) (A :: p2 :: p4 :: nil) 2 2 HAp4mtmp Hcomp Hincl);apply HT.
}

assert(HAp2p4M : rk(A :: p2 :: p4 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HAp2p4eq HAp2p4M3).
assert(HAp2p4m : rk(A :: p2 :: p4 ::  nil) >= 1) by (solve_hyps_min HAp2p4eq HAp2p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCEp2p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: E :: p2 :: p4 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ABCEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp4 requis par la preuve de (?)ABCDEApp4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp4m5 : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp4 requis par la preuve de (?)ABCEp4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp4 requis par la preuve de (?)ABEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp4M3 : rk(A :: B :: E :: p4 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p4 :: nil) (B :: A :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: E :: p4 :: nil) ((B :: nil) ++ (A :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: E :: p4 :: nil) (nil) 1 2 0 HBMtmp HAEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp4 requis par la preuve de (?)ABCEp4 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp4M4 : rk(A :: B :: C :: E :: p4 :: nil) <= 4).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABEp4Mtmp : rk(A :: B :: E :: p4 :: nil) <= 3) by (solve_hyps_max HABEp4eq HABEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p4 :: nil) (C :: A :: B :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: E :: p4 :: nil) ((C :: nil) ++ (A :: B :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: E :: p4 :: nil) (nil) 1 3 0 HCMtmp HABEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCEp4m2 : rk(A :: B :: C :: E :: p4 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: E :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: E :: p4 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp4m3 : rk(A :: B :: C :: E :: p4 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp4mtmp : rk(A :: B :: C :: D :: E :: Ap :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApp4eq HABCDEApp4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p4 :: nil) (D :: Ap :: A :: B :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p4 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp4mtmp;try rewrite HT2 in HABCDEApp4mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p4 :: nil) (nil) 5 0 2 HABCDEApp4mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2p4 requis par la preuve de (?)ABCDECpp2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp2p4 requis par la preuve de (?)ABCDEApBpp2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp2p4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp2p4 requis par la preuve de (?)ABCEp2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp2p4m2 : rk(A :: B :: C :: E :: p2 :: p4 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp2p4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp2p4eq HABCDEApBpp2p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p4 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p2 :: p4 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp2p4mtmp;try rewrite HT2 in HABCDEApBpp2p4mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp2p4mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp2p4m3 : rk(A :: B :: C :: E :: p2 :: p4 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp2p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp2p4eq HABCDECpp2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) (D :: Cp :: A :: B :: C :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p2 :: p4 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2p4mtmp;try rewrite HT2 in HABCDECpp2p4mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDECpp2p4mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2p4M5 : rk(A :: B :: C :: E :: p2 :: p4 :: nil) <= 5).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HABCEp4Mtmp : rk(A :: B :: C :: E :: p4 :: nil) <= 4) by (solve_hyps_max HABCEp4eq HABCEp4M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: B :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: p4 :: nil) (p2 :: A :: B :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: B :: C :: E :: p4 :: nil) ((p2 :: nil) ++ (A :: B :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: B :: C :: E :: p4 :: nil) (nil) 1 4 0 Hp2Mtmp HABCEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCEp2p4M4 : rk(A :: B :: C :: E :: p2 :: p4 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEp4Mtmp : rk(A :: B :: C :: E :: p4 :: nil) <= 4) by (solve_hyps_max HABCEp4eq HABCEp4M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: B :: C :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: p4 :: nil) (A :: p2 :: A :: B :: C :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: B :: C :: E :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: B :: C :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: B :: C :: E :: p4 :: nil) (A :: nil) 1 4 1 HAp2Mtmp HABCEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p2 :: p4 ::  de rang :  5 et 5 	 AiB : p2 ::  de rang :  1 et 1 	 A : D :: p2 ::   de rang : 2 et 2 *)
assert(HABCEp2p4m4 : rk(A :: B :: C :: E :: p2 :: p4 :: nil) >= 4).
{
	assert(HDp2eq : rk(D :: p2 :: nil) = 2) by (apply LDp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp2Mtmp : rk(D :: p2 :: nil) <= 2) by (solve_hyps_max HDp2eq HDp2M2).
	assert(HABCDEp2p4eq : rk(A :: B :: C :: D :: E :: p2 :: p4 :: nil) = 5) by (apply LABCDEp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp2p4mtmp : rk(A :: B :: C :: D :: E :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp2p4eq HABCDEp2p4m5).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (D :: p2 :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: p4 :: nil) (D :: p2 :: A :: B :: C :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p2 :: A :: B :: C :: E :: p2 :: p4 :: nil) ((D :: p2 :: nil) ++ (A :: B :: C :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp2p4mtmp;try rewrite HT2 in HABCDEp2p4mtmp.
	assert(HT := rule_4 (D :: p2 :: nil) (A :: B :: C :: E :: p2 :: p4 :: nil) (p2 :: nil) 5 1 2 HABCDEp2p4mtmp Hp2mtmp HDp2Mtmp Hincl); apply HT.
}

assert(HABCEp2p4M : rk(A :: B :: C :: E :: p2 :: p4 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCEp2p4m : rk(A :: B :: C :: E :: p2 :: p4 ::  nil) >= 1) by (solve_hyps_min HABCEp2p4eq HABCEp2p4m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADEp2p4 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: D :: E :: p2 :: p4 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p4 requis par la preuve de (?)ABCDEp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p4m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2p4 requis par la preuve de (?)ABCDECpp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p2p4 requis par la preuve de (?)ABCDEApBpp1p2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p2p4m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p4 requis par la preuve de (?)ACDEp1p2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p2p4m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p2p4mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2p4eq HABCDEApBpp1p2p4m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p4 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2p4mtmp;try rewrite HT2 in HABCDEApBpp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2p4mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p2p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p4eq HABCDECpp1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p4 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p4mtmp;try rewrite HT2 in HABCDECpp1p2p4mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (nil) 5 0 2 HABCDECpp1p2p4mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p2p4m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p4mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p4m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p4mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p4eq HABCDEp1p2p4m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p4mtmp;try rewrite HT2 in HABCDEp1p2p4mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p4mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2p4 requis par la preuve de (?)ABCDECpp2p4 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2p4m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCECp requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCCp requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCCpm2 : rk(B :: C :: Cp :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_2 (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDECpp1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : B :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HBCECpm2 : rk(B :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HBCCpmtmp : rk(B :: C :: Cp :: nil) >= 2) by (solve_hyps_min HBCCpeq HBCCpm2).
	assert(Hincl : incl (B :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (B :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil) (B :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HBCCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCECpm3 : rk(B :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (B :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: B :: p1 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCECpp1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ADEp2p4 requis par la preuve de (?)ADEp2p4 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 :: p4 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HADEp2p4m2 : rk(A :: D :: E :: p2 :: p4 :: nil) >= 2).
{
	assert(HBCECpMtmp : rk(B :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBCECpeq HBCECpM4).
	assert(HABCDECpp2p4mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HABCDECpp2p4eq HABCDECpp2p4m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: D :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: p4 :: nil) (B :: C :: E :: Cp :: A :: D :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: D :: E :: p2 :: p4 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: D :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2p4mtmp;try rewrite HT2 in HABCDECpp2p4mtmp.
	assert(HT := rule_4 (B :: C :: E :: Cp :: nil) (A :: D :: E :: p2 :: p4 :: nil) (E :: nil) 5 1 4 HABCDECpp2p4mtmp HEmtmp HBCECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p4 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp2p4m3 : rk(A :: D :: E :: p2 :: p4 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p4mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p4eq HACDEp1p2p4m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p2 :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p4 :: nil) (C :: p1 :: A :: D :: E :: p2 :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p2 :: p4 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p2 :: p4 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p4mtmp;try rewrite HT2 in HACDEp1p2p4mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p2 :: p4 :: nil) (nil) 5 0 2 HACDEp1p2p4mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 4 et 5*)
assert(HADEp2p4M4 : rk(A :: D :: E :: p2 :: p4 :: nil) <= 4).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HADEp4eq : rk(A :: D :: E :: p4 :: nil) = 3) by (apply LADEp4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADEp4Mtmp : rk(A :: D :: E :: p4 :: nil) <= 3) by (solve_hyps_max HADEp4eq HADEp4M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p4 :: nil) (p2 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: D :: E :: p4 :: nil) ((p2 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: D :: E :: p4 :: nil) (nil) 1 3 0 Hp2Mtmp HADEp4Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -2*)
assert(HADEp2p4M3 : rk(A :: D :: E :: p2 :: p4 :: nil) <= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HADEp4eq : rk(A :: D :: E :: p4 :: nil) = 3) by (apply LADEp4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADEp4Mtmp : rk(A :: D :: E :: p4 :: nil) <= 3) by (solve_hyps_max HADEp4eq HADEp4M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: p2 :: nil) (A :: D :: E :: p4 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: p4 :: nil) (A :: p2 :: A :: D :: E :: p4 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: A :: D :: E :: p4 :: nil) ((A :: p2 :: nil) ++ (A :: D :: E :: p4 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (A :: D :: E :: p4 :: nil) (A :: nil) 1 3 1 HAp2Mtmp HADEp4Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HADEp2p4M : rk(A :: D :: E :: p2 :: p4 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HADEp2p4eq HADEp2p4M5).
assert(HADEp2p4m : rk(A :: D :: E :: p2 :: p4 ::  nil) >= 1) by (solve_hyps_min HADEp2p4eq HADEp2p4m1).
intuition.
Qed.

(* dans constructLemma(), requis par LAp5 *)
(* dans constructLemma(), requis par LABCp5 *)
(* dans constructLemma(), requis par LABCEp2p5 *)
(* dans constructLemma(), requis par LABCDEp2p5 *)
(* dans constructLemma(), requis par LBCDEp5 *)
(* dans constructLemma(), requis par LABCDEp1p5 *)
(* dans la couche 0 *)
Lemma LABCDEp1p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p1 :: p5 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCDEp5 requis par la preuve de (?)ABCDEp1p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp5 requis par la preuve de (?)BCDEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp5 requis par la preuve de (?)ABCDEApp5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp5m5 : rk(A :: B :: C :: D :: E :: Ap :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)BCDEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDEp5 requis par la preuve de (?)BCDEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCDp5 requis par la preuve de (?)BCDEp5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDp5 requis par la preuve de (?)BCDp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCDp5M3 : rk(B :: C :: D :: p5 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: p5 :: nil) (D :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B :: C :: p5 :: nil) ((D :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HDMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour BCDEp5 requis par la preuve de (?)BCDEp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HBCDEp5M4 : rk(B :: C :: D :: E :: p5 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HBCDp5Mtmp : rk(B :: C :: D :: p5 :: nil) <= 3) by (solve_hyps_max HBCDp5eq HBCDp5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (B :: C :: D :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: p5 :: nil) (E :: B :: C :: D :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B :: C :: D :: p5 :: nil) ((E :: nil) ++ (B :: C :: D :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (B :: C :: D :: p5 :: nil) (nil) 1 3 0 HEMtmp HBCDp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 1 et 2 *)
assert(HBCDEp5m3 : rk(B :: C :: D :: E :: p5 :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HABCDEApp5mtmp : rk(A :: B :: C :: D :: E :: Ap :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApp5eq HABCDEApp5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (B :: C :: D :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p5 :: nil) (A :: Ap :: B :: C :: D :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: B :: C :: D :: E :: p5 :: nil) ((A :: Ap :: nil) ++ (B :: C :: D :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp5mtmp;try rewrite HT2 in HABCDEApp5mtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (B :: C :: D :: E :: p5 :: nil) (nil) 5 0 2 HABCDEApp5mtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p5 requis par la preuve de (?)ABCDEp1p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p5 requis par la preuve de (?)ABCDEp1p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p5m5 : rk(A :: B :: C :: D :: E :: p1 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HABCDEp1p5M5 : rk(A :: B :: C :: D :: E :: p1 :: p5 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HBCDEp5Mtmp : rk(B :: C :: D :: E :: p5 :: nil) <= 4) by (solve_hyps_max HBCDEp5eq HBCDEp5M4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: p1 :: nil) (B :: C :: D :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p5 :: nil) (A :: B :: p1 :: B :: C :: D :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: B :: C :: D :: E :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (B :: C :: D :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (B :: C :: D :: E :: p5 :: nil) (B :: nil) 2 4 1 HABp1Mtmp HBCDEp5Mtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCDEp1p5M : rk(A :: B :: C :: D :: E :: p1 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp1p5m : rk(A :: B :: C :: D :: E :: p1 :: p5 ::  nil) >= 1) by (solve_hyps_min HABCDEp1p5eq HABCDEp1p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCDEp5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(B :: C :: D :: E :: p5 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCDEp5 requis par la preuve de (?)BCDEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp5 requis par la preuve de (?)BCDEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp5 requis par la preuve de (?)ABCDEApp5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp5m5 : rk(A :: B :: C :: D :: E :: Ap :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)BCDEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDEp5 requis par la preuve de (?)BCDEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCDp5 requis par la preuve de (?)BCDEp5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDp5 requis par la preuve de (?)BCDp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCDp5M3 : rk(B :: C :: D :: p5 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: p5 :: nil) (D :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B :: C :: p5 :: nil) ((D :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HDMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour BCDEp5 requis par la preuve de (?)BCDEp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HBCDEp5M4 : rk(B :: C :: D :: E :: p5 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HBCDp5Mtmp : rk(B :: C :: D :: p5 :: nil) <= 3) by (solve_hyps_max HBCDp5eq HBCDp5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (B :: C :: D :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: p5 :: nil) (E :: B :: C :: D :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B :: C :: D :: p5 :: nil) ((E :: nil) ++ (B :: C :: D :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (B :: C :: D :: p5 :: nil) (nil) 1 3 0 HEMtmp HBCDp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 1 et 2 *)
assert(HBCDEp5m3 : rk(B :: C :: D :: E :: p5 :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HABCDEApp5mtmp : rk(A :: B :: C :: D :: E :: Ap :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApp5eq HABCDEApp5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (B :: C :: D :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p5 :: nil) (A :: Ap :: B :: C :: D :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: B :: C :: D :: E :: p5 :: nil) ((A :: Ap :: nil) ++ (B :: C :: D :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp5mtmp;try rewrite HT2 in HABCDEApp5mtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (B :: C :: D :: E :: p5 :: nil) (nil) 5 0 2 HABCDEApp5mtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p5 ::  de rang :  5 et 5 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HBCDEp5m4 : rk(B :: C :: D :: E :: p5 :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p5eq : rk(A :: B :: C :: D :: E :: p1 :: p5 :: nil) = 5) by (apply LABCDEp1p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p5eq HABCDEp1p5m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: p1 :: nil) (B :: C :: D :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p5 :: nil) (A :: B :: p1 :: B :: C :: D :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: B :: C :: D :: E :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (B :: C :: D :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p5mtmp;try rewrite HT2 in HABCDEp1p5mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (B :: C :: D :: E :: p5 :: nil) (B :: nil) 5 1 2 HABCDEp1p5mtmp HBmtmp HABp1Mtmp Hincl); apply HT.
}

assert(HBCDEp5M : rk(B :: C :: D :: E :: p5 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HBCDEp5eq HBCDEp5M5).
assert(HBCDEp5m : rk(B :: C :: D :: E :: p5 ::  nil) >= 1) by (solve_hyps_min HBCDEp5eq HBCDEp5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCDEp2p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: p2 :: p5 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp2p5 requis par la preuve de (?)ABCDEp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp2p5 requis par la preuve de (?)ABCDEp2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp2p5m5 : rk(A :: B :: C :: D :: E :: p2 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p2 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 5*)
assert(HABCDEp2p5M5 : rk(A :: B :: C :: D :: E :: p2 :: p5 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HBCDEp5eq : rk(B :: C :: D :: E :: p5 :: nil) = 4) by (apply LBCDEp5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HBCDEp5Mtmp : rk(B :: C :: D :: E :: p5 :: nil) <= 4) by (solve_hyps_max HBCDEp5eq HBCDEp5M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (B :: C :: D :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: p5 :: nil) (A :: p2 :: B :: C :: D :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: B :: C :: D :: E :: p5 :: nil) ((A :: p2 :: nil) ++ (B :: C :: D :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (B :: C :: D :: E :: p5 :: nil) (nil) 1 4 0 HAp2Mtmp HBCDEp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCDEp2p5M : rk(A :: B :: C :: D :: E :: p2 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEp2p5m : rk(A :: B :: C :: D :: E :: p2 :: p5 ::  nil) >= 1) by (solve_hyps_min HABCDEp2p5eq HABCDEp2p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCEp2p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: E :: p2 :: p5 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp2p5 requis par la preuve de (?)ABCEp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BCEp5 requis par la preuve de (?)ABCEp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCEp5 requis par la preuve de (?)BCEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour BCDEApp5 requis par la preuve de (?)BCEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp5 requis par la preuve de (?)BCDEApp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp5 requis par la preuve de (?)ABCDEApp5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp5m5 : rk(A :: B :: C :: D :: E :: Ap :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)BCDEApp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour BCDEApp5 requis par la preuve de (?)BCDEApp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDEp5 requis par la preuve de (?)BCDEApp5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCDp5 requis par la preuve de (?)BCDEp5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDp5 requis par la preuve de (?)BCDp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCDp5M3 : rk(B :: C :: D :: p5 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: p5 :: nil) (D :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B :: C :: p5 :: nil) ((D :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HDMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour BCDEp5 requis par la preuve de (?)BCDEp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HBCDEp5M4 : rk(B :: C :: D :: E :: p5 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HBCDp5Mtmp : rk(B :: C :: D :: p5 :: nil) <= 3) by (solve_hyps_max HBCDp5eq HBCDp5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (B :: C :: D :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: p5 :: nil) (E :: B :: C :: D :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B :: C :: D :: p5 :: nil) ((E :: nil) ++ (B :: C :: D :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (B :: C :: D :: p5 :: nil) (nil) 1 3 0 HEMtmp HBCDp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour BCDEApp5 requis par la preuve de (?)BCDEApp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HBCDEApp5M5 : rk(B :: C :: D :: E :: Ap :: p5 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HBCDEp5Mtmp : rk(B :: C :: D :: E :: p5 :: nil) <= 4) by (solve_hyps_max HBCDEp5eq HBCDEp5M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: D :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: Ap :: p5 :: nil) (Ap :: B :: C :: D :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: D :: E :: p5 :: nil) ((Ap :: nil) ++ (B :: C :: D :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: D :: E :: p5 :: nil) (nil) 1 4 0 HApMtmp HBCDEp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p5 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 1 et 2 *)
assert(HBCDEApp5m4 : rk(B :: C :: D :: E :: Ap :: p5 :: nil) >= 4).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HABCDEApp5mtmp : rk(A :: B :: C :: D :: E :: Ap :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApp5eq HABCDEApp5m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (B :: C :: D :: E :: Ap :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p5 :: nil) (A :: Ap :: B :: C :: D :: E :: Ap :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: B :: C :: D :: E :: Ap :: p5 :: nil) ((A :: Ap :: nil) ++ (B :: C :: D :: E :: Ap :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp5mtmp;try rewrite HT2 in HABCDEApp5mtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (B :: C :: D :: E :: Ap :: p5 :: nil) (Ap :: nil) 5 1 2 HABCDEApp5mtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)BCEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCEp5 requis par la preuve de (?)BCEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEp5 requis par la preuve de (?)BCEp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCEp5M3 : rk(B :: C :: E :: p5 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: E :: p5 :: nil) (E :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B :: C :: p5 :: nil) ((E :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HEMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : B :: C :: D :: E :: Ap :: p5 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HBCEp5m2 : rk(B :: C :: E :: p5 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HBCDEApp5mtmp : rk(B :: C :: D :: E :: Ap :: p5 :: nil) >= 4) by (solve_hyps_min HBCDEApp5eq HBCDEApp5m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (B :: C :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: Ap :: p5 :: nil) (D :: Ap :: B :: C :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: B :: C :: E :: p5 :: nil) ((D :: Ap :: nil) ++ (B :: C :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCDEApp5mtmp;try rewrite HT2 in HBCDEApp5mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (B :: C :: E :: p5 :: nil) (nil) 4 0 2 HBCDEApp5mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p5 ::  de rang :  5 et 5 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: D :: p1 ::   de rang : 3 et 3 *)
assert(HBCEp5m3 : rk(B :: C :: E :: p5 :: nil) >= 3).
{
	assert(HABDp1eq : rk(A :: B :: D :: p1 :: nil) = 3) by (apply LABDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(HABCDEp1p5eq : rk(A :: B :: C :: D :: E :: p1 :: p5 :: nil) = 5) by (apply LABCDEp1p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p5eq HABCDEp1p5m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: D :: p1 :: nil) (B :: C :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p5 :: nil) (A :: B :: D :: p1 :: B :: C :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: p1 :: B :: C :: E :: p5 :: nil) ((A :: B :: D :: p1 :: nil) ++ (B :: C :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p5mtmp;try rewrite HT2 in HABCDEp1p5mtmp.
	assert(HT := rule_4 (A :: B :: D :: p1 :: nil) (B :: C :: E :: p5 :: nil) (B :: nil) 5 1 3 HABCDEp1p5mtmp HBmtmp HABDp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEp2p5 requis par la preuve de (?)ABCEp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp5 requis par la preuve de (?)ABCEp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp5 requis par la preuve de (?)ABCEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp5 requis par la preuve de (?)ABCEp5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp5M3 : rk(A :: B :: C :: p5 :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p5 :: nil) (A :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p5 :: nil) ((A :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HAMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp5m2 : rk(A :: B :: C :: p5 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p5 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp5 requis par la preuve de (?)ABCEp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp5M4 : rk(A :: B :: C :: E :: p5 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp5Mtmp : rk(A :: B :: C :: p5 :: nil) <= 3) by (solve_hyps_max HABCp5eq HABCp5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p5 :: nil) (E :: A :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p5 :: nil) ((E :: nil) ++ (A :: B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p5 :: nil) (nil) 1 3 0 HEMtmp HABCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp5m3 : rk(A :: B :: C :: E :: p5 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp5mtmp : rk(A :: B :: C :: D :: E :: Ap :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApp5eq HABCDEApp5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p5 :: nil) (D :: Ap :: A :: B :: C :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p5 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp5mtmp;try rewrite HT2 in HABCDEApp5mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p5 :: nil) (nil) 5 0 2 HABCDEApp5mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp2p5 requis par la preuve de (?)ABCEp2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2p5 requis par la preuve de (?)ABCEp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2p5 requis par la preuve de (?)ABCDECpp2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCEp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp2p5 requis par la preuve de (?)ABCEp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp2p5 requis par la preuve de (?)ABCEp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp2p5 requis par la preuve de (?)ABCDEApBpp2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp2p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCEp2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp2p5 requis par la preuve de (?)ABCEp2p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp2p5m2 : rk(A :: B :: C :: E :: p2 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp2p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp2p5eq HABCDEApBpp2p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p2 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p2 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp2p5mtmp;try rewrite HT2 in HABCDEApBpp2p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p2 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp2p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp2p5m3 : rk(A :: B :: C :: E :: p2 :: p5 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp2p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp2p5eq HABCDECpp2p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p2 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2p5mtmp;try rewrite HT2 in HABCDECpp2p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p2 :: p5 :: nil) (nil) 5 0 2 HABCDECpp2p5mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2p5M5 : rk(A :: B :: C :: E :: p2 :: p5 :: nil) <= 5).
{
	assert(Hp2Mtmp : rk(p2 :: nil) <= 1) by (solve_hyps_max Hp2eq Hp2M1).
	assert(HABCEp5Mtmp : rk(A :: B :: C :: E :: p5 :: nil) <= 4) by (solve_hyps_max HABCEp5eq HABCEp5M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p2 :: nil) (A :: B :: C :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: p5 :: nil) (p2 :: A :: B :: C :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p2 :: A :: B :: C :: E :: p5 :: nil) ((p2 :: nil) ++ (A :: B :: C :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p2 :: nil) (A :: B :: C :: E :: p5 :: nil) (nil) 1 4 0 Hp2Mtmp HABCEp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HABCEp2p5M4 : rk(A :: B :: C :: E :: p2 :: p5 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HBCEp5Mtmp : rk(B :: C :: E :: p5 :: nil) <= 3) by (solve_hyps_max HBCEp5eq HBCEp5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (B :: C :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: p5 :: nil) (A :: p2 :: B :: C :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: B :: C :: E :: p5 :: nil) ((A :: p2 :: nil) ++ (B :: C :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (B :: C :: E :: p5 :: nil) (nil) 1 3 0 HAp2Mtmp HBCEp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p2 :: p5 ::  de rang :  5 et 5 	 AiB : p2 ::  de rang :  1 et 1 	 A : D :: p2 ::   de rang : 2 et 2 *)
assert(HABCEp2p5m4 : rk(A :: B :: C :: E :: p2 :: p5 :: nil) >= 4).
{
	assert(HDp2eq : rk(D :: p2 :: nil) = 2) by (apply LDp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp2Mtmp : rk(D :: p2 :: nil) <= 2) by (solve_hyps_max HDp2eq HDp2M2).
	assert(HABCDEp2p5eq : rk(A :: B :: C :: D :: E :: p2 :: p5 :: nil) = 5) by (apply LABCDEp2p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp2p5mtmp : rk(A :: B :: C :: D :: E :: p2 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp2p5eq HABCDEp2p5m5).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (D :: p2 :: nil) (A :: B :: C :: E :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: p5 :: nil) (D :: p2 :: A :: B :: C :: E :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p2 :: A :: B :: C :: E :: p2 :: p5 :: nil) ((D :: p2 :: nil) ++ (A :: B :: C :: E :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp2p5mtmp;try rewrite HT2 in HABCDEp2p5mtmp.
	assert(HT := rule_4 (D :: p2 :: nil) (A :: B :: C :: E :: p2 :: p5 :: nil) (p2 :: nil) 5 1 2 HABCDEp2p5mtmp Hp2mtmp HDp2Mtmp Hincl); apply HT.
}

assert(HABCEp2p5M : rk(A :: B :: C :: E :: p2 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCEp2p5m : rk(A :: B :: C :: E :: p2 :: p5 ::  nil) >= 1) by (solve_hyps_min HABCEp2p5eq HABCEp2p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCp5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: p5 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp5M3 : rk(A :: B :: C :: p5 :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p5 :: nil) (A :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p5 :: nil) ((A :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HAMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp5m2 : rk(A :: B :: C :: p5 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p5 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: E :: p2 :: p5 ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: E :: p2 ::   de rang : 2 et 2 *)
assert(HABCp5m3 : rk(A :: B :: C :: p5 :: nil) >= 3).
{
	assert(HAEp2eq : rk(A :: E :: p2 :: nil) = 2) by (apply LAEp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAEp2Mtmp : rk(A :: E :: p2 :: nil) <= 2) by (solve_hyps_max HAEp2eq HAEp2M2).
	assert(HABCEp2p5eq : rk(A :: B :: C :: E :: p2 :: p5 :: nil) = 4) by (apply LABCEp2p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCEp2p5mtmp : rk(A :: B :: C :: E :: p2 :: p5 :: nil) >= 4) by (solve_hyps_min HABCEp2p5eq HABCEp2p5m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: E :: p2 :: nil) (A :: B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: p5 :: nil) (A :: E :: p2 :: A :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p2 :: A :: B :: C :: p5 :: nil) ((A :: E :: p2 :: nil) ++ (A :: B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEp2p5mtmp;try rewrite HT2 in HABCEp2p5mtmp.
	assert(HT := rule_4 (A :: E :: p2 :: nil) (A :: B :: C :: p5 :: nil) (A :: nil) 4 1 2 HABCEp2p5mtmp HAmtmp HAEp2Mtmp Hincl); apply HT.
}

assert(HABCp5M : rk(A :: B :: C :: p5 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HABCp5eq HABCp5M4).
assert(HABCp5m : rk(A :: B :: C :: p5 ::  nil) >= 1) by (solve_hyps_min HABCp5eq HABCp5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: p5 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ap5 requis par la preuve de (?)Ap5 pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAp5m2 : rk(A :: p5 :: nil) >= 2).
{
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(HABCp5eq : rk(A :: B :: C :: p5 :: nil) = 3) by (apply LABCp5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp5mtmp : rk(A :: B :: C :: p5 :: nil) >= 3) by (solve_hyps_min HABCp5eq HABCp5m3).
	assert(Hp5mtmp : rk(p5 :: nil) >= 1) by (solve_hyps_min Hp5eq Hp5m1).
	assert(Hincl : incl (p5 :: nil) (list_inter (A :: p5 :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p5 :: nil) (A :: p5 :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p5 :: B :: C :: p5 :: nil) ((A :: p5 :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp5mtmp;try rewrite HT2 in HABCp5mtmp.
	assert(HT := rule_2 (A :: p5 :: nil) (B :: C :: p5 :: nil) (p5 :: nil) 3 1 2 HABCp5mtmp Hp5mtmp HBCp5Mtmp Hincl);apply HT.
}

assert(HAp5M : rk(A :: p5 ::  nil) <= 2) (* dim : 5 *) by (solve_hyps_max HAp5eq HAp5M2).
assert(HAp5m : rk(A :: p5 ::  nil) >= 1) by (solve_hyps_min HAp5eq HAp5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCEp5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(B :: C :: E :: p5 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCEp5 requis par la preuve de (?)BCEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour BCDEApp5 requis par la preuve de (?)BCEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp5 requis par la preuve de (?)BCDEApp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp5 requis par la preuve de (?)ABCDEApp5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp5m5 : rk(A :: B :: C :: D :: E :: Ap :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)BCDEApp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour BCDEApp5 requis par la preuve de (?)BCDEApp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDEp5 requis par la preuve de (?)BCDEApp5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCDp5 requis par la preuve de (?)BCDEp5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDp5 requis par la preuve de (?)BCDp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCDp5M3 : rk(B :: C :: D :: p5 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: p5 :: nil) (D :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: B :: C :: p5 :: nil) ((D :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HDMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour BCDEp5 requis par la preuve de (?)BCDEp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HBCDEp5M4 : rk(B :: C :: D :: E :: p5 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HBCDp5Mtmp : rk(B :: C :: D :: p5 :: nil) <= 3) by (solve_hyps_max HBCDp5eq HBCDp5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (B :: C :: D :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: p5 :: nil) (E :: B :: C :: D :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B :: C :: D :: p5 :: nil) ((E :: nil) ++ (B :: C :: D :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (B :: C :: D :: p5 :: nil) (nil) 1 3 0 HEMtmp HBCDp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour BCDEApp5 requis par la preuve de (?)BCDEApp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HBCDEApp5M5 : rk(B :: C :: D :: E :: Ap :: p5 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HBCDEp5Mtmp : rk(B :: C :: D :: E :: p5 :: nil) <= 4) by (solve_hyps_max HBCDEp5eq HBCDEp5M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: D :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: Ap :: p5 :: nil) (Ap :: B :: C :: D :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: D :: E :: p5 :: nil) ((Ap :: nil) ++ (B :: C :: D :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: D :: E :: p5 :: nil) (nil) 1 4 0 HApMtmp HBCDEp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p5 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 1 et 2 *)
assert(HBCDEApp5m4 : rk(B :: C :: D :: E :: Ap :: p5 :: nil) >= 4).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HABCDEApp5mtmp : rk(A :: B :: C :: D :: E :: Ap :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApp5eq HABCDEApp5m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (B :: C :: D :: E :: Ap :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p5 :: nil) (A :: Ap :: B :: C :: D :: E :: Ap :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: B :: C :: D :: E :: Ap :: p5 :: nil) ((A :: Ap :: nil) ++ (B :: C :: D :: E :: Ap :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp5mtmp;try rewrite HT2 in HABCDEApp5mtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (B :: C :: D :: E :: Ap :: p5 :: nil) (Ap :: nil) 5 1 2 HABCDEApp5mtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)BCEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCEp5 requis par la preuve de (?)BCEp5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCEp5 requis par la preuve de (?)BCEp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCEp5M3 : rk(B :: C :: E :: p5 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: E :: p5 :: nil) (E :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: B :: C :: p5 :: nil) ((E :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HEMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : B :: C :: D :: E :: Ap :: p5 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HBCEp5m2 : rk(B :: C :: E :: p5 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HBCDEApp5mtmp : rk(B :: C :: D :: E :: Ap :: p5 :: nil) >= 4) by (solve_hyps_min HBCDEApp5eq HBCDEApp5m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (B :: C :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: E :: Ap :: p5 :: nil) (D :: Ap :: B :: C :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: B :: C :: E :: p5 :: nil) ((D :: Ap :: nil) ++ (B :: C :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCDEApp5mtmp;try rewrite HT2 in HBCDEApp5mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (B :: C :: E :: p5 :: nil) (nil) 4 0 2 HBCDEApp5mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p5 ::  de rang :  5 et 5 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: D :: p1 ::   de rang : 3 et 3 *)
assert(HBCEp5m3 : rk(B :: C :: E :: p5 :: nil) >= 3).
{
	assert(HABDp1eq : rk(A :: B :: D :: p1 :: nil) = 3) by (apply LABDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(HABCDEp1p5eq : rk(A :: B :: C :: D :: E :: p1 :: p5 :: nil) = 5) by (apply LABCDEp1p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEp1p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p5eq HABCDEp1p5m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: D :: p1 :: nil) (B :: C :: E :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p5 :: nil) (A :: B :: D :: p1 :: B :: C :: E :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: p1 :: B :: C :: E :: p5 :: nil) ((A :: B :: D :: p1 :: nil) ++ (B :: C :: E :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p5mtmp;try rewrite HT2 in HABCDEp1p5mtmp.
	assert(HT := rule_4 (A :: B :: D :: p1 :: nil) (B :: C :: E :: p5 :: nil) (B :: nil) 5 1 3 HABCDEp1p5mtmp HBmtmp HABDp1Mtmp Hincl); apply HT.
}

assert(HBCEp5M : rk(B :: C :: E :: p5 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HBCEp5eq HBCEp5M4).
assert(HBCEp5m : rk(B :: C :: E :: p5 ::  nil) >= 1) by (solve_hyps_min HBCEp5eq HBCEp5m1).
intuition.
Qed.

(* dans constructLemma(), requis par LACp1p5 *)
(* dans la couche 0 *)
Lemma LABCp1p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: p1 :: p5 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp1p5 requis par la preuve de (?)ABCp1p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCp1p5 requis par la preuve de (?)ABCp1p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp5 requis par la preuve de (?)ABCp1p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp5 requis par la preuve de (?)ABCp5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp5M3 : rk(A :: B :: C :: p5 :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p5 :: nil) (A :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p5 :: nil) ((A :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 HAMtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp5m2 : rk(A :: B :: C :: p5 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p5 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCp1p5 requis par la preuve de (?)ABCp1p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCECpp1p5 requis par la preuve de (?)ABCp1p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p5 requis par la preuve de (?)ABCECpp1p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p5 requis par la preuve de (?)ABCDECpp1p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp1p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCECpp1p5 requis par la preuve de (?)ABCECpp1p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCECpp1p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCDECpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDECpm2 : rk(A :: C :: D :: E :: Cp :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDECpm4 : rk(A :: C :: D :: E :: Cp :: nil) >= 4).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (B :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: Cp :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HBCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCCpm2 : rk(A :: B :: C :: Cp :: nil) >= 2).
{
	assert(HACDECpMtmp : rk(A :: C :: D :: E :: Cp :: nil) <= 5) by (solve_hyps_max HACDECpeq HACDECpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HACDECpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCCpm3 : rk(A :: B :: C :: Cp :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDECpp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1p5 requis par la preuve de (?)ABCECpp1p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1p5 requis par la preuve de (?)ABCECpp1p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1p5 requis par la preuve de (?)ABCDEApBpCpp1p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp1p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1p5 requis par la preuve de (?)ABCECpp1p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1p5m2 : rk(A :: B :: C :: E :: Cp :: p1 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1p5eq HABCDEApBpCpp1p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1p5mtmp;try rewrite HT2 in HABCDEApBpCpp1p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCECpp1p5m3 : rk(A :: B :: C :: E :: Cp :: p1 :: p5 :: nil) >= 3).
{
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 3) by (solve_hyps_min HABCCpeq HABCCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p5 :: nil) 3 3 HABCCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p5 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1p5m4 : rk(A :: B :: C :: E :: Cp :: p1 :: p5 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p5eq HABCDECpp1p5m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p5mtmp;try rewrite HT2 in HABCDECpp1p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p5 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1p5mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABCp1p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCp1p5 requis par la preuve de (?)ABCp1p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Cp :: p1 :: p5 ::  de rang :  4 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABCp1p5m2 : rk(A :: B :: C :: p1 :: p5 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCECpp1p5mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: p5 :: nil) >= 4) by (solve_hyps_min HABCECpp1p5eq HABCECpp1p5m4).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: C :: p1 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: p5 :: nil) (A :: C :: E :: Cp :: A :: B :: C :: p1 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: C :: p1 :: p5 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: C :: p1 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1p5mtmp;try rewrite HT2 in HABCECpp1p5mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: C :: p1 :: p5 :: nil) (A :: C :: nil) 4 2 4 HABCECpp1p5mtmp HACmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCp1p5M4 : rk(A :: B :: C :: p1 :: p5 :: nil) <= 4).
{
	assert(Hp1Mtmp : rk(p1 :: nil) <= 1) by (solve_hyps_max Hp1eq Hp1M1).
	assert(HABCp5Mtmp : rk(A :: B :: C :: p5 :: nil) <= 3) by (solve_hyps_max HABCp5eq HABCp5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p1 :: nil) (A :: B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: p5 :: nil) (p1 :: A :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p1 :: A :: B :: C :: p5 :: nil) ((p1 :: nil) ++ (A :: B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p1 :: nil) (A :: B :: C :: p5 :: nil) (nil) 1 3 0 Hp1Mtmp HABCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCp1p5M3 : rk(A :: B :: C :: p1 :: p5 :: nil) <= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: p1 :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: p5 :: nil) (A :: B :: p1 :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: B :: C :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (B :: C :: p5 :: nil) (B :: nil) 2 2 1 HABp1Mtmp HBCp5Mtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp1p5m3 : rk(A :: B :: C :: p1 :: p5 :: nil) >= 3).
{
	assert(HACp1eq : rk(A :: C :: p1 :: nil) = 3) by (apply LACp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1mtmp : rk(A :: C :: p1 :: nil) >= 3) by (solve_hyps_min HACp1eq HACp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: p1 :: nil) (A :: B :: C :: p1 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: p1 :: nil) (A :: B :: C :: p1 :: p5 :: nil) 3 3 HACp1mtmp Hcomp Hincl);apply HT.
}

assert(HABCp1p5M : rk(A :: B :: C :: p1 :: p5 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HABCp1p5eq HABCp1p5M5).
assert(HABCp1p5m : rk(A :: B :: C :: p1 :: p5 ::  nil) >= 1) by (solve_hyps_min HABCp1p5eq HABCp1p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACp1p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C :: p1 :: p5 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACp1p5 requis par la preuve de (?)ACp1p5 pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACp1p5 requis par la preuve de (?)ACp1p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACp1p5 requis par la preuve de (?)ACp1p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACp1p5m2 : rk(A :: C :: p1 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: C :: p1 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: C :: p1 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACp1p5m3 : rk(A :: C :: p1 :: p5 :: nil) >= 3).
{
	assert(HACp1eq : rk(A :: C :: p1 :: nil) = 3) by (apply LACp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1mtmp : rk(A :: C :: p1 :: nil) >= 3) by (solve_hyps_min HACp1eq HACp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: p1 :: nil) (A :: C :: p1 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: p1 :: nil) (A :: C :: p1 :: p5 :: nil) 3 3 HACp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACp1p5M3 : rk(A :: C :: p1 :: p5 :: nil) <= 3).
{
	assert(HABCp1p5eq : rk(A :: B :: C :: p1 :: p5 :: nil) = 3) by (apply LABCp1p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp1p5Mtmp : rk(A :: B :: C :: p1 :: p5 :: nil) <= 3) by (solve_hyps_max HABCp1p5eq HABCp1p5M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: p1 :: p5 :: nil) (A :: B :: C :: p1 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: p1 :: p5 :: nil) (A :: B :: C :: p1 :: p5 :: nil) 3 3 HABCp1p5Mtmp Hcomp Hincl);apply HT.
}

assert(HACp1p5M : rk(A :: C :: p1 :: p5 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HACp1p5eq HACp1p5M4).
assert(HACp1p5m : rk(A :: C :: p1 :: p5 ::  nil) >= 1) by (solve_hyps_min HACp1p5eq HACp1p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpCpDpEpp1p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ApBpCpDpEpp1p5 requis par la preuve de (?)ApBpCpDpEpp1p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ApBpCpDpEpp1p5 requis par la preuve de (?)ApBpCpDpEpp1p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HApBpCpDpEpp1p5m5 : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -4*)
assert(HApBpCpDpEpp1p5M5 : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil) <= 5).
{
	assert(HApBpCpDpEpp1Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp1eq HApBpCpDpEpp1M5).
	assert(HApBpCpDpEpp5Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp5eq HApBpCpDpEpp5M5).
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (list_inter (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: Ap :: Bp :: Cp :: Dp :: Ep :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: Ap :: Bp :: Cp :: Dp :: Ep :: p5 :: nil) ((Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: nil) ++ (Ap :: Bp :: Cp :: Dp :: Ep :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 5 HApBpCpDpEpp1Mtmp HApBpCpDpEpp5Mtmp HApBpCpDpEpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApBpCpDpEpp1p5M : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HApBpCpDpEpp1p5m : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 ::  nil) >= 1) by (solve_hyps_min HApBpCpDpEpp1p5eq HApBpCpDpEpp1p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp2p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: p2 :: p5 ::  nil) = 2.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ap2p5 requis par la preuve de (?)Ap2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Ap2p5 requis par la preuve de (?)Ap2p5 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HAp2p5M2 : rk(A :: p2 :: p5 :: nil) <= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp5Mtmp : rk(p5 :: nil) <= 1) by (solve_hyps_max Hp5eq Hp5M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p2 :: p5 :: nil) (A :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p5 :: nil) ((A :: p2 :: nil) ++ (p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p5 :: nil) (nil) 1 1 0 HAp2Mtmp Hp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAp2p5m2 : rk(A :: p2 :: p5 :: nil) >= 2).
{
	assert(HAp5eq : rk(A :: p5 :: nil) = 2) by (apply LAp5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAp5mtmp : rk(A :: p5 :: nil) >= 2) by (solve_hyps_min HAp5eq HAp5m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p5 :: nil) (A :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p5 :: nil) (A :: p2 :: p5 :: nil) 2 2 HAp5mtmp Hcomp Hincl);apply HT.
}

assert(HAp2p5M : rk(A :: p2 :: p5 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max HAp2p5eq HAp2p5M3).
assert(HAp2p5m : rk(A :: p2 :: p5 ::  nil) >= 1) by (solve_hyps_min HAp2p5eq HAp2p5m1).
intuition.
Qed.

(* dans constructLemma(), requis par LCp1p2p5 *)
(* dans la couche 0 *)
Lemma LACp1p2p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C :: p1 :: p2 :: p5 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACp1p2p5 requis par la preuve de (?)ACp1p2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Cp1p5 requis par la preuve de (?)ACp1p2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Cp1p5 requis par la preuve de (?)Cp1p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: p1 :: p5 ::  de rang :  3 et 3 	 AiB : C :: p1 ::  de rang :  2 et 2 	 A : A :: B :: C :: p1 ::   de rang : 3 et 3 *)
assert(HCp1p5m2 : rk(C :: p1 :: p5 :: nil) >= 2).
{
	assert(HABCp1eq : rk(A :: B :: C :: p1 :: nil) = 3) by (apply LABCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(HABCp1p5eq : rk(A :: B :: C :: p1 :: p5 :: nil) = 3) by (apply LABCp1p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp1p5mtmp : rk(A :: B :: C :: p1 :: p5 :: nil) >= 3) by (solve_hyps_min HABCp1p5eq HABCp1p5m3).
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1mtmp : rk(C :: p1 :: nil) >= 2) by (solve_hyps_min HCp1eq HCp1m2).
	assert(Hincl : incl (C :: p1 :: nil) (list_inter (A :: B :: C :: p1 :: nil) (C :: p1 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: p5 :: nil) (A :: B :: C :: p1 :: C :: p1 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p1 :: C :: p1 :: p5 :: nil) ((A :: B :: C :: p1 :: nil) ++ (C :: p1 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp1p5mtmp;try rewrite HT2 in HABCp1p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: p1 :: nil) (C :: p1 :: p5 :: nil) (C :: p1 :: nil) 3 2 3 HABCp1p5mtmp HCp1mtmp HABCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACp1p2p5 requis par la preuve de (?)ACp1p2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACp1p2p5 requis par la preuve de (?)ACp1p2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACp1p2p5 requis par la preuve de (?)ACp1p2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACp1p2p5m2 : rk(A :: C :: p1 :: p2 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: C :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: C :: p1 :: p2 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACp1p2p5m3 : rk(A :: C :: p1 :: p2 :: p5 :: nil) >= 3).
{
	assert(HACp1eq : rk(A :: C :: p1 :: nil) = 3) by (apply LACp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1mtmp : rk(A :: C :: p1 :: nil) >= 3) by (solve_hyps_min HACp1eq HACp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: p1 :: nil) (A :: C :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: p1 :: nil) (A :: C :: p1 :: p2 :: p5 :: nil) 3 3 HACp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HACp1p2p5M4 : rk(A :: C :: p1 :: p2 :: p5 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HCp1p5Mtmp : rk(C :: p1 :: p5 :: nil) <= 3) by (solve_hyps_max HCp1p5eq HCp1p5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (C :: p1 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: p1 :: p2 :: p5 :: nil) (A :: p2 :: C :: p1 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: C :: p1 :: p5 :: nil) ((A :: p2 :: nil) ++ (C :: p1 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (C :: p1 :: p5 :: nil) (nil) 1 3 0 HAp2Mtmp HCp1p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACp1p2p5M3 : rk(A :: C :: p1 :: p2 :: p5 :: nil) <= 3).
{
	assert(HACp1p5eq : rk(A :: C :: p1 :: p5 :: nil) = 3) by (apply LACp1p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1p5Mtmp : rk(A :: C :: p1 :: p5 :: nil) <= 3) by (solve_hyps_max HACp1p5eq HACp1p5M3).
	assert(HAp2p5eq : rk(A :: p2 :: p5 :: nil) = 2) by (apply LAp2p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAp2p5Mtmp : rk(A :: p2 :: p5 :: nil) <= 2) by (solve_hyps_max HAp2p5eq HAp2p5M2).
	assert(HAp5eq : rk(A :: p5 :: nil) = 2) by (apply LAp5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAp5mtmp : rk(A :: p5 :: nil) >= 2) by (solve_hyps_min HAp5eq HAp5m2).
	assert(Hincl : incl (A :: p5 :: nil) (list_inter (A :: C :: p1 :: p5 :: nil) (A :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: p1 :: p2 :: p5 :: nil) (A :: C :: p1 :: p5 :: A :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: p1 :: p5 :: A :: p2 :: p5 :: nil) ((A :: C :: p1 :: p5 :: nil) ++ (A :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: p1 :: p5 :: nil) (A :: p2 :: p5 :: nil) (A :: p5 :: nil) 3 2 2 HACp1p5Mtmp HAp2p5Mtmp HAp5mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HACp1p2p5M : rk(A :: C :: p1 :: p2 :: p5 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HACp1p2p5eq HACp1p2p5M5).
assert(HACp1p2p5m : rk(A :: C :: p1 :: p2 :: p5 ::  nil) >= 1) by (solve_hyps_min HACp1p2p5eq HACp1p2p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCp1p2p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(C :: p1 :: p2 :: p5 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Cp1p2p5 requis par la preuve de (?)Cp1p2p5 pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACp1p2p5 requis par la preuve de (?)Cp1p2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Cp1p5 requis par la preuve de (?)ACp1p2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Cp1p5 requis par la preuve de (?)Cp1p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: p1 :: p5 ::  de rang :  3 et 3 	 AiB : C :: p1 ::  de rang :  2 et 2 	 A : A :: B :: C :: p1 ::   de rang : 3 et 3 *)
assert(HCp1p5m2 : rk(C :: p1 :: p5 :: nil) >= 2).
{
	assert(HABCp1eq : rk(A :: B :: C :: p1 :: nil) = 3) by (apply LABCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(HABCp1p5eq : rk(A :: B :: C :: p1 :: p5 :: nil) = 3) by (apply LABCp1p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp1p5mtmp : rk(A :: B :: C :: p1 :: p5 :: nil) >= 3) by (solve_hyps_min HABCp1p5eq HABCp1p5m3).
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1mtmp : rk(C :: p1 :: nil) >= 2) by (solve_hyps_min HCp1eq HCp1m2).
	assert(Hincl : incl (C :: p1 :: nil) (list_inter (A :: B :: C :: p1 :: nil) (C :: p1 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: p5 :: nil) (A :: B :: C :: p1 :: C :: p1 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p1 :: C :: p1 :: p5 :: nil) ((A :: B :: C :: p1 :: nil) ++ (C :: p1 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp1p5mtmp;try rewrite HT2 in HABCp1p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: p1 :: nil) (C :: p1 :: p5 :: nil) (C :: p1 :: nil) 3 2 3 HABCp1p5mtmp HCp1mtmp HABCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACp1p2p5 requis par la preuve de (?)ACp1p2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACp1p2p5 requis par la preuve de (?)ACp1p2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACp1p2p5 requis par la preuve de (?)ACp1p2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACp1p2p5m2 : rk(A :: C :: p1 :: p2 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: C :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: C :: p1 :: p2 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACp1p2p5m3 : rk(A :: C :: p1 :: p2 :: p5 :: nil) >= 3).
{
	assert(HACp1eq : rk(A :: C :: p1 :: nil) = 3) by (apply LACp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1mtmp : rk(A :: C :: p1 :: nil) >= 3) by (solve_hyps_min HACp1eq HACp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: p1 :: nil) (A :: C :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: p1 :: nil) (A :: C :: p1 :: p2 :: p5 :: nil) 3 3 HACp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HACp1p2p5M4 : rk(A :: C :: p1 :: p2 :: p5 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HCp1p5Mtmp : rk(C :: p1 :: p5 :: nil) <= 3) by (solve_hyps_max HCp1p5eq HCp1p5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (C :: p1 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: p1 :: p2 :: p5 :: nil) (A :: p2 :: C :: p1 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: C :: p1 :: p5 :: nil) ((A :: p2 :: nil) ++ (C :: p1 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (C :: p1 :: p5 :: nil) (nil) 1 3 0 HAp2Mtmp HCp1p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Cp1p2p5 requis par la preuve de (?)Cp1p2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCp1p2p5 requis par la preuve de (?)Cp1p2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCp1p2p5 requis par la preuve de (?)ABCp1p2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Cp2p5 requis par la preuve de (?)ABCp1p2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCp1p2p5 requis par la preuve de (?)ABCp1p2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCECpp1p2p5 requis par la preuve de (?)ABCp1p2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2p5 requis par la preuve de (?)ABCECpp1p2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2p5 requis par la preuve de (?)ABCDECpp1p2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp1p2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCECpp1p2p5 requis par la preuve de (?)ABCECpp1p2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCECpp1p2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCDECpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDECpm2 : rk(A :: C :: D :: E :: Cp :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDECpm4 : rk(A :: C :: D :: E :: Cp :: nil) >= 4).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (B :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: Cp :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HBCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCCpm2 : rk(A :: B :: C :: Cp :: nil) >= 2).
{
	assert(HACDECpMtmp : rk(A :: C :: D :: E :: Cp :: nil) <= 5) by (solve_hyps_max HACDECpeq HACDECpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HACDECpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCCpm3 : rk(A :: B :: C :: Cp :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDECpp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1p2p5 requis par la preuve de (?)ABCECpp1p2p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1p2p5 requis par la preuve de (?)ABCECpp1p2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1p2p5 requis par la preuve de (?)ABCDEApBpCpp1p2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1p2p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp1p2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1p2p5 requis par la preuve de (?)ABCECpp1p2p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1p2p5m2 : rk(A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1p2p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1p2p5eq HABCDEApBpCpp1p2p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1p2p5mtmp;try rewrite HT2 in HABCDEApBpCpp1p2p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1p2p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCECpp1p2p5m3 : rk(A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil) >= 3).
{
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 3) by (solve_hyps_min HABCCpeq HABCCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil) 3 3 HABCCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p5 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1p2p5m4 : rk(A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1p2p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p5eq HABCDECpp1p2p5m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p5mtmp;try rewrite HT2 in HABCDECpp1p2p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1p2p5mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABCp1p2p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCp1p2p5 requis par la preuve de (?)ABCp1p2p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 ::  de rang :  4 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABCp1p2p5m2 : rk(A :: B :: C :: p1 :: p2 :: p5 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCECpp1p2p5mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil) >= 4) by (solve_hyps_min HABCECpp1p2p5eq HABCECpp1p2p5m4).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: C :: p1 :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: p2 :: p5 :: nil) (A :: C :: E :: Cp :: A :: B :: C :: p1 :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: C :: p1 :: p2 :: p5 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: C :: p1 :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1p2p5mtmp;try rewrite HT2 in HABCECpp1p2p5mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: C :: p1 :: p2 :: p5 :: nil) (A :: C :: nil) 4 2 4 HABCECpp1p2p5mtmp HACmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HABCp1p2p5M5 : rk(A :: B :: C :: p1 :: p2 :: p5 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HCp2p5Mtmp : rk(C :: p2 :: p5 :: nil) <= 3) by (solve_hyps_max HCp2p5eq HCp2p5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: p1 :: nil) (C :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: p2 :: p5 :: nil) (A :: B :: p1 :: C :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: C :: p2 :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (C :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (C :: p2 :: p5 :: nil) (nil) 2 3 0 HABp1Mtmp HCp2p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp1p2p5m3 : rk(A :: B :: C :: p1 :: p2 :: p5 :: nil) >= 3).
{
	assert(HACp1eq : rk(A :: C :: p1 :: nil) = 3) by (apply LACp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1mtmp : rk(A :: C :: p1 :: nil) >= 3) by (solve_hyps_min HACp1eq HACp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: p1 :: nil) (A :: B :: C :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: p1 :: nil) (A :: B :: C :: p1 :: p2 :: p5 :: nil) 3 3 HACp1mtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Cp1p2p5 requis par la preuve de (?)Cp1p2p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: p1 :: p2 :: p5 ::  de rang :  3 et 5 	 AiB : C :: p1 ::  de rang :  2 et 2 	 A : A :: B :: C :: p1 ::   de rang : 3 et 3 *)
assert(HCp1p2p5m2 : rk(C :: p1 :: p2 :: p5 :: nil) >= 2).
{
	assert(HABCp1eq : rk(A :: B :: C :: p1 :: nil) = 3) by (apply LABCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(HABCp1p2p5mtmp : rk(A :: B :: C :: p1 :: p2 :: p5 :: nil) >= 3) by (solve_hyps_min HABCp1p2p5eq HABCp1p2p5m3).
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1mtmp : rk(C :: p1 :: nil) >= 2) by (solve_hyps_min HCp1eq HCp1m2).
	assert(Hincl : incl (C :: p1 :: nil) (list_inter (A :: B :: C :: p1 :: nil) (C :: p1 :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: p2 :: p5 :: nil) (A :: B :: C :: p1 :: C :: p1 :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p1 :: C :: p1 :: p2 :: p5 :: nil) ((A :: B :: C :: p1 :: nil) ++ (C :: p1 :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp1p2p5mtmp;try rewrite HT2 in HABCp1p2p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: p1 :: nil) (C :: p1 :: p2 :: p5 :: nil) (C :: p1 :: nil) 3 2 3 HABCp1p2p5mtmp HCp1mtmp HABCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: p1 :: p2 :: p5 ::  de rang :  3 et 4 	 AiB : p2 ::  de rang :  1 et 1 	 A : A :: p2 ::   de rang : 1 et 1 *)
assert(HCp1p2p5m3 : rk(C :: p1 :: p2 :: p5 :: nil) >= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HACp1p2p5mtmp : rk(A :: C :: p1 :: p2 :: p5 :: nil) >= 3) by (solve_hyps_min HACp1p2p5eq HACp1p2p5m3).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (A :: p2 :: nil) (C :: p1 :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: p1 :: p2 :: p5 :: nil) (A :: p2 :: C :: p1 :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: C :: p1 :: p2 :: p5 :: nil) ((A :: p2 :: nil) ++ (C :: p1 :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACp1p2p5mtmp;try rewrite HT2 in HACp1p2p5mtmp.
	assert(HT := rule_4 (A :: p2 :: nil) (C :: p1 :: p2 :: p5 :: nil) (p2 :: nil) 3 1 1 HACp1p2p5mtmp Hp2mtmp HAp2Mtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCp1p2p5M3 : rk(C :: p1 :: p2 :: p5 :: nil) <= 3).
{
	assert(HACp1p2p5eq : rk(A :: C :: p1 :: p2 :: p5 :: nil) = 3) by (apply LACp1p2p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1p2p5Mtmp : rk(A :: C :: p1 :: p2 :: p5 :: nil) <= 3) by (solve_hyps_max HACp1p2p5eq HACp1p2p5M3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: p1 :: p2 :: p5 :: nil) (A :: C :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: p1 :: p2 :: p5 :: nil) (A :: C :: p1 :: p2 :: p5 :: nil) 3 3 HACp1p2p5Mtmp Hcomp Hincl);apply HT.
}

assert(HCp1p2p5M : rk(C :: p1 :: p2 :: p5 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HCp1p2p5eq HCp1p2p5M4).
assert(HCp1p2p5m : rk(C :: p1 :: p2 :: p5 ::  nil) >= 1) by (solve_hyps_min HCp1p2p5eq HCp1p2p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpCpDpEpp1p2p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ApBpCpDpEpp1p2p5 requis par la preuve de (?)ApBpCpDpEpp1p2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ApBpCpDpEpp1p2p5 requis par la preuve de (?)ApBpCpDpEpp1p2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HApBpCpDpEpp1p2p5m5 : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -4*)
assert(HApBpCpDpEpp1p2p5M5 : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil) <= 5).
{
	assert(HApBpCpDpEpp2Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp2eq HApBpCpDpEpp2M5).
	assert(HApBpCpDpEpp1p5eq : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil) = 5) by (apply LApBpCpDpEpp1p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HApBpCpDpEpp1p5Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp1p5eq HApBpCpDpEpp1p5M5).
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (list_inter (Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil) ((Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) ++ (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: Cp :: Dp :: Ep :: p2 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 5 HApBpCpDpEpp2Mtmp HApBpCpDpEpp1p5Mtmp HApBpCpDpEpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApBpCpDpEpp1p2p5M : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HApBpCpDpEpp1p2p5m : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 ::  nil) >= 1) by (solve_hyps_min HApBpCpDpEpp1p2p5eq HApBpCpDpEpp1p2p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCp3p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(B :: C :: p3 :: p5 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCp3p5 requis par la preuve de (?)BCp3p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCp3p5 requis par la preuve de (?)BCp3p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEp1p3p5 requis par la preuve de (?)BCp3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p3p5 requis par la preuve de (?)ABCEp1p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p3p5 requis par la preuve de (?)ABCDEp1p3p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p3p5m5 : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp1p3p5 requis par la preuve de (?)ABCEp1p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p3p5 requis par la preuve de (?)ABCEp1p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p3p5 requis par la preuve de (?)ABCDECpp1p3p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p3p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCEp1p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp1p3p5 requis par la preuve de (?)ABCEp1p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p3p5 requis par la preuve de (?)ABCEp1p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p3p5 requis par la preuve de (?)ABCDEApBpp1p3p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p3p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCEp1p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp1p3p5 requis par la preuve de (?)ABCEp1p3p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp1p3p5m2 : rk(A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp1p3p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p3p5eq HABCDEApBpp1p3p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p1 :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p3p5mtmp;try rewrite HT2 in HABCDEApBpp1p3p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p3p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp1p3p5m3 : rk(A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1p3p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p3p5eq HABCDECpp1p3p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: p1 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p1 :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p3p5mtmp;try rewrite HT2 in HABCDECpp1p3p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) (nil) 5 0 2 HABCDECpp1p3p5mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 :: p5 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HABCEp1p3p5m4 : rk(A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) >= 4).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HABCDEp1p3p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3p5eq HABCDEp1p3p5m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: p5 :: nil) (D :: p1 :: A :: B :: C :: E :: p1 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) ((D :: p1 :: nil) ++ (A :: B :: C :: E :: p1 :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3p5mtmp;try rewrite HT2 in HABCDEp1p3p5mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p3p5mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCp3p5 requis par la preuve de (?)BCp3p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: E :: p1 :: p3 :: p5 ::  de rang :  4 et 6 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: E :: p1 ::   de rang : 3 et 3 *)
assert(HBCp3p5m2 : rk(B :: C :: p3 :: p5 :: nil) >= 2).
{
	assert(HABEp1eq : rk(A :: B :: E :: p1 :: nil) = 3) by (apply LABEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCEp1p3p5mtmp : rk(A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) >= 4) by (solve_hyps_min HABCEp1p3p5eq HABCEp1p3p5m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: E :: p1 :: nil) (B :: C :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p3 :: p5 :: nil) (A :: B :: E :: p1 :: B :: C :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: p1 :: B :: C :: p3 :: p5 :: nil) ((A :: B :: E :: p1 :: nil) ++ (B :: C :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEp1p3p5mtmp;try rewrite HT2 in HABCEp1p3p5mtmp.
	assert(HT := rule_4 (A :: B :: E :: p1 :: nil) (B :: C :: p3 :: p5 :: nil) (B :: nil) 4 1 3 HABCEp1p3p5mtmp HBmtmp HABEp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCp3p5M3 : rk(B :: C :: p3 :: p5 :: nil) <= 3).
{
	assert(Hp3Mtmp : rk(p3 :: nil) <= 1) by (solve_hyps_max Hp3eq Hp3M1).
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p3 :: nil) (B :: C :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: p3 :: p5 :: nil) (p3 :: B :: C :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p3 :: B :: C :: p5 :: nil) ((p3 :: nil) ++ (B :: C :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p3 :: nil) (B :: C :: p5 :: nil) (nil) 1 2 0 Hp3Mtmp HBCp5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCp3p5m3 : rk(B :: C :: p3 :: p5 :: nil) >= 3).
{
	assert(HBCp3eq : rk(B :: C :: p3 :: nil) = 3) by (apply LBCp3 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HBCp3mtmp : rk(B :: C :: p3 :: nil) >= 3) by (solve_hyps_min HBCp3eq HBCp3m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: p3 :: nil) (B :: C :: p3 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: p3 :: nil) (B :: C :: p3 :: p5 :: nil) 3 3 HBCp3mtmp Hcomp Hincl);apply HT.
}

assert(HBCp3p5M : rk(B :: C :: p3 :: p5 ::  nil) <= 4) (* dim : 5 *) by (solve_hyps_max HBCp3p5eq HBCp3p5M4).
assert(HBCp3p5m : rk(B :: C :: p3 :: p5 ::  nil) >= 1) by (solve_hyps_min HBCp3p5eq HBCp3p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpCpDpEpp1p2p3p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ApBpCpDpEpp1p2p3p5 requis par la preuve de (?)ApBpCpDpEpp1p2p3p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ApBpCpDpEpp1p2p3p5 requis par la preuve de (?)ApBpCpDpEpp1p2p3p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HApBpCpDpEpp1p2p3p5m5 : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -4*)
assert(HApBpCpDpEpp1p2p3p5M5 : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil) <= 5).
{
	assert(HApBpCpDpEpp3Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp3eq HApBpCpDpEpp3M5).
	assert(HApBpCpDpEpp1p2p5eq : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil) = 5) by (apply LApBpCpDpEpp1p2p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HApBpCpDpEpp1p2p5Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp1p2p5eq HApBpCpDpEpp1p2p5M5).
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (list_inter (Ap :: Bp :: Cp :: Dp :: Ep :: p3 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p3 :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: Dp :: Ep :: p3 :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil) ((Ap :: Bp :: Cp :: Dp :: Ep :: p3 :: nil) ++ (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: Cp :: Dp :: Ep :: p3 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 5 HApBpCpDpEpp3Mtmp HApBpCpDpEpp1p2p5Mtmp HApBpCpDpEpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApBpCpDpEpp1p2p3p5M : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HApBpCpDpEpp1p2p3p5m : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 ::  nil) >= 1) by (solve_hyps_min HApBpCpDpEpp1p2p3p5eq HApBpCpDpEpp1p2p3p5m1).
intuition.
Qed.

(* dans constructLemma(), requis par Lp3p4p5 *)
(* dans constructLemma(), requis par LBCp3p4p5 *)
(* dans la couche 0 *)
Lemma LABCEp3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: E :: p3 :: p4 :: p5 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEp3p4p5 requis par la preuve de (?)ABCEp3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp3p4p5 requis par la preuve de (?)ABCEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp3p4p5 requis par la preuve de (?)ABCDEp3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp3p4p5m5 : rk(A :: B :: C :: D :: E :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEp3p4p5 requis par la preuve de (?)ABCEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp2p3p4p5 requis par la preuve de (?)ABCEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp2p3p4p5 requis par la preuve de (?)ABCDEp2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp2p3p4p5m5 : rk(A :: B :: C :: D :: E :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp3p4p5 requis par la preuve de (?)ABCEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp3p4p5 requis par la preuve de (?)ABCEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp3p4p5 requis par la preuve de (?)ABCDECpp3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp3p4p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp3p4p5 requis par la preuve de (?)ABCEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp3p4p5 requis par la preuve de (?)ABCEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp3p4p5 requis par la preuve de (?)ABCDEApBpp3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp3p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp3p4p5 requis par la preuve de (?)ABCEp3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp3p4p5m2 : rk(A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp3p4p5eq HABCDEApBpp3p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p3 :: p4 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp3p4p5mtmp;try rewrite HT2 in HABCDEApBpp3p4p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp3p4p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp3p4p5m3 : rk(A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp3p4p5eq HABCDECpp3p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp3p4p5mtmp;try rewrite HT2 in HABCDECpp3p4p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) (nil) 5 0 2 HABCDECpp3p4p5mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: D :: p2 ::   de rang : 2 et 2 *)
assert(HABCEp3p4p5m4 : rk(A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HADp2eq : rk(A :: D :: p2 :: nil) = 2) by (apply LADp2 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(HABCDEp2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp2p3p4p5eq HABCDEp2p3p4p5m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p2 :: nil) (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p2 :: p3 :: p4 :: p5 :: nil) (A :: D :: p2 :: A :: B :: C :: E :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p2 :: A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) ((A :: D :: p2 :: nil) ++ (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp2p3p4p5mtmp;try rewrite HT2 in HABCDEp2p3p4p5mtmp.
	assert(HT := rule_4 (A :: D :: p2 :: nil) (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) (A :: nil) 5 1 2 HABCDEp2p3p4p5mtmp HAmtmp HADp2Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HABCEp3p4p5m5 : rk(A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HABCDEp3p4p5mtmp : rk(A :: B :: C :: D :: E :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp3p4p5eq HABCDEp3p4p5m5).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p3 :: p4 :: p5 :: nil) (A :: D :: p3 :: A :: B :: C :: E :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp3p4p5mtmp;try rewrite HT2 in HABCDEp3p4p5mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) (A :: p3 :: nil) 5 2 2 HABCDEp3p4p5mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 5*)
assert(HABCEp3p4p5M5 : rk(A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) <= 5).
{
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HBCp3p5eq : rk(B :: C :: p3 :: p5 :: nil) = 3) by (apply LBCp3p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HBCp3p5Mtmp : rk(B :: C :: p3 :: p5 :: nil) <= 3) by (solve_hyps_max HBCp3p5eq HBCp3p5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: E :: p4 :: nil) (B :: C :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) (A :: E :: p4 :: B :: C :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p4 :: B :: C :: p3 :: p5 :: nil) ((A :: E :: p4 :: nil) ++ (B :: C :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: E :: p4 :: nil) (B :: C :: p3 :: p5 :: nil) (nil) 2 3 0 HAEp4Mtmp HBCp3p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCEp3p4p5M : rk(A :: B :: C :: E :: p3 :: p4 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCEp3p4p5m : rk(A :: B :: C :: E :: p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min HABCEp3p4p5eq HABCEp3p4p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCp3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(B :: C :: p3 :: p4 :: p5 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCp3p4p5 requis par la preuve de (?)BCp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour BCp3p4p5 requis par la preuve de (?)BCp3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour BCp3p4p5 requis par la preuve de (?)BCp3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEp1p3p4p5 requis par la preuve de (?)BCp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p3p4p5 requis par la preuve de (?)ABCEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p3p4p5 requis par la preuve de (?)ABCDEp1p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p3p4p5m5 : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp1p3p4p5 requis par la preuve de (?)ABCEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p3p4p5 requis par la preuve de (?)ABCEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p3p4p5 requis par la preuve de (?)ABCDECpp1p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p3p4p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp1p3p4p5 requis par la preuve de (?)ABCEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p3p4p5 requis par la preuve de (?)ABCEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p3p4p5 requis par la preuve de (?)ABCDEApBpp1p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p3p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp1p3p4p5 requis par la preuve de (?)ABCEp1p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp1p3p4p5m2 : rk(A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp1p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p3p4p5eq HABCDEApBpp1p3p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p3p4p5mtmp;try rewrite HT2 in HABCDEApBpp1p3p4p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p3p4p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp1p3p4p5m3 : rk(A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p3p4p5eq HABCDECpp1p3p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p3p4p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) (nil) 5 0 2 HABCDECpp1p3p4p5mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HABCEp1p3p4p5m4 : rk(A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HABCDEp1p3p4p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3p4p5eq HABCDEp1p3p4p5m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (D :: p1 :: A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((D :: p1 :: nil) ++ (A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3p4p5mtmp;try rewrite HT2 in HABCDEp1p3p4p5mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p3p4p5mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour BCp3p4p5 requis par la preuve de (?)BCp3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 ::  de rang :  4 et 6 	 AiB : B ::  de rang :  1 et 1 	 A : A :: B :: E :: p1 ::   de rang : 3 et 3 *)
assert(HBCp3p4p5m2 : rk(B :: C :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HABEp1eq : rk(A :: B :: E :: p1 :: nil) = 3) by (apply LABEp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCEp1p3p4p5mtmp : rk(A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HABCEp1p3p4p5eq HABCEp1p3p4p5m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: E :: p1 :: nil) (B :: C :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p3 :: p4 :: p5 :: nil) (A :: B :: E :: p1 :: B :: C :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: p1 :: B :: C :: p3 :: p4 :: p5 :: nil) ((A :: B :: E :: p1 :: nil) ++ (B :: C :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEp1p3p4p5mtmp;try rewrite HT2 in HABCEp1p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: E :: p1 :: nil) (B :: C :: p3 :: p4 :: p5 :: nil) (B :: nil) 4 1 3 HABCEp1p3p4p5mtmp HBmtmp HABEp1Mtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCp3p4p5m3 : rk(B :: C :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HBCp3eq : rk(B :: C :: p3 :: nil) = 3) by (apply LBCp3 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HBCp3mtmp : rk(B :: C :: p3 :: nil) >= 3) by (solve_hyps_min HBCp3eq HBCp3m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: p3 :: nil) (B :: C :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: p3 :: nil) (B :: C :: p3 :: p4 :: p5 :: nil) 3 3 HBCp3mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 4 et 5*)
assert(HBCp3p4p5M4 : rk(B :: C :: p3 :: p4 :: p5 :: nil) <= 4).
{
	assert(Hp4Mtmp : rk(p4 :: nil) <= 1) by (solve_hyps_max Hp4eq Hp4M1).
	assert(HBCp3p5eq : rk(B :: C :: p3 :: p5 :: nil) = 3) by (apply LBCp3p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HBCp3p5Mtmp : rk(B :: C :: p3 :: p5 :: nil) <= 3) by (solve_hyps_max HBCp3p5eq HBCp3p5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (p4 :: nil) (B :: C :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: p3 :: p4 :: p5 :: nil) (p4 :: B :: C :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (p4 :: B :: C :: p3 :: p5 :: nil) ((p4 :: nil) ++ (B :: C :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (p4 :: nil) (B :: C :: p3 :: p5 :: nil) (nil) 1 3 0 Hp4Mtmp HBCp3p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: E :: p3 :: p4 :: p5 ::  de rang :  5 et 5 	 AiB : p4 ::  de rang :  1 et 1 	 A : A :: E :: p4 ::   de rang : 2 et 2 *)
assert(HBCp3p4p5m4 : rk(B :: C :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HABCEp3p4p5eq : rk(A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) = 5) by (apply LABCEp3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCEp3p4p5mtmp : rk(A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCEp3p4p5eq HABCEp3p4p5m5).
	assert(Hp4mtmp : rk(p4 :: nil) >= 1) by (solve_hyps_min Hp4eq Hp4m1).
	assert(Hincl : incl (p4 :: nil) (list_inter (A :: E :: p4 :: nil) (B :: C :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p3 :: p4 :: p5 :: nil) (A :: E :: p4 :: B :: C :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p4 :: B :: C :: p3 :: p4 :: p5 :: nil) ((A :: E :: p4 :: nil) ++ (B :: C :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEp3p4p5mtmp;try rewrite HT2 in HABCEp3p4p5mtmp.
	assert(HT := rule_4 (A :: E :: p4 :: nil) (B :: C :: p3 :: p4 :: p5 :: nil) (p4 :: nil) 5 1 2 HABCEp3p4p5mtmp Hp4mtmp HAEp4Mtmp Hincl); apply HT.
}

assert(HBCp3p4p5M : rk(B :: C :: p3 :: p4 :: p5 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max HBCp3p4p5eq HBCp3p4p5M5).
assert(HBCp3p4p5m : rk(B :: C :: p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min HBCp3p4p5eq HBCp3p4p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lp3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(p3 :: p4 :: p5 ::  nil) = 3.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour p3p4p5 requis par la preuve de (?)p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AEp3p4p5 requis par la preuve de (?)p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour p3p5 requis par la preuve de (?)AEp3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour AEp3p4p5 requis par la preuve de (?)AEp3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADEp3p4p5 requis par la preuve de (?)AEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Ep4p5 requis par la preuve de (?)ADEp3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp3p4p5 requis par la preuve de (?)ADEp3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p3p4p5 requis par la preuve de (?)ADEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p3p4p5 requis par la preuve de (?)ACDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p3p4p5 requis par la preuve de (?)ABCDEp1p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p3p4p5m5 : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p3p4p5 requis par la preuve de (?)ACDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)ACDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p3p4p5 requis par la preuve de (?)ACDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p3p4p5 requis par la preuve de (?)ACDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p3p4p5 requis par la preuve de (?)ABCDECpp1p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p3p4p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p3p4p5 requis par la preuve de (?)ACDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p3p4p5 requis par la preuve de (?)ACDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p3p4p5 requis par la preuve de (?)ABCDEApBpp1p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p3p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p3p4p5 requis par la preuve de (?)ACDEp1p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p3p4p5m2 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p3p4p5eq HABCDEApBpp1p3p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p3 :: p4 :: p5 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p3p4p5mtmp;try rewrite HT2 in HABCDEApBpp1p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p3p4p5mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p3p4p5m3 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p3p4p5eq HABCDECpp1p3p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p3p4p5mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (nil) 5 0 2 HABCDECpp1p3p4p5mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p3p4p5m4 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p3p4p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3p4p5eq HABCDEp1p3p4p5m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3p4p5mtmp;try rewrite HT2 in HABCDEp1p3p4p5mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p3p4p5mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p3p4p5m5 : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p3p4p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p3p4p5eq HABCDEp1p3p4p5m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p3p4p5mtmp;try rewrite HT2 in HABCDEp1p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p3p4p5mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp3p4p5 requis par la preuve de (?)ADEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp3p4p5 requis par la preuve de (?)ADEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp3p4p5 requis par la preuve de (?)ABCDECpp3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp3p4p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCECp requis par la preuve de (?)ADEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCCp requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCCpm2 : rk(B :: C :: Cp :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_2 (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDECpp1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : B :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HBCECpm2 : rk(B :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HBCCpmtmp : rk(B :: C :: Cp :: nil) >= 2) by (solve_hyps_min HBCCpeq HBCCpm2).
	assert(Hincl : incl (B :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (B :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil) (B :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HBCCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCECpm3 : rk(B :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (B :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: B :: p1 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCECpp1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp3p4p5 requis par la preuve de (?)ADEp3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HADEp3p4p5m2 : rk(A :: D :: E :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HBCECpMtmp : rk(B :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBCECpeq HBCECpM4).
	assert(HABCDECpp3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp3p4p5eq HABCDECpp3p4p5m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: D :: E :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p3 :: p4 :: p5 :: nil) (B :: C :: E :: Cp :: A :: D :: E :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: D :: E :: p3 :: p4 :: p5 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: D :: E :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp3p4p5mtmp;try rewrite HT2 in HABCDECpp3p4p5mtmp.
	assert(HT := rule_4 (B :: C :: E :: Cp :: nil) (A :: D :: E :: p3 :: p4 :: p5 :: nil) (E :: nil) 5 1 4 HABCDECpp3p4p5mtmp HEmtmp HBCECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp3p4p5m3 : rk(A :: D :: E :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p3p4p5mtmp : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HACDEp1p3p4p5eq HACDEp1p3p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (C :: p1 :: A :: D :: E :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p3 :: p4 :: p5 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p3p4p5mtmp;try rewrite HT2 in HACDEp1p3p4p5mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p3 :: p4 :: p5 :: nil) (nil) 5 0 2 HACDEp1p3p4p5mtmp Hmtmp HCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HADEp3p4p5M5 : rk(A :: D :: E :: p3 :: p4 :: p5 :: nil) <= 5).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HEp4p5Mtmp : rk(E :: p4 :: p5 :: nil) <= 3) by (solve_hyps_max HEp4p5eq HEp4p5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D :: p3 :: nil) (E :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p3 :: p4 :: p5 :: nil) (A :: D :: p3 :: E :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: E :: p4 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (E :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: p3 :: nil) (E :: p4 :: p5 :: nil) (nil) 2 3 0 HADp3Mtmp HEp4p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour AEp3p4p5 requis par la preuve de (?)AEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p3p4p5 requis par la preuve de (?)AEp3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p3p4p5 requis par la preuve de (?)ADEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p3p4p5 requis par la preuve de (?)ADEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEDpp1p3p4p5 requis par la preuve de (?)ABDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEDpp1p3p4p5 requis par la preuve de (?)ABCDEDpp1p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEDpp1p3p4p5m5 : rk(A :: B :: C :: D :: E :: Dp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CDp requis par la preuve de (?)ABDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p3p4p5 requis par la preuve de (?)ABDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABDEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p3p4p5 requis par la preuve de (?)ABDEp1p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABDEp1p3p4p5m2 : rk(A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCDECpp1p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p3p4p5eq HABCDECpp1p3p4p5m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) (A :: C :: E :: Cp :: A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p3p4p5mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (A :: E :: nil) 5 1 4 HABCDECpp1p3p4p5mtmp HAEmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Dp :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Dp ::   de rang : 1 et 2 *)
assert(HABDEp1p3p4p5m3 : rk(A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HCDpMtmp : rk(C :: Dp :: nil) <= 2) by (solve_hyps_max HCDpeq HCDpM2).
	assert(HABCDEDpp1p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Dp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEDpp1p3p4p5eq HABCDEDpp1p3p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Dp :: nil) (A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Dp :: p1 :: p3 :: p4 :: p5 :: nil) (C :: Dp :: A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Dp :: A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((C :: Dp :: nil) ++ (A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEDpp1p3p4p5mtmp;try rewrite HT2 in HABCDEDpp1p3p4p5mtmp.
	assert(HT := rule_4 (C :: Dp :: nil) (A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (nil) 5 0 2 HABCDEDpp1p3p4p5mtmp Hmtmp HCDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p3p4p5 requis par la preuve de (?)ADEp1p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p3p4p5 requis par la preuve de (?)ADEp1p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HADEp1p3p4p5m2 : rk(A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HBCECpMtmp : rk(B :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBCECpeq HBCECpM4).
	assert(HABCDECpp1p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p3p4p5eq HABCDECpp1p3p4p5m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p4 :: p5 :: nil) (B :: C :: E :: Cp :: A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p3p4p5mtmp.
	assert(HT := rule_4 (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (E :: nil) 5 1 4 HABCDECpp1p3p4p5mtmp HEmtmp HBCECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p3p4p5m3 : rk(A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p3p4p5mtmp : rk(A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 3) by (solve_hyps_min HABDEp1p3p4p5eq HABDEp1p3p4p5m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p3p4p5mtmp;try rewrite HT2 in HABDEp1p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p3p4p5mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p3p4p5m4 : rk(A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p3p4p5mtmp : rk(A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HACDEp1p3p4p5eq HACDEp1p3p4p5m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p3p4p5mtmp;try rewrite HT2 in HACDEp1p3p4p5mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (p1 :: nil) 5 1 2 HACDEp1p3p4p5mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour AEp3p4p5 requis par la preuve de (?)AEp3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p3 :: p4 :: p5 ::  de rang :  4 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: D :: p1 ::   de rang : 3 et 3 *)
assert(HAEp3p4p5m2 : rk(A :: E :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADp1Mtmp : rk(A :: D :: p1 :: nil) <= 3) by (solve_hyps_max HADp1eq HADp1M3).
	assert(HADEp1p3p4p5mtmp : rk(A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HADEp1p3p4p5eq HADEp1p3p4p5m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p1 :: nil) (A :: E :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p3 :: p4 :: p5 :: nil) (A :: D :: p1 :: A :: E :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p1 :: A :: E :: p3 :: p4 :: p5 :: nil) ((A :: D :: p1 :: nil) ++ (A :: E :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p3p4p5mtmp;try rewrite HT2 in HADEp1p3p4p5mtmp.
	assert(HT := rule_4 (A :: D :: p1 :: nil) (A :: E :: p3 :: p4 :: p5 :: nil) (A :: nil) 4 1 3 HADEp1p3p4p5mtmp HAmtmp HADp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: D :: E :: p3 :: p4 :: p5 ::  de rang :  3 et 5 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HAEp3p4p5m3 : rk(A :: E :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HADEp3p4p5mtmp : rk(A :: D :: E :: p3 :: p4 :: p5 :: nil) >= 3) by (solve_hyps_min HADEp3p4p5eq HADEp3p4p5m3).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: E :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p3 :: p4 :: p5 :: nil) (A :: D :: p3 :: A :: E :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: E :: p3 :: p4 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (A :: E :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp3p4p5mtmp;try rewrite HT2 in HADEp3p4p5mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: E :: p3 :: p4 :: p5 :: nil) (A :: p3 :: nil) 3 2 2 HADEp3p4p5mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAEp3p4p5M4 : rk(A :: E :: p3 :: p4 :: p5 :: nil) <= 4).
{
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(Hp3p5Mtmp : rk(p3 :: p5 :: nil) <= 2) by (solve_hyps_max Hp3p5eq Hp3p5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: E :: p4 :: nil) (p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p3 :: p4 :: p5 :: nil) (A :: E :: p4 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p4 :: p3 :: p5 :: nil) ((A :: E :: p4 :: nil) ++ (p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: E :: p4 :: nil) (p3 :: p5 :: nil) (nil) 2 2 0 HAEp4Mtmp Hp3p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour p3p4p5 requis par la preuve de (?)p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: E :: p3 :: p4 :: p5 ::  de rang :  3 et 4 	 AiB : p4 ::  de rang :  1 et 1 	 A : A :: E :: p4 ::   de rang : 2 et 2 *)
assert(Hp3p4p5m2 : rk(p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HAEp3p4p5mtmp : rk(A :: E :: p3 :: p4 :: p5 :: nil) >= 3) by (solve_hyps_min HAEp3p4p5eq HAEp3p4p5m3).
	assert(Hp4mtmp : rk(p4 :: nil) >= 1) by (solve_hyps_min Hp4eq Hp4m1).
	assert(Hincl : incl (p4 :: nil) (list_inter (A :: E :: p4 :: nil) (p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p3 :: p4 :: p5 :: nil) (A :: E :: p4 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p4 :: p3 :: p4 :: p5 :: nil) ((A :: E :: p4 :: nil) ++ (p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAEp3p4p5mtmp;try rewrite HT2 in HAEp3p4p5mtmp.
	assert(HT := rule_4 (A :: E :: p4 :: nil) (p3 :: p4 :: p5 :: nil) (p4 :: nil) 3 1 2 HAEp3p4p5mtmp Hp4mtmp HAEp4Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: C :: p3 :: p4 :: p5 ::  de rang :  4 et 4 	 AiB : p5 ::  de rang :  1 et 1 	 A : B :: C :: p5 ::   de rang : 2 et 2 *)
assert(Hp3p4p5m3 : rk(p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HBCp5Mtmp : rk(B :: C :: p5 :: nil) <= 2) by (solve_hyps_max HBCp5eq HBCp5M2).
	assert(HBCp3p4p5eq : rk(B :: C :: p3 :: p4 :: p5 :: nil) = 4) by (apply LBCp3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HBCp3p4p5mtmp : rk(B :: C :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HBCp3p4p5eq HBCp3p4p5m4).
	assert(Hp5mtmp : rk(p5 :: nil) >= 1) by (solve_hyps_min Hp5eq Hp5m1).
	assert(Hincl : incl (p5 :: nil) (list_inter (B :: C :: p5 :: nil) (p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: p3 :: p4 :: p5 :: nil) (B :: C :: p5 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: p5 :: p3 :: p4 :: p5 :: nil) ((B :: C :: p5 :: nil) ++ (p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCp3p4p5mtmp;try rewrite HT2 in HBCp3p4p5mtmp.
	assert(HT := rule_4 (B :: C :: p5 :: nil) (p3 :: p4 :: p5 :: nil) (p5 :: nil) 4 1 2 HBCp3p4p5mtmp Hp5mtmp HBCp5Mtmp Hincl); apply HT.
}

assert(Hp3p4p5M : rk(p3 :: p4 :: p5 ::  nil) <= 3) (* dim : 5 *) by (solve_hyps_max Hp3p4p5eq Hp3p4p5M3).
assert(Hp3p4p5m : rk(p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min Hp3p4p5eq Hp3p4p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCp1p2p3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(C :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour Cp1p2p3p4p5 requis par la preuve de (?)Cp1p2p3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACp1p2p3p4p5 requis par la preuve de (?)Cp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACEp1p2p3p4p5 requis par la preuve de (?)ACp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p3p4p5 requis par la preuve de (?)ACEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p3p4p5 requis par la preuve de (?)ABCDEp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2p3p4p5 requis par la preuve de (?)ABCDECpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p2p3p4p5 requis par la preuve de (?)ABCDEApBpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p2p3p4p5m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2p3p4p5eq HABCDEApBpp1p2p3p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2p3p4p5mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4p5m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4p5eq HABCDECpp1p2p3p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (nil) 5 0 2 HABCDECpp1p2p3p4p5mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4p5m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4p5eq HABCDEp1p2p3p4p5m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p3p4p5mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4p5m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4p5eq HABCDEp1p2p3p4p5m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p3p4p5mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACEp1p2p3p4p5 requis par la preuve de (?)ACEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACEp1p2p3p4p5 requis par la preuve de (?)ACEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEp1p2p3p4p5 requis par la preuve de (?)ACEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEp1p2p3p4p5 requis par la preuve de (?)ABCEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEp1p2p3p4p5 requis par la preuve de (?)ABCEp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCEp1p2p3p4p5m2 : rk(A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2p3p4p5eq HABCDEApBpp1p2p3p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2p3p4p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCEp1p2p3p4p5m3 : rk(A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4p5eq HABCDECpp1p2p3p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (nil) 5 0 2 HABCDECpp1p2p3p4p5mtmp Hmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACEp1p2p3p4p5 requis par la preuve de (?)ACEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ACEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACEp1p2p3p4p5 requis par la preuve de (?)ACEp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACEp1p2p3p4p5m2 : rk(A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4p5eq HABCDECpp1p2p3p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDECpp1p2p3p4p5mtmp HACmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACEp1p2p3p4p5m3 : rk(A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEp1p2p3p4p5mtmp : rk(A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3) by (solve_hyps_min HABCEp1p2p3p4p5eq HABCEp1p2p3p4p5m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: p1 :: A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEp1p2p3p4p5mtmp;try rewrite HT2 in HABCEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p1 :: nil) 3 2 2 HABCEp1p2p3p4p5mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HACEp1p2p3p4p5m4 : rk(A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HACDEp1p2p3p4p5mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p3p4p5eq HACDEp1p2p3p4p5m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (D :: p1 :: A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((D :: p1 :: nil) ++ (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p3p4p5mtmp;try rewrite HT2 in HACDEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2p3p4p5mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HACEp1p2p3p4p5m5 : rk(A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HACDEp1p2p3p4p5mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p3p4p5eq HACDEp1p2p3p4p5m5).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: D :: p3 :: A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p3p4p5mtmp;try rewrite HT2 in HACDEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p3 :: nil) 5 2 2 HACDEp1p2p3p4p5mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACp1p2p3p4p5 requis par la preuve de (?)ACp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDp1p2p3p4p5 requis par la preuve de (?)ACp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDp1p2p3p4p5 requis par la preuve de (?)ACDp1p2p3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCDp1p2p3p4p5 requis par la preuve de (?)ACDp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDp1p2p3p4p5 requis par la preuve de (?)ABCDp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDp1p2p3p4p5 requis par la preuve de (?)ABCDp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDp1p2p3p4p5m2 : rk(A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2p3p4p5eq HABCDEApBpp1p2p3p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2p3p4p5mtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : E :: Cp ::   de rang : 1 et 2 *)
assert(HABCDp1p2p3p4p5m3 : rk(A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4p5eq HABCDECpp1p2p3p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: Cp :: nil) (A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (E :: Cp :: A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Cp :: A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((E :: Cp :: nil) ++ (A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (E :: Cp :: nil) (A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (nil) 5 0 2 HABCDECpp1p2p3p4p5mtmp Hmtmp HECpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDp1p2p3p4p5 requis par la preuve de (?)ACDp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABECp requis par la preuve de (?)ACDp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABECpp2 requis par la preuve de (?)ABECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDECpp2 requis par la preuve de (?)ABECpp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABDECpp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp2 requis par la preuve de (?)ABCDECpp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp2m5 : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)ABDECpp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABDECpp2 requis par la preuve de (?)ABDECpp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp requis par la preuve de (?)ABDECpp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCpm2 : rk(A :: B :: Cp :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Cp :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: Cp :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Cp :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_2 (A :: B :: Cp :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDECpp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDECpp2 requis par la preuve de (?)ABDECpp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp2 requis par la preuve de (?)ABDECpp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp2 requis par la preuve de (?)ABDEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp2 requis par la preuve de (?)ABDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp2 requis par la preuve de (?)ABDp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABp2 requis par la preuve de (?)ABp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABp2M2 : rk(A :: B :: p2 :: nil) <= 2).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: p2 :: nil) (B :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: p2 :: nil) ((B :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: p2 :: nil) (nil) 1 1 0 HBMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp2 requis par la preuve de (?)ABDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDp2M3 : rk(A :: B :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp2Mtmp : rk(A :: B :: p2 :: nil) <= 2) by (solve_hyps_max HABp2eq HABp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p2 :: nil) (D :: A :: B :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p2 :: nil) ((D :: nil) ++ (A :: B :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p2 :: nil) (nil) 1 2 0 HDMtmp HABp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp2 requis par la preuve de (?)ABDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp2M4 : rk(A :: B :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp2Mtmp : rk(A :: B :: D :: p2 :: nil) <= 3) by (solve_hyps_max HABDp2eq HABDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p2 :: nil) (E :: A :: B :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p2 :: nil) ((E :: nil) ++ (A :: B :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HABDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp2m3 : rk(A :: B :: D :: E :: p2 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: B :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDECpp2 requis par la preuve de (?)ABDECpp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDECpp2M5 : rk(A :: B :: D :: E :: Cp :: p2 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABDEp2Mtmp : rk(A :: B :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABDEp2eq HABDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Cp :: p2 :: nil) (Cp :: A :: B :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: D :: E :: p2 :: nil) ((Cp :: nil) ++ (A :: B :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: D :: E :: p2 :: nil) (nil) 1 4 0 HCpMtmp HABDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABDECpp2m2 : rk(A :: B :: D :: E :: Cp :: p2 :: nil) >= 2).
{
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 2) by (solve_hyps_min HABCpeq HABCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (A :: B :: D :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (A :: B :: D :: E :: Cp :: p2 :: nil) 2 2 HABCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p2 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : C :: Cp ::   de rang : 1 et 2 *)
assert(HABDECpp2m4 : rk(A :: B :: D :: E :: Cp :: p2 :: nil) >= 4).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (C :: Cp :: nil) (A :: B :: D :: E :: Cp :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (C :: Cp :: A :: B :: D :: E :: Cp :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: A :: B :: D :: E :: Cp :: p2 :: nil) ((C :: Cp :: nil) ++ (A :: B :: D :: E :: Cp :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_4 (C :: Cp :: nil) (A :: B :: D :: E :: Cp :: p2 :: nil) (Cp :: nil) 5 1 2 HABCDECpp2mtmp HCpmtmp HCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABECpp2 requis par la preuve de (?)ABECpp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABECpp2 requis par la preuve de (?)ABECpp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp2 requis par la preuve de (?)ABECpp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp2 requis par la preuve de (?)ABEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABDEApp2 requis par la preuve de (?)ABDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp2 requis par la preuve de (?)ABDEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp2 requis par la preuve de (?)ABDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp2M5 : rk(A :: B :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp2Mtmp : rk(A :: B :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABDEp2eq HABDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABDEApp2m2 : rk(A :: B :: D :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: D :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp2m4 : rk(A :: B :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp2 requis par la preuve de (?)ABEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp2 requis par la preuve de (?)ABEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABEp2M3 : rk(A :: B :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp2Mtmp : rk(A :: B :: p2 :: nil) <= 2) by (solve_hyps_max HABp2eq HABp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p2 :: nil) (E :: A :: B :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p2 :: nil) ((E :: nil) ++ (A :: B :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p2 :: nil) (nil) 1 2 0 HEMtmp HABp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp2m2 : rk(A :: B :: E :: p2 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp2mtmp : rk(A :: B :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABDEApp2eq HABDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp2mtmp;try rewrite HT2 in HABDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p2 :: nil) (nil) 4 0 2 HABDEApp2mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABECpp2 requis par la preuve de (?)ABECpp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABECpp2M4 : rk(A :: B :: E :: Cp :: p2 :: nil) <= 4).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABEp2Mtmp : rk(A :: B :: E :: p2 :: nil) <= 3) by (solve_hyps_max HABEp2eq HABEp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: Cp :: p2 :: nil) (Cp :: A :: B :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: E :: p2 :: nil) ((Cp :: nil) ++ (A :: B :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: E :: p2 :: nil) (nil) 1 3 0 HCpMtmp HABEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABECpp2m2 : rk(A :: B :: E :: Cp :: p2 :: nil) >= 2).
{
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 2) by (solve_hyps_min HABCpeq HABCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (A :: B :: E :: Cp :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (A :: B :: E :: Cp :: p2 :: nil) 2 2 HABCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Cp :: p2 ::  de rang :  4 et 5 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABECpp2m3 : rk(A :: B :: E :: Cp :: p2 :: nil) >= 3).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABDECpp2mtmp : rk(A :: B :: D :: E :: Cp :: p2 :: nil) >= 4) by (solve_hyps_min HABDECpp2eq HABDECpp2m4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: E :: Cp :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Cp :: p2 :: nil) (D :: Cp :: A :: B :: E :: Cp :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: E :: Cp :: p2 :: nil) ((D :: Cp :: nil) ++ (A :: B :: E :: Cp :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDECpp2mtmp;try rewrite HT2 in HABDECpp2mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: E :: Cp :: p2 :: nil) (Cp :: nil) 4 1 2 HABDECpp2mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABECp requis par la preuve de (?)ABECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABECp requis par la preuve de (?)ABECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: B :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HABECpm2 : rk(A :: B :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 2) by (solve_hyps_min HABCpeq HABCpm2).
	assert(Hincl : incl (A :: B :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: B :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: B :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: B :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: B :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: B :: E :: Cp :: nil) (A :: B :: Cp :: nil) 5 2 5 HABCDECpmtmp HABCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABECpm3 : rk(A :: B :: E :: Cp :: nil) >= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABECpp2mtmp : rk(A :: B :: E :: Cp :: p2 :: nil) >= 3) by (solve_hyps_min HABECpp2eq HABECpp2m3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: E :: Cp :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: Cp :: p2 :: nil) (A :: B :: E :: Cp :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: Cp :: A :: p2 :: nil) ((A :: B :: E :: Cp :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABECpp2mtmp;try rewrite HT2 in HABECpp2mtmp.
	assert(HT := rule_2 (A :: B :: E :: Cp :: nil) (A :: p2 :: nil) (A :: nil) 3 1 1 HABECpp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDp1p2p3p4p5 requis par la preuve de (?)ACDp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B :: E :: Cp ::   de rang : 3 et 4 *)
assert(HACDp1p2p3p4p5m2 : rk(A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HABECpMtmp : rk(A :: B :: E :: Cp :: nil) <= 4) by (solve_hyps_max HABECpeq HABECpM4).
	assert(HABCDECpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4p5eq HABCDECpp1p2p3p4p5m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: E :: Cp :: nil) (A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: E :: Cp :: A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: E :: Cp :: A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: E :: Cp :: nil) ++ (A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: E :: Cp :: nil) (A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: nil) 5 1 4 HABCDECpp1p2p3p4p5mtmp HAmtmp HABECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDp1p2p3p4p5m3 : rk(A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3) by (solve_hyps_min HABCDp1p2p3p4p5eq HABCDp1p2p3p4p5m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: p1 :: A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDp1p2p3p4p5mtmp;try rewrite HT2 in HABCDp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p1 :: nil) 3 2 2 HABCDp1p2p3p4p5mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDp1p2p3p4p5m4 : rk(A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HACDp1eq : rk(A :: C :: D :: p1 :: nil) = 4) by (apply LACDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACDp1mtmp : rk(A :: C :: D :: p1 :: nil) >= 4) by (solve_hyps_min HACDp1eq HACDp1m4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: p1 :: nil) (A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: p1 :: nil) (A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 4 4 HACDp1mtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACp1p2p3p4p5 requis par la preuve de (?)ACp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACp1p2p3p4p5 requis par la preuve de (?)ACp1p2p3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACp1p2p3p4p5 requis par la preuve de (?)ACp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACp1p2p3p4p5m2 : rk(A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACp1p2p3p4p5m3 : rk(A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HACp1eq : rk(A :: C :: p1 :: nil) = 3) by (apply LACp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1mtmp : rk(A :: C :: p1 :: nil) >= 3) by (solve_hyps_min HACp1eq HACp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: p1 :: nil) (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: p1 :: nil) (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 3 3 HACp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  4 et 6 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HACp1p2p3p4p5m4 : rk(A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HACDp1p2p3p4p5mtmp : rk(A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HACDp1p2p3p4p5eq HACDp1p2p3p4p5m4).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: D :: p3 :: A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDp1p2p3p4p5mtmp;try rewrite HT2 in HACDp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p3 :: nil) 4 2 2 HACDp1p2p3p4p5mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: p4 ::  de rang :  2 et 2 	 A : A :: E :: p4 ::   de rang : 2 et 2 *)
assert(HACp1p2p3p4p5m5 : rk(A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HACEp1p2p3p4p5mtmp : rk(A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HACEp1p2p3p4p5eq HACEp1p2p3p4p5m5).
	assert(HAp4mtmp : rk(A :: p4 :: nil) >= 2) by (solve_hyps_min HAp4eq HAp4m2).
	assert(Hincl : incl (A :: p4 :: nil) (list_inter (A :: E :: p4 :: nil) (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: E :: p4 :: A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p4 :: A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: E :: p4 :: nil) ++ (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACEp1p2p3p4p5mtmp;try rewrite HT2 in HACEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: E :: p4 :: nil) (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p4 :: nil) 5 2 2 HACEp1p2p3p4p5mtmp HAp4mtmp HAEp4Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour Cp1p2p3p4p5 requis par la preuve de (?)Cp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour Cp1p2p3p4p5 requis par la preuve de (?)Cp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour Cp1p2p3p4p5 requis par la preuve de (?)Cp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCp1p2p3p4p5 requis par la preuve de (?)Cp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCp1p2p3p4p5 requis par la preuve de (?)ABCp1p2p3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCECpp1p2p3p4p5 requis par la preuve de (?)ABCp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCECpp1p2p3p4p5 requis par la preuve de (?)ABCECpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCECpp1p2p3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDECp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDECp requis par la preuve de (?)ACDECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDECpm2 : rk(A :: C :: D :: E :: Cp :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDECpm4 : rk(A :: C :: D :: E :: Cp :: nil) >= 4).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (B :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: Cp :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HBCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCCp requis par la preuve de (?)ABCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCCpm2 : rk(A :: B :: C :: Cp :: nil) >= 2).
{
	assert(HACDECpMtmp : rk(A :: C :: D :: E :: Cp :: nil) <= 5) by (solve_hyps_max HACDECpeq HACDECpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: C :: D :: E :: Cp :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: C :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: C :: D :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HACDECpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCCpm3 : rk(A :: B :: C :: Cp :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDECpp2mtmp : rk(A :: B :: C :: D :: E :: Cp :: p2 :: nil) >= 5) by (solve_hyps_min HABCDECpp2eq HABCDECpp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p2 :: nil) (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Cp :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Cp :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp2mtmp;try rewrite HT2 in HABCDECpp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Cp :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDECpp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1p2p3p4p5 requis par la preuve de (?)ABCECpp1p2p3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1p2p3p4p5 requis par la preuve de (?)ABCECpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1p2p3p4p5 requis par la preuve de (?)ABCDEApBpCpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1p2p3p4p5 requis par la preuve de (?)ABCECpp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1p2p3p4p5m2 : rk(A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1p2p3p4p5eq HABCDEApBpCpp1p2p3p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpCpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1p2p3p4p5mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCECpp1p2p3p4p5m3 : rk(A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 3) by (solve_hyps_min HABCCpeq HABCCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 3 3 HABCCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1p2p3p4p5m4 : rk(A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4p5eq HABCDECpp1p2p3p4p5m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1p2p3p4p5mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABCp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCp1p2p3p4p5 requis par la preuve de (?)ABCp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  4 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABCp1p2p3p4p5m2 : rk(A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCECpp1p2p3p4p5mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HABCECpp1p2p3p4p5eq HABCECpp1p2p3p4p5m4).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: E :: Cp :: A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1p2p3p4p5mtmp;try rewrite HT2 in HABCECpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: nil) 4 2 4 HABCECpp1p2p3p4p5mtmp HACmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp1p2p3p4p5m3 : rk(A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HACp1eq : rk(A :: C :: p1 :: nil) = 3) by (apply LACp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACp1mtmp : rk(A :: C :: p1 :: nil) >= 3) by (solve_hyps_min HACp1eq HACp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: p1 :: nil) (A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: p1 :: nil) (A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 3 3 HACp1mtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour Cp1p2p3p4p5 requis par la preuve de (?)Cp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  3 et 6 	 AiB : C :: p1 ::  de rang :  2 et 2 	 A : A :: B :: C :: p1 ::   de rang : 3 et 3 *)
assert(HCp1p2p3p4p5m2 : rk(C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HABCp1eq : rk(A :: B :: C :: p1 :: nil) = 3) by (apply LABCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(HABCp1p2p3p4p5mtmp : rk(A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3) by (solve_hyps_min HABCp1p2p3p4p5eq HABCp1p2p3p4p5m3).
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1mtmp : rk(C :: p1 :: nil) >= 2) by (solve_hyps_min HCp1eq HCp1m2).
	assert(Hincl : incl (C :: p1 :: nil) (list_inter (A :: B :: C :: p1 :: nil) (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: C :: p1 :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: p1 :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: C :: p1 :: nil) ++ (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp1p2p3p4p5mtmp;try rewrite HT2 in HABCp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: p1 :: nil) (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (C :: p1 :: nil) 3 2 3 HABCp1p2p3p4p5mtmp HCp1mtmp HABCp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  3 et 6 	 AiB : p2 ::  de rang :  1 et 1 	 A : A :: p2 ::   de rang : 1 et 1 *)
assert(HCp1p2p3p4p5m3 : rk(C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HACp1p2p3p4p5mtmp : rk(A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3) by (solve_hyps_min HACp1p2p3p4p5eq HACp1p2p3p4p5m3).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (A :: p2 :: nil) (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p2 :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: p2 :: nil) ++ (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACp1p2p3p4p5mtmp;try rewrite HT2 in HACp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: p2 :: nil) (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p2 :: nil) 3 1 1 HACp1p2p3p4p5mtmp Hp2mtmp HAp2Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  4 et 6 	 AiB : p2 :: p3 ::  de rang :  2 et 2 	 A : A :: p2 :: p3 ::   de rang : 2 et 2 *)
assert(HCp1p2p3p4p5m4 : rk(C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HAp2p3eq : rk(A :: p2 :: p3 :: nil) = 2) by (apply LAp2p3 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAp2p3Mtmp : rk(A :: p2 :: p3 :: nil) <= 2) by (solve_hyps_max HAp2p3eq HAp2p3M2).
	assert(HACp1p2p3p4p5mtmp : rk(A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HACp1p2p3p4p5eq HACp1p2p3p4p5m4).
	assert(Hp2p3eq : rk(p2 :: p3 :: nil) = 2) by (apply Lp2p3 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(Hp2p3mtmp : rk(p2 :: p3 :: nil) >= 2) by (solve_hyps_min Hp2p3eq Hp2p3m2).
	assert(Hincl : incl (p2 :: p3 :: nil) (list_inter (A :: p2 :: p3 :: nil) (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p2 :: p3 :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p3 :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: p2 :: p3 :: nil) ++ (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACp1p2p3p4p5mtmp;try rewrite HT2 in HACp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: p2 :: p3 :: nil) (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p2 :: p3 :: nil) 4 2 2 HACp1p2p3p4p5mtmp Hp2p3mtmp HAp2p3Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : p2 :: p4 ::  de rang :  2 et 2 	 A : A :: p2 :: p4 ::   de rang : 2 et 2 *)
assert(HCp1p2p3p4p5m5 : rk(C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HAp2p4eq : rk(A :: p2 :: p4 :: nil) = 2) by (apply LAp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAp2p4Mtmp : rk(A :: p2 :: p4 :: nil) <= 2) by (solve_hyps_max HAp2p4eq HAp2p4M2).
	assert(HACp1p2p3p4p5mtmp : rk(A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HACp1p2p3p4p5eq HACp1p2p3p4p5m5).
	assert(Hp2p4eq : rk(p2 :: p4 :: nil) = 2) by (apply Lp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(Hp2p4mtmp : rk(p2 :: p4 :: nil) >= 2) by (solve_hyps_min Hp2p4eq Hp2p4m2).
	assert(Hincl : incl (p2 :: p4 :: nil) (list_inter (A :: p2 :: p4 :: nil) (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p2 :: p4 :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p4 :: C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: p2 :: p4 :: nil) ++ (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACp1p2p3p4p5mtmp;try rewrite HT2 in HACp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: p2 :: p4 :: nil) (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p2 :: p4 :: nil) 5 2 2 HACp1p2p3p4p5mtmp Hp2p4mtmp HAp2p4Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -2*)
assert(HCp1p2p3p4p5M5 : rk(C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) <= 5).
{
	assert(HCp1p2p5eq : rk(C :: p1 :: p2 :: p5 :: nil) = 3) by (apply LCp1p2p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1p2p5Mtmp : rk(C :: p1 :: p2 :: p5 :: nil) <= 3) by (solve_hyps_max HCp1p2p5eq HCp1p2p5M3).
	assert(Hp3p4p5eq : rk(p3 :: p4 :: p5 :: nil) = 3) by (apply Lp3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(Hp3p4p5Mtmp : rk(p3 :: p4 :: p5 :: nil) <= 3) by (solve_hyps_max Hp3p4p5eq Hp3p4p5M3).
	assert(Hp5mtmp : rk(p5 :: nil) >= 1) by (solve_hyps_min Hp5eq Hp5m1).
	assert(Hincl : incl (p5 :: nil) (list_inter (C :: p1 :: p2 :: p5 :: nil) (p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (C :: p1 :: p2 :: p5 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: p2 :: p5 :: p3 :: p4 :: p5 :: nil) ((C :: p1 :: p2 :: p5 :: nil) ++ (p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: p1 :: p2 :: p5 :: nil) (p3 :: p4 :: p5 :: nil) (p5 :: nil) 3 3 1 HCp1p2p5Mtmp Hp3p4p5Mtmp Hp5mtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HCp1p2p3p4p5M : rk(C :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HCp1p2p3p4p5m : rk(C :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min HCp1p2p3p4p5eq HCp1p2p3p4p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpCpDpEpp1p2p3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) = 5.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ApBpCpDpEpp1p2p3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ApBpCpDpEpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HApBpCpDpEpp1p2p3p4p5m5 : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et -4*)
assert(HApBpCpDpEpp1p2p3p4p5M5 : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) <= 5).
{
	assert(HApBpCpDpEpp4Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp4eq HApBpCpDpEpp4M5).
	assert(HApBpCpDpEpp1p2p3p5eq : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil) = 5) by (apply LApBpCpDpEpp1p2p3p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HApBpCpDpEpp1p2p3p5Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp1p2p3p5eq HApBpCpDpEpp1p2p3p5M5).
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (list_inter (Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil) ((Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) ++ (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 5 HApBpCpDpEpp4Mtmp HApBpCpDpEpp1p2p3p5Mtmp HApBpCpDpEpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApBpCpDpEpp1p2p3p4p5M : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HApBpCpDpEpp1p2p3p4p5m : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min HApBpCpDpEpp1p2p3p4p5eq HApBpCpDpEpp1p2p3p4p5m1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApBpCpDpEpp1p2p3p4p5 *)
(* dans constructLemma(), requis par LACApBpCpDpEpp1p2p3p4p5 *)
(* dans constructLemma(), requis par LACEApBpCpDpEpp1p2p3p4p5 *)
(* dans constructLemma(), requis par LACDEApBpCpDpEpp1p2p3p4p5 *)
(* dans la couche 0 *)
Lemma LABCDEApBpCpDpEpp1p2p3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) = 6.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ABCDEApBpCpDpEpp1p2p3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ABCDEApBpCpDpEpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpDpEpp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpDpEpp1p2p3p4p5m6 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 6).
{
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(Hcomp : 6 <= 6) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 6 6 HABCDEApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

assert(HABCDEApBpCpDpEpp1p2p3p4p5M : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HABCDEApBpCpDpEpp1p2p3p4p5m : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min HABCDEApBpCpDpEpp1p2p3p4p5eq HABCDEApBpCpDpEpp1p2p3p4p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACDEApBpCpDpEpp1p2p3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) = 6.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ABCDEApBpCpDpEpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpDpEpp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpCpDpEpp1p2p3p4p5m3 : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpDpEpp1p2p3p4p5eq HABCDEApBpCpDpEpp1p2p3p4p5m5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpCpDpEpp1p2p3p4p5mtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpCpDpEpp1p2p3p4p5m4 : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpDpEpp1p2p3p4p5eq HABCDEApBpCpDpEpp1p2p3p4p5m5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (Bp :: nil) 5 1 2 HABCDEApBpCpDpEpp1p2p3p4p5mtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACDEApBpCpDpEpp1p2p3p4p5m5 : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 6 et 6) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  6 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEApBpCpDpEpp1p2p3p4p5m6 : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 6).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApBpCpDpEpp1p2p3p4p5eq : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) = 6) by (apply LABCDEApBpCpDpEpp1p2p3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABCDEApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpp1p2p3p4p5eq HABCDEApBpCpDpEpp1p2p3p4p5m6).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p1 :: nil) 6 2 2 HABCDEApBpCpDpEpp1p2p3p4p5mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

assert(HACDEApBpCpDpEpp1p2p3p4p5M : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HACDEApBpCpDpEpp1p2p3p4p5m : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min HACDEApBpCpDpEpp1p2p3p4p5eq HACDEApBpCpDpEpp1p2p3p4p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACEApBpCpDpEpp1p2p3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) = 6.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACEApBpCpDpEpp1p2p3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ABCDEApBpCpDpEpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpDpEpp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACDEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpCpDpEpp1p2p3p4p5m3 : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpDpEpp1p2p3p4p5eq HABCDEApBpCpDpEpp1p2p3p4p5m5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpCpDpEpp1p2p3p4p5mtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpCpDpEpp1p2p3p4p5m4 : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpDpEpp1p2p3p4p5eq HABCDEApBpCpDpEpp1p2p3p4p5m5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (Bp :: nil) 5 1 2 HABCDEApBpCpDpEpp1p2p3p4p5mtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ACEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACEApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpCpDpEpp1p2p3p4p5m2 : rk(A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpDpEpp1p2p3p4p5eq HABCDEApBpCpDpEpp1p2p3p4p5m5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpCpDpEpp1p2p3p4p5mtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpCpDpEpp1p2p3p4p5m3 : rk(A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HACDEApBpCpDpEpp1p2p3p4p5eq HACDEApBpCpDpEpp1p2p3p4p5m4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HACDEApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (Bp :: nil) 4 1 2 HACDEApBpCpDpEpp1p2p3p4p5mtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACEApBpCpDpEpp1p2p3p4p5m5 : rk(A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 6 et 6) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  6 et 6 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HACEApBpCpDpEpp1p2p3p4p5m6 : rk(A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 6).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HACDEApBpCpDpEpp1p2p3p4p5eq : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) = 6) by (apply LACDEApBpCpDpEpp1p2p3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACDEApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 6) by (solve_hyps_min HACDEApBpCpDpEpp1p2p3p4p5eq HACDEApBpCpDpEpp1p2p3p4p5m6).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: D :: p3 :: A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HACDEApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p3 :: nil) 6 2 2 HACDEApBpCpDpEpp1p2p3p4p5mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

assert(HACEApBpCpDpEpp1p2p3p4p5M : rk(A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HACEApBpCpDpEpp1p2p3p4p5m : rk(A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min HACEApBpCpDpEpp1p2p3p4p5eq HACEApBpCpDpEpp1p2p3p4p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBpCpDpEpp1p2p3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) = 6.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACApBpCpDpEpp1p2p3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ABCDEApBpCpDpEpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpDpEpp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BDECp requis par la preuve de (?)ACApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDECpp1 requis par la preuve de (?)BDECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABDECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)ABDECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDECpp1 requis par la preuve de (?)ABDECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDECpp1 requis par la preuve de (?)ABDECpp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDECpp1M5 : rk(A :: B :: D :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: D :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : C :: Cp ::   de rang : 1 et 2 *)
assert(HABDECpp1m4 : rk(A :: B :: D :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (C :: Cp :: nil) (A :: B :: D :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (C :: Cp :: A :: B :: D :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: A :: B :: D :: E :: Cp :: p1 :: nil) ((C :: Cp :: nil) ++ (A :: B :: D :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (C :: Cp :: nil) (A :: B :: D :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BDECp requis par la preuve de (?)BDECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)BDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDCp requis par la preuve de (?)BDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)BDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BDCp requis par la preuve de (?)BDCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBDCpm2 : rk(B :: D :: Cp :: nil) >= 2).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABDECpp1mtmp : rk(A :: B :: D :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABDECpp1eq HABDECpp1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: D :: Cp :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Cp :: p1 :: nil) (B :: D :: Cp :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: Cp :: A :: B :: E :: p1 :: nil) ((B :: D :: Cp :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDECpp1mtmp;try rewrite HT2 in HABDECpp1mtmp.
	assert(HT := rule_2 (B :: D :: Cp :: nil) (A :: B :: E :: p1 :: nil) (B :: nil) 4 1 3 HABDECpp1mtmp HBmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)BDECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BDECp requis par la preuve de (?)BDECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : B :: D :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HBDECpm2 : rk(B :: D :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HBDCpmtmp : rk(B :: D :: Cp :: nil) >= 2) by (solve_hyps_min HBDCpeq HBDCpm2).
	assert(Hincl : incl (B :: D :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (B :: D :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: B :: D :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: B :: D :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (B :: D :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (B :: D :: E :: Cp :: nil) (B :: D :: Cp :: nil) 5 2 5 HABCDECpmtmp HBDCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBDECpm3 : rk(B :: D :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDECpp1mtmp : rk(A :: B :: D :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABDECpp1eq HABDECpp1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: D :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Cp :: p1 :: nil) (B :: D :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: E :: Cp :: A :: B :: p1 :: nil) ((B :: D :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDECpp1mtmp;try rewrite HT2 in HABDECpp1mtmp.
	assert(HT := rule_2 (B :: D :: E :: Cp :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABDECpp1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)ACApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : B :: D :: E :: Cp ::   de rang : 3 et 4 *)
assert(HACApBpCpDpEpp1p2p3p4p5m2 : rk(A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HBDECpMtmp : rk(B :: D :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBDECpeq HBDECpM4).
	assert(HABCDEApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpDpEpp1p2p3p4p5eq HABCDEApBpCpDpEpp1p2p3p4p5m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: D :: E :: Cp :: nil) (A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (B :: D :: E :: Cp :: A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: E :: Cp :: A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((B :: D :: E :: Cp :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (B :: D :: E :: Cp :: nil) (A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (Cp :: nil) 5 1 4 HABCDEApBpCpDpEpp1p2p3p4p5mtmp HCpmtmp HBDECpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApBpCpDpEpp1p2p3p4p5m5 : rk(A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 6 et 6) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  6 et 6 	 AiB : A :: p4 ::  de rang :  2 et 2 	 A : A :: E :: p4 ::   de rang : 2 et 2 *)
assert(HACApBpCpDpEpp1p2p3p4p5m6 : rk(A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 6).
{
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HACEApBpCpDpEpp1p2p3p4p5eq : rk(A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) = 6) by (apply LACEApBpCpDpEpp1p2p3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACEApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 6) by (solve_hyps_min HACEApBpCpDpEpp1p2p3p4p5eq HACEApBpCpDpEpp1p2p3p4p5m6).
	assert(HAp4mtmp : rk(A :: p4 :: nil) >= 2) by (solve_hyps_min HAp4eq HAp4m2).
	assert(Hincl : incl (A :: p4 :: nil) (list_inter (A :: E :: p4 :: nil) (A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: E :: p4 :: A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p4 :: A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: E :: p4 :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACEApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HACEApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: E :: p4 :: nil) (A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p4 :: nil) 6 2 2 HACEApBpCpDpEpp1p2p3p4p5mtmp HAp4mtmp HAEp4Mtmp Hincl); apply HT.
}

assert(HACApBpCpDpEpp1p2p3p4p5M : rk(A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HACApBpCpDpEpp1p2p3p4p5m : rk(A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min HACApBpCpDpEpp1p2p3p4p5eq HACApBpCpDpEpp1p2p3p4p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpCpDpEpp1p2p3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) = 6.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour CApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)CApBpCpDpEpp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour CApBpCpDpEpp1p2p3p4p5 requis par la preuve de (?)CApBpCpDpEpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HCApBpCpDpEpp1p2p3p4p5m5 : rk(C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HApBpCpDpEpmtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpeq HApBpCpDpEpm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Dp :: Ep :: nil) (C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HApBpCpDpEpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 6 et 6) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  6 et 6 	 AiB : Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  de rang :  5 et 5 	 A : A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::   de rang : 5 et 5 *)
assert(HCApBpCpDpEpp1p2p3p4p5m6 : rk(C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 6).
{
	assert(HAApBpCpDpEpp4eq : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) = 5) by (apply LAApBpCpDpEpp4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAApBpCpDpEpp4Mtmp : rk(A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) <= 5) by (solve_hyps_max HAApBpCpDpEpp4eq HAApBpCpDpEpp4M5).
	assert(HACApBpCpDpEpp1p2p3p4p5eq : rk(A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) = 6) by (apply LACApBpCpDpEpp1p2p3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACApBpCpDpEpp1p2p3p4p5mtmp : rk(A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 6) by (solve_hyps_min HACApBpCpDpEpp1p2p3p4p5eq HACApBpCpDpEpp1p2p3p4p5m6).
	assert(HApBpCpDpEpp4mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) >= 5) by (solve_hyps_min HApBpCpDpEpp4eq HApBpCpDpEpp4m5).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) (list_inter (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) (C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) ++ (C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HACApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) (C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p4 :: nil) 6 5 5 HACApBpCpDpEpp1p2p3p4p5mtmp HApBpCpDpEpp4mtmp HAApBpCpDpEpp4Mtmp Hincl); apply HT.
}

assert(HCApBpCpDpEpp1p2p3p4p5M : rk(C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) <= 6) by (apply rk_upper_dim).
assert(HCApBpCpDpEpp1p2p3p4p5m : rk(C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min HCApBpCpDpEpp1p2p3p4p5eq HCApBpCpDpEpp1p2p3p4p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lp1p2p3p4p5 : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> rk(p1 :: p2 :: p3 :: p4 :: p5 ::  nil) = 4.
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour p1p2p3p4p5 requis par la preuve de (?)p1p2p3p4p5 pour la règle 3  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour Ap1p2p3p4p5 requis par la preuve de (?)p1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour AEp1p2p3p4p5 requis par la preuve de (?)Ap1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Ap1p2p3p5 requis par la preuve de (?)AEp1p2p3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ADp1p2p3p5 requis par la preuve de (?)Ap1p2p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Ap1p2p5 requis par la preuve de (?)ADp1p2p3p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour p1p5 requis par la preuve de (?)Ap1p2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Ap1p2p5 requis par la preuve de (?)Ap1p2p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Ap1p2p5 requis par la preuve de (?)Ap1p2p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp1p2p5m2 : rk(A :: p1 :: p2 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: p1 :: p2 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: p1 :: p2 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAp1p2p5M3 : rk(A :: p1 :: p2 :: p5 :: nil) <= 3).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp1p5Mtmp : rk(p1 :: p5 :: nil) <= 2) by (solve_hyps_max Hp1p5eq Hp1p5M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p1 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p5 :: nil) (A :: p2 :: p1 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p5 :: nil) ((A :: p2 :: nil) ++ (p1 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p1 :: p5 :: nil) (nil) 1 2 0 HAp2Mtmp Hp1p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADp1p2p3p5 requis par la preuve de (?)ADp1p2p3p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Dp1p3p5 requis par la preuve de (?)ADp1p2p3p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABDp1p3p5 requis par la preuve de (?)Dp1p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABDp1p3p5 requis par la preuve de (?)ABDp1p3p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Dp3p5 requis par la preuve de (?)ABDp1p3p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDp1p3p5 requis par la preuve de (?)ABDp1p3p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p3p5 requis par la preuve de (?)ABDp1p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p3p5 requis par la preuve de (?)ABCDECpp1p3p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p3p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACECp requis par la preuve de (?)ABDp1p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1 requis par la preuve de (?)ABCDECpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DCp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp1 requis par la preuve de (?)ABCDEApp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp1m5 : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DAp requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp1 requis par la preuve de (?)ABCp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp1M3 : rk(A :: B :: C :: p1 :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p1 :: nil) (C :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: B :: p1 :: nil) ((C :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HCMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp1 requis par la preuve de (?)ABCEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp1M4 : rk(A :: B :: C :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp1Mtmp : rk(A :: B :: C :: p1 :: nil) <= 3) by (solve_hyps_max HABCp1eq HABCp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p1 :: nil) (E :: A :: B :: C :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p1 :: nil) ((E :: nil) ++ (A :: B :: C :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p1 :: nil) (nil) 1 3 0 HEMtmp HABCp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEp1m3 : rk(A :: B :: C :: E :: p1 :: nil) >= 3).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCpp1 requis par la preuve de (?)ABCDEApBpCpp1 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpp1m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBp requis par la preuve de (?)ABCDEApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDp1 requis par la preuve de (?)ABDp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDp1M3 : rk(A :: B :: D :: p1 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: nil) (D :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: B :: p1 :: nil) ((D :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HDMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABDEp1 requis par la preuve de (?)ABDEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEp1M4 : rk(A :: B :: D :: E :: p1 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: D :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: nil) (E :: A :: B :: D :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: D :: p1 :: nil) ((E :: nil) ++ (A :: B :: D :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: D :: p1 :: nil) (nil) 1 3 0 HEMtmp HABDp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEApp1 requis par la preuve de (?)ABDEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABDEApp1M5 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: D :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABDEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEApp1m4 : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: Ap :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABEp1 requis par la preuve de (?)ABEp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABEp1M3 : rk(A :: B :: E :: p1 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: E :: p1 :: nil) (E :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: p1 :: nil) ((E :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: p1 :: nil) (nil) 1 2 0 HEMtmp HABp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: D :: E :: Ap :: p1 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABEp1m2 : rk(A :: B :: E :: p1 :: nil) >= 2).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABDEApp1mtmp : rk(A :: B :: D :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABDEApp1eq HABDEApp1m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: E :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEApp1mtmp;try rewrite HT2 in HABDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (nil) 4 0 2 HABDEApp1mtmp Hmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEBpCpDpEp requis par la preuve de (?)ABCDEBpCpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEBpCpDpEpm5 : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCE requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBpCpDpEp requis par la preuve de (?)ABCEApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: E ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCEApBpCpDpEpm2 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCEmtmp : rk(A :: B :: C :: E :: nil) >= 1) by (solve_hyps_min HABCEeq HABCEm1).
	assert(Hincl : incl (A :: B :: C :: E :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCEmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApBpCpDpEpm5 : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDAp requis par la preuve de (?)ACDAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDApm2 : rk(A :: C :: D :: Ap :: nil) >= 2).
{
	assert(HABCEApBpCpDpEpMtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCEApBpCpDpEpeq HABCEApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCEApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HACDApm3 : rk(A :: C :: D :: Ap :: nil) >= 3).
{
	assert(HABEp1Mtmp : rk(A :: B :: E :: p1 :: nil) <= 3) by (solve_hyps_max HABEp1eq HABEp1M3).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: A :: B :: E :: p1 :: nil) ((A :: C :: D :: Ap :: nil) ++ (A :: B :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: Ap :: nil) (A :: B :: E :: p1 :: nil) (A :: nil) 5 1 3 HABCDEApp1mtmp HAmtmp HABEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EAp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCD requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDApBpCpDpEp requis par la preuve de (?)ABCDApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C :: D ::  de rang :  1 et 4 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCDApBpCpDpEpm2 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 2).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: nil) 6 1 5 HABCDEApBpCpDpEpmtmp HABCDmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: -4 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCDApBpCpDpEpm5 : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 6 1 2 HABCDEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABC requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABC pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCp2 requis par la preuve de (?)ABCp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCp2M3 : rk(A :: B :: C :: p2 :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (B :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: p2 :: nil) ((B :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HBMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCp2m2 : rk(A :: B :: C :: p2 :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: B :: C :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: B :: C :: p2 :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABC requis par la preuve de (?)ABC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCm2 : rk(A :: B :: C :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCp2mtmp : rk(A :: B :: C :: p2 :: nil) >= 2) by (solve_hyps_min HABCp2eq HABCp2m2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: p2 :: nil) (A :: B :: C :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: A :: p2 :: nil) ((A :: B :: C :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCp2mtmp;try rewrite HT2 in HABCp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: nil) (A :: p2 :: nil) (A :: nil) 2 1 1 HABCp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCApBpCpDpEp requis par la preuve de (?)ABCApBpCpDpEp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: -4 5 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  6 et 6 	 AiB : A :: B :: C ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: E ::   de rang : 5 et 5 *)
assert(HABCApBpCpDpEpm3 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 3).
{
	assert(HABCDEMtmp : rk(A :: B :: C :: D :: E :: nil) <= 5) by (solve_hyps_max HABCDEeq HABCDEM5).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: D :: E :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 5 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : E :: Ap ::   de rang : 1 et 2 *)
assert(HABCApBpCpDpEpm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 4).
{
	assert(HEApMtmp : rk(E :: Ap :: nil) <= 2) by (solve_hyps_max HEApeq HEApM2).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_4 (E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (Ap :: nil) 5 1 2 HABCEApBpCpDpEpmtmp HApmtmp HEApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEAp requis par la preuve de (?)ACDEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm2 : rk(A :: C :: D :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACDEApm3 : rk(A :: C :: D :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: D :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HACDApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACDEApm4 : rk(A :: C :: D :: E :: Ap :: nil) >= 4).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: D :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_2 (A :: C :: D :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 5 1 2 HABCDEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEAp requis par la preuve de (?)ABCDEAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApm5 : rk(A :: B :: C :: D :: E :: Ap :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApBp requis par la preuve de (?)ACDEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDEApBpm3 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDEApmtmp : rk(A :: C :: D :: E :: Ap :: nil) >= 4) by (solve_hyps_min HACDEApeq HACDEApm4).
	assert(Hincl : incl (A :: C :: D :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (A :: C :: D :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HACDEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACDEApBpm4 : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: D :: E :: Ap :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: D :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: D :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour EBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDApBp requis par la preuve de (?)ACDApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: D :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACDApBpm2 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACDApmtmp : rk(A :: C :: D :: Ap :: nil) >= 3) by (solve_hyps_min HACDApeq HACDApm3).
	assert(Hincl : incl (A :: C :: D :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: D :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: D :: Ap :: Bp :: nil) (A :: C :: D :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACDApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HACDApBpm3 : rk(A :: C :: D :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: C :: D :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: C :: D :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: C :: D :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCECpp1 requis par la preuve de (?)ABCECpp1 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: D :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCECpp1m2 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 2).
{
	assert(HACDApBpMtmp : rk(A :: C :: D :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACDApBpeq HACDApBpM5).
	assert(HABCDEApBpCpp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpp1eq HABCDEApBpCpp1m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: p1 :: nil) (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: Ap :: Bp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((A :: C :: D :: Ap :: Bp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpp1mtmp;try rewrite HT2 in HABCDEApBpCpp1mtmp.
	assert(HT := rule_4 (A :: C :: D :: Ap :: Bp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpp1mtmp HACmtmp HACDApBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCECpp1M5 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) <= 5).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: C :: E :: p1 :: nil) ((Cp :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HCpMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 ::  de rang :  5 et 6 	 AiB : Cp ::  de rang :  1 et 1 	 A : D :: Cp ::   de rang : 1 et 2 *)
assert(HABCECpp1m4 : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4).
{
	assert(HDCpMtmp : rk(D :: Cp :: nil) <= 2) by (solve_hyps_max HDCpeq HDCpM2).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: A :: B :: C :: E :: Cp :: p1 :: nil) ((D :: Cp :: nil) ++ (A :: B :: C :: E :: Cp :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_4 (D :: Cp :: nil) (A :: B :: C :: E :: Cp :: p1 :: nil) (Cp :: nil) 5 1 2 HABCDECpp1mtmp HCpmtmp HDCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECp requis par la preuve de (?)ABCDECp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpm5 : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ACCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpDpEp requis par la preuve de (?)ABCDEApBpDpEp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpDpEpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACCp requis par la preuve de (?)ACCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 5*)
assert(HACCpm2 : rk(A :: C :: Cp :: nil) >= 2).
{
	assert(HABCDEApBpDpEpMtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEApBpDpEpeq HABCDEApBpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Cp :: A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) ((A :: C :: Cp :: nil) ++ (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: Cp :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Dp :: Ep :: nil) (A :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACmtmp HABCDEApBpDpEpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ACECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ECp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpCp requis par la preuve de (?)ABCDEApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpCpm5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp1 requis par la preuve de (?)ABCEApp1 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp1M5 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp1Mtmp : rk(A :: B :: C :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABCEp1eq HABCEp1M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: A :: B :: C :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p1 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p1 :: nil) (nil) 1 4 0 HApMtmp HABCEp1Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp1m2 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 2).
{
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) 2 2 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp1m4 : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p1 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p1 :: nil) (Ap :: nil) 5 1 2 HABCDEApp1mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACEAp requis par la preuve de (?)ACEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HACEApm2 : rk(A :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 2) by (solve_hyps_min HACApeq HACApm2).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: C :: Ap :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HACApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACEApm3 : rk(A :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCEApp1mtmp : rk(A :: B :: C :: E :: Ap :: p1 :: nil) >= 4) by (solve_hyps_min HABCEApp1eq HABCEApp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p1 :: nil) (A :: C :: E :: Ap :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: A :: B :: p1 :: nil) ((A :: C :: E :: Ap :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp1mtmp;try rewrite HT2 in HABCEApp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Ap :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCEApp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACEApBp requis par la preuve de (?)ACEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: C :: E :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HACEApBpm2 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HACEApmtmp : rk(A :: C :: E :: Ap :: nil) >= 3) by (solve_hyps_min HACEApeq HACEApm3).
	assert(Hincl : incl (A :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: C :: E :: Ap :: Bp :: nil) (A :: C :: E :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HACEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HACEApBpm3 : rk(A :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HACDEApBpmtmp : rk(A :: C :: D :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACDEApBpeq HACDEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApBpmtmp;try rewrite HT2 in HACDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HACDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCDCp requis par la preuve de (?)ABCDCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: Cp ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: C :: E :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HABCDCpm2 : rk(A :: B :: C :: D :: Cp :: nil) >= 2).
{
	assert(HACEApBpMtmp : rk(A :: C :: E :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HACEApBpeq HACEApBpM5).
	assert(HABCDEApBpCpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) >= 5) by (solve_hyps_min HABCDEApBpCpeq HABCDEApBpCpm5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: nil) (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Ap :: Bp :: A :: B :: C :: D :: Cp :: nil) ((A :: C :: E :: Ap :: Bp :: nil) ++ (A :: B :: C :: D :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpmtmp;try rewrite HT2 in HABCDEApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: Cp :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpCpmtmp HACmtmp HACEApBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCDCpm4 : rk(A :: B :: C :: D :: Cp :: nil) >= 4).
{
	assert(HECpMtmp : rk(E :: Cp :: nil) <= 2) by (solve_hyps_max HECpeq HECpM2).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_2 (A :: B :: C :: D :: Cp :: nil) (E :: Cp :: nil) (Cp :: nil) 5 1 2 HABCDECpmtmp HCpmtmp HECpMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACECp requis par la preuve de (?)ACECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : A :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HACECpm2 : rk(A :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HACCpmtmp : rk(A :: C :: Cp :: nil) >= 2) by (solve_hyps_min HACCpeq HACCpm2).
	assert(Hincl : incl (A :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: A :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (A :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (A :: C :: E :: Cp :: nil) (A :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HACCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HACECpm3 : rk(A :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (A :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: p1 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (A :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (A :: nil) 4 1 2 HABCECpp1mtmp HAmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDp1p3p5 requis par la preuve de (?)ABDp1p3p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 ::  de rang :  5 et 6 	 AiB : A ::  de rang :  1 et 1 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABDp1p3p5m2 : rk(A :: B :: D :: p1 :: p3 :: p5 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCDECpp1p3p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p3p5eq HABCDECpp1p3p5m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: D :: p1 :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p3 :: p5 :: nil) (A :: C :: E :: Cp :: A :: B :: D :: p1 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: D :: p1 :: p3 :: p5 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: D :: p1 :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p3p5mtmp;try rewrite HT2 in HABCDECpp1p3p5mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: D :: p1 :: p3 :: p5 :: nil) (A :: nil) 5 1 4 HABCDECpp1p3p5mtmp HAmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HABDp1p3p5M5 : rk(A :: B :: D :: p1 :: p3 :: p5 :: nil) <= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HDp3p5Mtmp : rk(D :: p3 :: p5 :: nil) <= 3) by (solve_hyps_max HDp3p5eq HDp3p5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: p1 :: nil) (D :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: p3 :: p5 :: nil) (A :: B :: p1 :: D :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: D :: p3 :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (D :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: p1 :: nil) (D :: p3 :: p5 :: nil) (nil) 2 3 0 HABp1Mtmp HDp3p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDp1p3p5m3 : rk(A :: B :: D :: p1 :: p3 :: p5 :: nil) >= 3).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADp1mtmp : rk(A :: D :: p1 :: nil) >= 3) by (solve_hyps_min HADp1eq HADp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: p1 :: nil) (A :: B :: D :: p1 :: p3 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: p1 :: nil) (A :: B :: D :: p1 :: p3 :: p5 :: nil) 3 3 HADp1mtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Dp1p3p5 requis par la preuve de (?)Dp1p3p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: D :: p1 :: p3 :: p5 ::  de rang :  3 et 5 	 AiB : D :: p1 ::  de rang :  2 et 2 	 A : A :: B :: D :: p1 ::   de rang : 3 et 3 *)
assert(HDp1p3p5m2 : rk(D :: p1 :: p3 :: p5 :: nil) >= 2).
{
	assert(HABDp1eq : rk(A :: B :: D :: p1 :: nil) = 3) by (apply LABDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HABDp1Mtmp : rk(A :: B :: D :: p1 :: nil) <= 3) by (solve_hyps_max HABDp1eq HABDp1M3).
	assert(HABDp1p3p5mtmp : rk(A :: B :: D :: p1 :: p3 :: p5 :: nil) >= 3) by (solve_hyps_min HABDp1p3p5eq HABDp1p3p5m3).
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1mtmp : rk(D :: p1 :: nil) >= 2) by (solve_hyps_min HDp1eq HDp1m2).
	assert(Hincl : incl (D :: p1 :: nil) (list_inter (A :: B :: D :: p1 :: nil) (D :: p1 :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: p1 :: p3 :: p5 :: nil) (A :: B :: D :: p1 :: D :: p1 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: p1 :: D :: p1 :: p3 :: p5 :: nil) ((A :: B :: D :: p1 :: nil) ++ (D :: p1 :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDp1p3p5mtmp;try rewrite HT2 in HABDp1p3p5mtmp.
	assert(HT := rule_4 (A :: B :: D :: p1 :: nil) (D :: p1 :: p3 :: p5 :: nil) (D :: p1 :: nil) 3 2 3 HABDp1p3p5mtmp HDp1mtmp HABDp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADp1p2p3p5 requis par la preuve de (?)ADp1p2p3p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADp1p2p3p5 requis par la preuve de (?)ADp1p2p3p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADp1p2p3p5 requis par la preuve de (?)ADp1p2p3p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HADp1p2p3p5m2 : rk(A :: D :: p1 :: p2 :: p3 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADp1p2p3p5m3 : rk(A :: D :: p1 :: p2 :: p3 :: p5 :: nil) >= 3).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADp1mtmp : rk(A :: D :: p1 :: nil) >= 3) by (solve_hyps_min HADp1eq HADp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p5 :: nil) 3 3 HADp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HADp1p2p3p5M5 : rk(A :: D :: p1 :: p2 :: p3 :: p5 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HDp1p3p5Mtmp : rk(D :: p1 :: p3 :: p5 :: nil) <= 4) by (solve_hyps_max HDp1p3p5eq HDp1p3p5M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (D :: p1 :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p5 :: nil) (A :: p2 :: D :: p1 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: D :: p1 :: p3 :: p5 :: nil) ((A :: p2 :: nil) ++ (D :: p1 :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (D :: p1 :: p3 :: p5 :: nil) (nil) 1 4 0 HAp2Mtmp HDp1p3p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HADp1p2p3p5M4 : rk(A :: D :: p1 :: p2 :: p3 :: p5 :: nil) <= 4).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HAp1p2p5Mtmp : rk(A :: p1 :: p2 :: p5 :: nil) <= 3) by (solve_hyps_max HAp1p2p5eq HAp1p2p5M3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p5 :: nil) (A :: D :: p3 :: A :: p1 :: p2 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: p1 :: p2 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (A :: p1 :: p2 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p5 :: nil) (A :: nil) 2 3 1 HADp3Mtmp HAp1p2p5Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Ap1p2p3p5 requis par la preuve de (?)Ap1p2p3p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour p1p3p5 requis par la preuve de (?)Ap1p2p3p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour Ap1p2p3p5 requis par la preuve de (?)Ap1p2p3p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour Ap1p2p3p5 requis par la preuve de (?)Ap1p2p3p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp1p2p3p5m2 : rk(A :: p1 :: p2 :: p3 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: p1 :: p2 :: p3 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: p1 :: p2 :: p3 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAp1p2p3p5M4 : rk(A :: p1 :: p2 :: p3 :: p5 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp1p3p5Mtmp : rk(p1 :: p3 :: p5 :: nil) <= 3) by (solve_hyps_max Hp1p3p5eq Hp1p3p5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p1 :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p3 :: p5 :: nil) (A :: p2 :: p1 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p3 :: p5 :: nil) ((A :: p2 :: nil) ++ (p1 :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p1 :: p3 :: p5 :: nil) (nil) 1 3 0 HAp2Mtmp Hp1p3p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: D :: p1 :: p2 :: p3 :: p5 ::  de rang :  3 et 4 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HAp1p2p3p5m3 : rk(A :: p1 :: p2 :: p3 :: p5 :: nil) >= 3).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HADp1p2p3p5mtmp : rk(A :: D :: p1 :: p2 :: p3 :: p5 :: nil) >= 3) by (solve_hyps_min HADp1p2p3p5eq HADp1p2p3p5m3).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p5 :: nil) (A :: D :: p3 :: A :: p1 :: p2 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: p1 :: p2 :: p3 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (A :: p1 :: p2 :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADp1p2p3p5mtmp;try rewrite HT2 in HADp1p2p3p5mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p3 :: p5 :: nil) (A :: p3 :: nil) 3 2 2 HADp1p2p3p5mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour AEp1p2p3p4p5 requis par la preuve de (?)AEp1p2p3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ADEp1p2p3p4p5 requis par la preuve de (?)AEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ACDEp1p2p3p4p5 requis par la preuve de (?)ADEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEp1p2p3p4p5 requis par la preuve de (?)ABCDEp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ACDEp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bp1 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ACDEp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDECpp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDECpp1p2p3p4p5 requis par la preuve de (?)ABCDECpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDECpp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ACDEp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApBpp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApBpp1p2p3p4p5 requis par la preuve de (?)ABCDEApBpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApBpp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEApp2 requis par la preuve de (?)ABCDEApp2 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEApp2m5 : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Ap :: p2 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDp2 requis par la preuve de (?)ACDp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDp2M3 : rk(A :: C :: D :: p2 :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HACp2Mtmp : rk(A :: C :: p2 :: nil) <= 2) by (solve_hyps_max HACp2eq HACp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: p2 :: nil) (D :: A :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: C :: p2 :: nil) ((D :: nil) ++ (A :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: C :: p2 :: nil) (nil) 1 2 0 HDMtmp HACp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ACDEp2 requis par la preuve de (?)ACDEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEp2M4 : rk(A :: C :: D :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HACDp2Mtmp : rk(A :: C :: D :: p2 :: nil) <= 3) by (solve_hyps_max HACDp2eq HACDp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: C :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p2 :: nil) (E :: A :: C :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: C :: D :: p2 :: nil) ((E :: nil) ++ (A :: C :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: C :: D :: p2 :: nil) (nil) 1 3 0 HEMtmp HACDp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEApp2 requis par la preuve de (?)ACDEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HACDEApp2M5 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: D :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HACDEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEApp2m4 : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: Ap :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ADp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADp2 requis par la preuve de (?)ADp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HADp2M2 : rk(A :: D :: p2 :: nil) <= 2).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p2 :: nil) (D :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: A :: p2 :: nil) ((D :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (A :: p2 :: nil) (nil) 1 1 0 HDMtmp HAp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADEp2 requis par la preuve de (?)ADEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HADEp2M3 : rk(A :: D :: E :: p2 :: nil) <= 3).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HADp2Mtmp : rk(A :: D :: p2 :: nil) <= 2) by (solve_hyps_max HADp2eq HADp2M2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: D :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p2 :: nil) (E :: A :: D :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: D :: p2 :: nil) ((E :: nil) ++ (A :: D :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: D :: p2 :: nil) (nil) 1 2 0 HEMtmp HADp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: C :: D :: E :: Ap :: p2 ::  de rang :  4 et 5 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HADEp2m2 : rk(A :: D :: E :: p2 :: nil) >= 2).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HACDEApp2mtmp : rk(A :: C :: D :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HACDEApp2eq HACDEApp2m4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: Ap :: p2 :: nil) (C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: D :: E :: p2 :: nil) ((C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEApp2mtmp;try rewrite HT2 in HACDEApp2mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (nil) 4 0 2 HACDEApp2mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAp requis par la preuve de (?)ABCAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCApm2 : rk(A :: B :: C :: Ap :: nil) >= 2).
{
	assert(HABCDEBpCpDpEpMtmp : rk(A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDEBpCpDpEpeq HABCDEBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCmtmp : rk(A :: B :: C :: nil) >= 2) by (solve_hyps_min HABCeq HABCm2).
	assert(Hincl : incl (A :: B :: C :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: B :: C :: D :: E :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: nil) 6 2 6 HABCDEApBpCpDpEpmtmp HABCmtmp HABCDEBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABCApm3 : rk(A :: B :: C :: Ap :: nil) >= 3).
{
	assert(HADEp2Mtmp : rk(A :: D :: E :: p2 :: nil) <= 3) by (solve_hyps_max HADEp2eq HADEp2M3).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: A :: D :: E :: p2 :: nil) ((A :: B :: C :: Ap :: nil) ++ (A :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: Ap :: nil) (A :: D :: E :: p2 :: nil) (A :: nil) 5 1 3 HABCDEApp2mtmp HAmtmp HADEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACDEp2 requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 1 et 2 *)
assert(HACDEp2m3 : rk(A :: C :: D :: E :: p2 :: nil) >= 3).
{
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (nil) 5 0 2 HABCDEApp2mtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HACDEp2Mtmp : rk(A :: C :: D :: E :: p2 :: nil) <= 4) by (solve_hyps_max HACDEp2eq HACDEp2M4).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: A :: C :: D :: E :: p2 :: nil) ((A :: B :: Ap :: nil) ++ (A :: C :: D :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (A :: C :: D :: E :: p2 :: nil) (A :: nil) 5 1 4 HABCDEApp2mtmp HAmtmp HACDEp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCEp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEp2 requis par la preuve de (?)ABCEp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEp2M4 : rk(A :: B :: C :: E :: p2 :: nil) <= 4).
{
	assert(HEMtmp : rk(E :: nil) <= 1) by (solve_hyps_max HEeq HEM1).
	assert(HABCp2Mtmp : rk(A :: B :: C :: p2 :: nil) <= 3) by (solve_hyps_max HABCp2eq HABCp2M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (E :: nil) (A :: B :: C :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: p2 :: nil) (E :: A :: B :: C :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: A :: B :: C :: p2 :: nil) ((E :: nil) ++ (A :: B :: C :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (E :: nil) (A :: B :: C :: p2 :: nil) (nil) 1 3 0 HEMtmp HABCp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApp2 requis par la preuve de (?)ABCEApp2 pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 5 et 5*)
assert(HABCEApp2M5 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) <= 5).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABCEp2Mtmp : rk(A :: B :: C :: E :: p2 :: nil) <= 4) by (solve_hyps_max HABCEp2eq HABCEp2M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: C :: E :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: A :: B :: C :: E :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: C :: E :: p2 :: nil) ((Ap :: nil) ++ (A :: B :: C :: E :: p2 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: C :: E :: p2 :: nil) (nil) 1 4 0 HApMtmp HABCEp2Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m2 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 2).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 2) by (solve_hyps_min HABApeq HABApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 2 2 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABCEApp2m3 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 3).
{
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) 3 3 HABCApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p2 ::  de rang :  5 et 6 	 AiB : Ap ::  de rang :  1 et 1 	 A : D :: Ap ::   de rang : 1 et 2 *)
assert(HABCEApp2m4 : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4).
{
	assert(HDApMtmp : rk(D :: Ap :: nil) <= 2) by (solve_hyps_max HDApeq HDApM2).
	assert(HABCDEApp2mtmp : rk(A :: B :: C :: D :: E :: Ap :: p2 :: nil) >= 5) by (solve_hyps_min HABCDEApp2eq HABCDEApp2m5).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p2 :: nil) (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: A :: B :: C :: E :: Ap :: p2 :: nil) ((D :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp2mtmp;try rewrite HT2 in HABCDEApp2mtmp.
	assert(HT := rule_4 (D :: Ap :: nil) (A :: B :: C :: E :: Ap :: p2 :: nil) (Ap :: nil) 5 1 2 HABCDEApp2mtmp HApmtmp HDApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCEAp requis par la preuve de (?)ABCEAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 5 et 5*)
assert(HABCEApm2 : rk(A :: B :: C :: E :: Ap :: nil) >= 2).
{
	assert(HABCApBpCpDpEpMtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCApBpCpDpEpeq HABCApBpCpDpEpM6).
	assert(HABCEApBpCpDpEpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 5) by (solve_hyps_min HABCEApBpCpDpEpeq HABCEApBpCpDpEpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpCpDpEpmtmp;try rewrite HT2 in HABCEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCEApBpCpDpEpmtmp HABCApmtmp HABCApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 5 et 5*)
assert(HABCEApm3 : rk(A :: B :: C :: E :: Ap :: nil) >= 3).
{
	assert(HABCDApBpCpDpEpMtmp : rk(A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) <= 6) by (solve_hyps_max HABCDApBpCpDpEpeq HABCDApBpCpDpEpM6).
	assert(HABCDEApBpCpDpEpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) >= 6) by (solve_hyps_min HABCDEApBpCpDpEpeq HABCDEApBpCpDpEpm6).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpCpDpEpmtmp;try rewrite HT2 in HABCDEApBpCpDpEpmtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: B :: C :: D :: Ap :: Bp :: Cp :: Dp :: Ep :: nil) (A :: B :: C :: Ap :: nil) 6 3 6 HABCDEApBpCpDpEpmtmp HABCApmtmp HABCDApBpCpDpEpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HABCEApm4 : rk(A :: B :: C :: E :: Ap :: nil) >= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HABCEApp2mtmp : rk(A :: B :: C :: E :: Ap :: p2 :: nil) >= 4) by (solve_hyps_min HABCEApp2eq HABCEApp2m4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: p2 :: nil) (A :: B :: C :: E :: Ap :: A :: p2 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: E :: Ap :: A :: p2 :: nil) ((A :: B :: C :: E :: Ap :: nil) ++ (A :: p2 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApp2mtmp;try rewrite HT2 in HABCEApp2mtmp.
	assert(HT := rule_2 (A :: B :: C :: E :: Ap :: nil) (A :: p2 :: nil) (A :: nil) 4 1 1 HABCEApp2mtmp HAmtmp HAp2Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCEApBp requis par la preuve de (?)ABCEApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: E :: Ap ::  de rang :  4 et 5 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCEApBpm3 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 3).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCEApmtmp : rk(A :: B :: C :: E :: Ap :: nil) >= 4) by (solve_hyps_min HABCEApeq HABCEApm4).
	assert(Hincl : incl (A :: B :: C :: E :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: E :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (A :: B :: C :: E :: Ap :: nil) 5 4 6 HABCDEApBpmtmp HABCEApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : D :: Bp ::   de rang : 1 et 2 *)
assert(HABCEApBpm4 : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4).
{
	assert(HDBpMtmp : rk(D :: Bp :: nil) <= 2) by (solve_hyps_max HDBpeq HDBpM2).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: A :: B :: C :: E :: Ap :: Bp :: nil) ((D :: Bp :: nil) ++ (A :: B :: C :: E :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (D :: Bp :: nil) (A :: B :: C :: E :: Ap :: Bp :: nil) (Bp :: nil) 5 1 2 HABCDEApBpmtmp HBpmtmp HDBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp ::  de rang :  5 et 6 	 AiB : A :: B :: C :: Ap ::  de rang :  3 et 4 	 A : A :: B :: C :: D :: E :: Ap ::   de rang : 5 et 6 *)
assert(HABCApBpm2 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCDEApMtmp : rk(A :: B :: C :: D :: E :: Ap :: nil) <= 6) by (solve_hyps_max HABCDEApeq HABCDEApM6).
	assert(HABCDEApBpmtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: nil) >= 5) by (solve_hyps_min HABCDEApBpeq HABCDEApBpm5).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HABCApeq HABCApm3).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (list_inter (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: nil) (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: E :: Ap :: A :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: D :: E :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpmtmp;try rewrite HT2 in HABCDEApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: E :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Ap :: nil) 5 3 6 HABCDEApBpmtmp HABCApmtmp HABCDEApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: E :: Ap :: Bp ::  de rang :  4 et 6 	 AiB : Bp ::  de rang :  1 et 1 	 A : E :: Bp ::   de rang : 1 et 2 *)
assert(HABCApBpm3 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HEBpMtmp : rk(E :: Bp :: nil) <= 2) by (solve_hyps_max HEBpeq HEBpM2).
	assert(HABCEApBpmtmp : rk(A :: B :: C :: E :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCEApBpeq HABCEApBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Ap :: Bp :: nil) (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (E :: Bp :: A :: B :: C :: Ap :: Bp :: nil) ((E :: Bp :: nil) ++ (A :: B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCEApBpmtmp;try rewrite HT2 in HABCEApBpmtmp.
	assert(HT := rule_4 (E :: Bp :: nil) (A :: B :: C :: Ap :: Bp :: nil) (Bp :: nil) 4 1 2 HABCEApBpmtmp HBpmtmp HEBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ACDEp1p2p3p4p5 requis par la preuve de (?)ACDEp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: C ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 3 et 5 *)
assert(HACDEp1p2p3p4p5m2 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 5) by (solve_hyps_max HABCApBpeq HABCApBpM5).
	assert(HABCDEApBpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEApBpp1p2p3p4p5eq HABCDEApBpp1p2p3p4p5m5).
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hincl : incl (A :: C :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: Bp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApBpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEApBpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: nil) 5 2 5 HABCDEApBpp1p2p3p4p5mtmp HACmtmp HABCApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4p5m3 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	assert(HABCDECpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4p5eq HABCDECpp1p2p3p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((B :: Cp :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (nil) 5 0 2 HABCDECpp1p2p3p4p5mtmp Hmtmp HBCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : B :: p1 ::   de rang : 1 et 2 *)
assert(HACDEp1p2p3p4p5m4 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HBp1Mtmp : rk(B :: p1 :: nil) <= 2) by (solve_hyps_max HBp1eq HBp1M2).
	assert(HABCDEp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4p5eq HABCDEp1p2p3p4p5m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p1 :: nil) 5 1 2 HABCDEp1p2p3p4p5mtmp Hp1mtmp HBp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 5 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HACDEp1p2p3p4p5m5 : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCDEp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEp1p2p3p4p5eq HABCDEp1p2p3p4p5m5).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p1 :: nil) 5 2 2 HABCDEp1p2p3p4p5mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADEp1p2p3p4p5 requis par la preuve de (?)ADEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ABDEp1p2p3p4p5 requis par la preuve de (?)ADEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 5 <= rg <= 6 pour ABCDEDpp1p2p3p4p5 requis par la preuve de (?)ABDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABCDEDpp1p2p3p4p5 requis par la preuve de (?)ABCDEDpp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDEDpp1p2p3p4p5m5 : rk(A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5).
{
	assert(HABCDEmtmp : rk(A :: B :: C :: D :: E :: nil) >= 5) by (solve_hyps_min HABCDEeq HABCDEm5).
	assert(Hcomp : 5 <= 5) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: E :: nil) (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 HABCDEmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CDp requis par la preuve de (?)ABDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ABDEp1p2p3p4p5 requis par la preuve de (?)ABDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AE requis par la preuve de (?)ABDEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ABDEp1p2p3p4p5 requis par la preuve de (?)ABDEp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : A :: E ::  de rang :  1 et 2 	 A : A :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HABDEp1p2p3p4p5m2 : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HACECpMtmp : rk(A :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HACECpeq HACECpM4).
	assert(HABCDECpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4p5eq HABCDECpp1p2p3p4p5m5).
	assert(HAEmtmp : rk(A :: E :: nil) >= 1) by (solve_hyps_min HAEeq HAEm1).
	assert(Hincl : incl (A :: E :: nil) (list_inter (A :: C :: E :: Cp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: C :: E :: Cp :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: E :: Cp :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: C :: E :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: C :: E :: Cp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: E :: nil) 5 1 4 HABCDECpp1p2p3p4p5mtmp HAEmtmp HACECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Dp ::   de rang : 1 et 2 *)
assert(HABDEp1p2p3p4p5m3 : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HCDpMtmp : rk(C :: Dp :: nil) <= 2) by (solve_hyps_max HCDpeq HCDpM2).
	assert(HABCDEDpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDEDpp1p2p3p4p5eq HABCDEDpp1p2p3p4p5m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Dp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Dp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (C :: Dp :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Dp :: A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((C :: Dp :: nil) ++ (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEDpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDEDpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (C :: Dp :: nil) (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (nil) 5 0 2 HABCDEDpp1p2p3p4p5mtmp Hmtmp HCDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADEp1p2p3p4p5 requis par la preuve de (?)ADEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCECp requis par la preuve de (?)ADEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCCp requis par la preuve de (?)BCECp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDEp1 requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Ap :: p1 ::  de rang :  5 et 6 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 1 et 2 *)
assert(HABDEp1m3 : rk(A :: B :: D :: E :: p1 :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCDEApp1mtmp : rk(A :: B :: C :: D :: E :: Ap :: p1 :: nil) >= 5) by (solve_hyps_min HABCDEApp1eq HABCDEApp1m5).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Ap :: p1 :: nil) (C :: Ap :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: E :: p1 :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDEApp1mtmp;try rewrite HT2 in HABCDEApp1mtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: E :: p1 :: nil) (nil) 5 0 2 HABCDEApp1mtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCCp requis par la preuve de (?)BCCp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et 5*)
assert(HBCCpm2 : rk(B :: C :: Cp :: nil) >= 2).
{
	assert(HABDEp1Mtmp : rk(A :: B :: D :: E :: p1 :: nil) <= 4) by (solve_hyps_max HABDEp1eq HABDEp1M4).
	assert(HABCDECpp1mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: nil) >= 5) by (solve_hyps_min HABCDECpp1eq HABCDECpp1m5).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: nil) (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Cp :: A :: B :: D :: E :: p1 :: nil) ((B :: C :: Cp :: nil) ++ (A :: B :: D :: E :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1mtmp;try rewrite HT2 in HABCDECpp1mtmp.
	assert(HT := rule_2 (B :: C :: Cp :: nil) (A :: B :: D :: E :: p1 :: nil) (B :: nil) 5 1 4 HABCDECpp1mtmp HBmtmp HABDEp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCECp requis par la preuve de (?)BCECp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp ::  de rang :  5 et 6 	 AiB : B :: C :: Cp ::  de rang :  2 et 3 	 A : A :: B :: C :: D :: Cp ::   de rang : 4 et 5 *)
assert(HBCECpm2 : rk(B :: C :: E :: Cp :: nil) >= 2).
{
	assert(HABCDCpMtmp : rk(A :: B :: C :: D :: Cp :: nil) <= 5) by (solve_hyps_max HABCDCpeq HABCDCpM5).
	assert(HABCDECpmtmp : rk(A :: B :: C :: D :: E :: Cp :: nil) >= 5) by (solve_hyps_min HABCDECpeq HABCDECpm5).
	assert(HBCCpmtmp : rk(B :: C :: Cp :: nil) >= 2) by (solve_hyps_min HBCCpeq HBCCpm2).
	assert(Hincl : incl (B :: C :: Cp :: nil) (list_inter (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: nil) (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: D :: Cp :: B :: C :: E :: Cp :: nil) ((A :: B :: C :: D :: Cp :: nil) ++ (B :: C :: E :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpmtmp;try rewrite HT2 in HABCDECpmtmp.
	assert(HT := rule_4 (A :: B :: C :: D :: Cp :: nil) (B :: C :: E :: Cp :: nil) (B :: C :: Cp :: nil) 5 2 5 HABCDECpmtmp HBCCpmtmp HABCDCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -2 et -4*)
assert(HBCECpm3 : rk(B :: C :: E :: Cp :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABCECpp1mtmp : rk(A :: B :: C :: E :: Cp :: p1 :: nil) >= 4) by (solve_hyps_min HABCECpp1eq HABCECpp1m4).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: E :: Cp :: p1 :: nil) (B :: C :: E :: Cp :: A :: B :: p1 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: B :: p1 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: B :: p1 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCECpp1mtmp;try rewrite HT2 in HABCECpp1mtmp.
	assert(HT := rule_2 (B :: C :: E :: Cp :: nil) (A :: B :: p1 :: nil) (B :: nil) 4 1 2 HABCECpp1mtmp HBmtmp HABp1Mtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADEp1p2p3p4p5 requis par la preuve de (?)ADEp1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 5*)
(* ensembles concernés AUB : A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : E ::  de rang :  1 et 1 	 A : B :: C :: E :: Cp ::   de rang : 3 et 4 *)
assert(HADEp1p2p3p4p5m2 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HBCECpMtmp : rk(B :: C :: E :: Cp :: nil) <= 4) by (solve_hyps_max HBCECpeq HBCECpM4).
	assert(HABCDECpp1p2p3p4p5mtmp : rk(A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HABCDECpp1p2p3p4p5eq HABCDECpp1p2p3p4p5m5).
	assert(HEmtmp : rk(E :: nil) >= 1) by (solve_hyps_min HEeq HEm1).
	assert(Hincl : incl (E :: nil) (list_inter (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: E :: Cp :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (B :: C :: E :: Cp :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: E :: Cp :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((B :: C :: E :: Cp :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDECpp1p2p3p4p5mtmp;try rewrite HT2 in HABCDECpp1p2p3p4p5mtmp.
	assert(HT := rule_4 (B :: C :: E :: Cp :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (E :: nil) 5 1 4 HABCDECpp1p2p3p4p5mtmp HEmtmp HBCECpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  3 et 6 	 AiB : A :: p1 ::  de rang :  2 et 2 	 A : A :: B :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p3p4p5m3 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HABp1Mtmp : rk(A :: B :: p1 :: nil) <= 2) by (solve_hyps_max HABp1eq HABp1M2).
	assert(HABDEp1p2p3p4p5mtmp : rk(A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3) by (solve_hyps_min HABDEp1p2p3p4p5eq HABDEp1p2p3p4p5m3).
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hincl : incl (A :: p1 :: nil) (list_inter (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: B :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDEp1p2p3p4p5mtmp;try rewrite HT2 in HABDEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: B :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p1 :: nil) 3 2 2 HABDEp1p2p3p4p5mtmp HAp1mtmp HABp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  5 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : C :: p1 ::   de rang : 2 et 2 *)
assert(HADEp1p2p3p4p5m4 : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HCp1eq : rk(C :: p1 :: nil) = 2) by (apply LCp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1Mtmp : rk(C :: p1 :: nil) <= 2) by (solve_hyps_max HCp1eq HCp1M2).
	assert(HACDEp1p2p3p4p5mtmp : rk(A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 5) by (solve_hyps_min HACDEp1p2p3p4p5eq HACDEp1p2p3p4p5m5).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (C :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((C :: p1 :: nil) ++ (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDEp1p2p3p4p5mtmp;try rewrite HT2 in HACDEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (C :: p1 :: nil) (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p1 :: nil) 5 1 2 HACDEp1p2p3p4p5mtmp Hp1mtmp HCp1Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour AEp1p2p3p4p5 requis par la preuve de (?)AEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour AEp1p2p3p4p5 requis par la preuve de (?)AEp1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour AEp1p2p3p4p5 requis par la preuve de (?)AEp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAEp1p2p3p4p5m2 : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 6) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  4 et 6 	 AiB : p1 ::  de rang :  1 et 1 	 A : D :: p1 ::   de rang : 2 et 2 *)
assert(HAEp1p2p3p4p5m3 : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HDp1eq : rk(D :: p1 :: nil) = 2) by (apply LDp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HDp1Mtmp : rk(D :: p1 :: nil) <= 2) by (solve_hyps_max HDp1eq HDp1M2).
	assert(HADEp1p2p3p4p5mtmp : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HADEp1p2p3p4p5eq HADEp1p2p3p4p5m4).
	assert(Hp1mtmp : rk(p1 :: nil) >= 1) by (solve_hyps_min Hp1eq Hp1m1).
	assert(Hincl : incl (p1 :: nil) (list_inter (D :: p1 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (D :: p1 :: A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: p1 :: A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((D :: p1 :: nil) ++ (A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2p3p4p5mtmp;try rewrite HT2 in HADEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (D :: p1 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p1 :: nil) 4 1 2 HADEp1p2p3p4p5mtmp Hp1mtmp HDp1Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 6) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  4 et 6 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HAEp1p2p3p4p5m4 : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HADEp1p2p3p4p5mtmp : rk(A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HADEp1p2p3p4p5eq HADEp1p2p3p4p5m4).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: D :: p3 :: A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADEp1p2p3p4p5mtmp;try rewrite HT2 in HADEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p3 :: nil) 4 2 2 HADEp1p2p3p4p5mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HAEp1p2p3p4p5M5 : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) <= 5).
{
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HAp1p2p3p5Mtmp : rk(A :: p1 :: p2 :: p3 :: p5 :: nil) <= 4) by (solve_hyps_max HAp1p2p3p5eq HAp1p2p3p5M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: E :: p4 :: nil) (A :: p1 :: p2 :: p3 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: E :: p4 :: A :: p1 :: p2 :: p3 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p4 :: A :: p1 :: p2 :: p3 :: p5 :: nil) ((A :: E :: p4 :: nil) ++ (A :: p1 :: p2 :: p3 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: E :: p4 :: nil) (A :: p1 :: p2 :: p3 :: p5 :: nil) (A :: nil) 2 4 1 HAEp4Mtmp HAp1p2p3p5Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour Ap1p2p3p4p5 requis par la preuve de (?)Ap1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour ADp1p2p3p4p5 requis par la preuve de (?)Ap1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Ap1p2p4p5 requis par la preuve de (?)ADp1p2p3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour p1p4p5 requis par la preuve de (?)Ap1p2p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour Ap1p2p4p5 requis par la preuve de (?)Ap1p2p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour Ap1p2p4p5 requis par la preuve de (?)Ap1p2p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp1p2p4p5m2 : rk(A :: p1 :: p2 :: p4 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: p1 :: p2 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: p1 :: p2 :: p4 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAp1p2p4p5M4 : rk(A :: p1 :: p2 :: p4 :: p5 :: nil) <= 4).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp1p4p5Mtmp : rk(p1 :: p4 :: p5 :: nil) <= 3) by (solve_hyps_max Hp1p4p5eq Hp1p4p5M3).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p1 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p4 :: p5 :: nil) (A :: p2 :: p1 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p4 :: p5 :: nil) ((A :: p2 :: nil) ++ (p1 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p1 :: p4 :: p5 :: nil) (nil) 1 3 0 HAp2Mtmp Hp1p4p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 6 pour ADp1p2p3p4p5 requis par la preuve de (?)ADp1p2p3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour ADp1p2p3p4p5 requis par la preuve de (?)ADp1p2p3p4p5 pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour ADp1p2p3p4p5 requis par la preuve de (?)ADp1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HADp1p2p3p4p5m2 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADp1p2p3p4p5m3 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HADp1eq : rk(A :: D :: p1 :: nil) = 3) by (apply LADp1 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HADp1mtmp : rk(A :: D :: p1 :: nil) >= 3) by (solve_hyps_min HADp1eq HADp1m3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: p1 :: nil) (A :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 3 3 HADp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et -2*)
assert(HADp1p2p3p4p5M5 : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) <= 5).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HAp1p2p4p5Mtmp : rk(A :: p1 :: p2 :: p4 :: p5 :: nil) <= 4) by (solve_hyps_max HAp1p2p4p5eq HAp1p2p4p5M4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: D :: p3 :: A :: p1 :: p2 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: p1 :: p2 :: p4 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (A :: p1 :: p2 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p4 :: p5 :: nil) (A :: nil) 2 4 1 HADp3Mtmp HAp1p2p4p5Mtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour Ap1p2p3p4p5 requis par la preuve de (?)Ap1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour p1p3p4p5 requis par la preuve de (?)Ap1p2p3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 6 pour Ap1p2p3p4p5 requis par la preuve de (?)Ap1p2p3p4p5 pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 6 pour Ap1p2p3p4p5 requis par la preuve de (?)Ap1p2p3p4p5 pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAp1p2p3p4p5m2 : rk(A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HAp1mtmp : rk(A :: p1 :: nil) >= 2) by (solve_hyps_min HAp1eq HAp1m2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: p1 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: p1 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) 2 2 HAp1mtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 5 et 5*)
assert(HAp1p2p3p4p5M5 : rk(A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) <= 5).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(Hp1p3p4p5Mtmp : rk(p1 :: p3 :: p4 :: p5 :: nil) <= 4) by (solve_hyps_max Hp1p3p4p5eq Hp1p3p4p5M4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: p2 :: nil) (p1 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p2 :: p1 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p3 :: p4 :: p5 :: nil) ((A :: p2 :: nil) ++ (p1 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: p2 :: nil) (p1 :: p3 :: p4 :: p5 :: nil) (nil) 1 4 0 HAp2Mtmp Hp1p3p4p5Mtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: D :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  3 et 5 	 AiB : A :: p3 ::  de rang :  2 et 2 	 A : A :: D :: p3 ::   de rang : 2 et 2 *)
assert(HAp1p2p3p4p5m3 : rk(A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HADp3Mtmp : rk(A :: D :: p3 :: nil) <= 2) by (solve_hyps_max HADp3eq HADp3M2).
	assert(HADp1p2p3p4p5mtmp : rk(A :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3) by (solve_hyps_min HADp1p2p3p4p5eq HADp1p2p3p4p5m3).
	assert(HAp3mtmp : rk(A :: p3 :: nil) >= 2) by (solve_hyps_min HAp3eq HAp3m2).
	assert(Hincl : incl (A :: p3 :: nil) (list_inter (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: D :: p3 :: A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: p3 :: A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: D :: p3 :: nil) ++ (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HADp1p2p3p4p5mtmp;try rewrite HT2 in HADp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: D :: p3 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p3 :: nil) 3 2 2 HADp1p2p3p4p5mtmp HAp3mtmp HADp3Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : A :: E :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  4 et 5 	 AiB : A :: p4 ::  de rang :  2 et 2 	 A : A :: E :: p4 ::   de rang : 2 et 2 *)
assert(HAp1p2p3p4p5m4 : rk(A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HAEp4Mtmp : rk(A :: E :: p4 :: nil) <= 2) by (solve_hyps_max HAEp4eq HAEp4M2).
	assert(HAEp1p2p3p4p5mtmp : rk(A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HAEp1p2p3p4p5eq HAEp1p2p3p4p5m4).
	assert(HAp4mtmp : rk(A :: p4 :: nil) >= 2) by (solve_hyps_min HAp4eq HAp4m2).
	assert(Hincl : incl (A :: p4 :: nil) (list_inter (A :: E :: p4 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: E :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: E :: p4 :: A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: E :: p4 :: A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: E :: p4 :: nil) ++ (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAEp1p2p3p4p5mtmp;try rewrite HT2 in HAEp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: E :: p4 :: nil) (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p4 :: nil) 4 2 2 HAEp1p2p3p4p5mtmp HAp4mtmp HAEp4Mtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 5 pour p1p2p3p4p5 requis par la preuve de (?)p1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 5 pour p1p2p3p4p5 requis par la preuve de (?)p1p2p3p4p5 pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 5 pour p1p2p3p4p5 requis par la preuve de (?)p1p2p3p4p5 pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 5) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  2 et 5 	 AiB : p2 ::  de rang :  1 et 1 	 A : A :: p2 ::   de rang : 1 et 1 *)
assert(Hp1p2p3p4p5m2 : rk(p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2).
{
	assert(HAp2Mtmp : rk(A :: p2 :: nil) <= 1) by (solve_hyps_max HAp2eq HAp2M1).
	assert(HAp1p2p3p4p5mtmp : rk(A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 2) by (solve_hyps_min HAp1p2p3p4p5eq HAp1p2p3p4p5m2).
	assert(Hp2mtmp : rk(p2 :: nil) >= 1) by (solve_hyps_min Hp2eq Hp2m1).
	assert(Hincl : incl (p2 :: nil) (list_inter (A :: p2 :: nil) (p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p2 :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: p2 :: nil) ++ (p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAp1p2p3p4p5mtmp;try rewrite HT2 in HAp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: p2 :: nil) (p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p2 :: nil) 2 1 1 HAp1p2p3p4p5mtmp Hp2mtmp HAp2Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  3 et 5 	 AiB : p2 :: p3 ::  de rang :  2 et 2 	 A : A :: p2 :: p3 ::   de rang : 2 et 2 *)
assert(Hp1p2p3p4p5m3 : rk(p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3).
{
	assert(HAp2p3eq : rk(A :: p2 :: p3 :: nil) = 2) by (apply LAp2p3 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAp2p3Mtmp : rk(A :: p2 :: p3 :: nil) <= 2) by (solve_hyps_max HAp2p3eq HAp2p3M2).
	assert(HAp1p2p3p4p5mtmp : rk(A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 3) by (solve_hyps_min HAp1p2p3p4p5eq HAp1p2p3p4p5m3).
	assert(Hp2p3eq : rk(p2 :: p3 :: nil) = 2) by (apply Lp2p3 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(Hp2p3mtmp : rk(p2 :: p3 :: nil) >= 2) by (solve_hyps_min Hp2p3eq Hp2p3m2).
	assert(Hincl : incl (p2 :: p3 :: nil) (list_inter (A :: p2 :: p3 :: nil) (p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p2 :: p3 :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p3 :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: p2 :: p3 :: nil) ++ (p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAp1p2p3p4p5mtmp;try rewrite HT2 in HAp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: p2 :: p3 :: nil) (p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p2 :: p3 :: nil) 3 2 2 HAp1p2p3p4p5mtmp Hp2p3mtmp HAp2p3Mtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 5) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: p1 :: p2 :: p3 :: p4 :: p5 ::  de rang :  4 et 5 	 AiB : p2 :: p4 ::  de rang :  2 et 2 	 A : A :: p2 :: p4 ::   de rang : 2 et 2 *)
assert(Hp1p2p3p4p5m4 : rk(p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4).
{
	assert(HAp2p4eq : rk(A :: p2 :: p4 :: nil) = 2) by (apply LAp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HAp2p4Mtmp : rk(A :: p2 :: p4 :: nil) <= 2) by (solve_hyps_max HAp2p4eq HAp2p4M2).
	assert(HAp1p2p3p4p5mtmp : rk(A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 4) by (solve_hyps_min HAp1p2p3p4p5eq HAp1p2p3p4p5m4).
	assert(Hp2p4eq : rk(p2 :: p4 :: nil) = 2) by (apply Lp2p4 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(Hp2p4mtmp : rk(p2 :: p4 :: nil) >= 2) by (solve_hyps_min Hp2p4eq Hp2p4m2).
	assert(Hincl : incl (p2 :: p4 :: nil) (list_inter (A :: p2 :: p4 :: nil) (p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (A :: p2 :: p4 :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: p2 :: p4 :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((A :: p2 :: p4 :: nil) ++ (p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAp1p2p3p4p5mtmp;try rewrite HT2 in HAp1p2p3p4p5mtmp.
	assert(HT := rule_4 (A :: p2 :: p4 :: nil) (p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p2 :: p4 :: nil) 4 2 2 HAp1p2p3p4p5mtmp Hp2p4mtmp HAp2p4Mtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(Hp1p2p3p4p5M4 : rk(p1 :: p2 :: p3 :: p4 :: p5 :: nil) <= 4).
{
	assert(HCp1p2p3p4p5eq : rk(C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) = 5) by (apply LCp1p2p3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCp1p2p3p4p5Mtmp : rk(C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) <= 5) by (solve_hyps_max HCp1p2p3p4p5eq HCp1p2p3p4p5M5).
	assert(HApBpCpDpEpp1p2p3p4p5eq : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) = 5) by (apply LApBpCpDpEpp1p2p3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HApBpCpDpEpp1p2p3p4p5Mtmp : rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) <= 5) by (solve_hyps_max HApBpCpDpEpp1p2p3p4p5eq HApBpCpDpEpp1p2p3p4p5M5).
	assert(HCApBpCpDpEpp1p2p3p4p5eq : rk(C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) = 6) by (apply LCApBpCpDpEpp1p2p3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption).
	assert(HCApBpCpDpEpp1p2p3p4p5mtmp : rk(C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) >= 6) by (solve_hyps_min HCApBpCpDpEpp1p2p3p4p5eq HCApBpCpDpEpp1p2p3p4p5m6).
	assert(Hincl : incl (p1 :: p2 :: p3 :: p4 :: p5 :: nil) (list_inter (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (C :: p1 :: p2 :: p3 :: p4 :: p5 :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: p1 :: p2 :: p3 :: p4 :: p5 :: Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ((C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) ++ (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApBpCpDpEpp1p2p3p4p5mtmp;try rewrite HT2 in HCApBpCpDpEpp1p2p3p4p5mtmp.
	assert(HT := rule_3 (C :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (Ap :: Bp :: Cp :: Dp :: Ep :: p1 :: p2 :: p3 :: p4 :: p5 :: nil) (p1 :: p2 :: p3 :: p4 :: p5 :: nil) 5 5 6 HCp1p2p3p4p5Mtmp HApBpCpDpEpp1p2p3p4p5Mtmp HCApBpCpDpEpp1p2p3p4p5mtmp Hincl);apply HT.
}


assert(Hp1p2p3p4p5M : rk(p1 :: p2 :: p3 :: p4 :: p5 ::  nil) <= 5) (* dim : 5 *) by (solve_hyps_max Hp1p2p3p4p5eq Hp1p2p3p4p5M5).
assert(Hp1p2p3p4p5m : rk(p1 :: p2 :: p3 :: p4 :: p5 ::  nil) >= 1) by (solve_hyps_min Hp1p2p3p4p5eq Hp1p2p3p4p5m1).
intuition.
Qed.

(* dans la couche 0 *)
Theorem def_Conclusion : forall A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 ,
rk(A :: B :: C :: D :: E ::  nil) = 5 -> rk(Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 5 -> rk(A :: B :: C :: D :: E :: Ap :: Bp :: Cp :: Dp :: Ep ::  nil) = 6 ->
rk(A :: p1 ::  nil) = 2 -> rk(A :: B :: p1 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p1 ::  nil) = 5 ->
rk(A :: p2 ::  nil) = 1 -> rk(A :: C :: p2 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p2 ::  nil) = 5 ->
rk(A :: p3 ::  nil) = 2 -> rk(A :: D :: p3 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p3 ::  nil) = 5 ->
rk(A :: p4 ::  nil) = 2 -> rk(A :: E :: p4 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p4 ::  nil) = 5 ->
rk(B :: C :: p5 ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp :: Ep :: p5 ::  nil) = 5 -> 
	 rk(p1 :: p2 :: p3 :: p4 :: p5 ::  nil) = 4  .
Proof.

intros A B C D E Ap Bp Cp Dp Ep p1 p2 p3 p4 p5 
HABCDEeq HApBpCpDpEpeq HABCDEApBpCpDpEpeq HAp1eq HABp1eq HApBpCpDpEpp1eq HAp2eq HACp2eq HApBpCpDpEpp2eq HAp3eq
HADp3eq HApBpCpDpEpp3eq HAp4eq HAEp4eq HApBpCpDpEpp4eq HBCp5eq HApBpCpDpEpp5eq .
repeat split.

	apply Lp1p2p3p4p5 with (A := A) (B := B) (C := C) (D := D) (E := E) (Ap := Ap) (Bp := Bp) (Cp := Cp) (Dp := Dp) (Ep := Ep) (p1 := p1) (p2 := p2) (p3 := p3) (p4 := p4) (p5 := p5) ; assumption.
Qed .
