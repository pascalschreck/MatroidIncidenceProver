Require Import lemmas_automation_g.


(* dans la couche 0 *)
Lemma LA : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HAM : rk(A ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HAeq HAM1).
assert(HAm : rk(A ::  nil) >= 1) by (solve_hyps_min HAeq HAm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LB : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBM : rk(B ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBeq HBM1).
assert(HBm : rk(B ::  nil) >= 1) by (solve_hyps_min HBeq HBm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LC : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(C ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HCM : rk(C ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCeq HCM1).
assert(HCm : rk(C ::  nil) >= 1) by (solve_hyps_min HCeq HCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HApM : rk(Ap ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HApeq HApM1).
assert(HApm : rk(Ap ::  nil) >= 1) by (solve_hyps_min HApeq HApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCAp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HABCApM : rk(A :: B :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApm : rk(A :: B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HABCApeq HABCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bp ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBpM : rk(Bp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBpeq HBpM1).
assert(HBpm : rk(Bp ::  nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HABCBpM : rk(A :: B :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpm : rk(A :: B :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HABCBpeq HABCBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBp requis par la preuve de (?)ABCApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpm4 : rk(A :: B :: C :: Ap :: Bp :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpM : rk(A :: B :: C :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpm : rk(A :: B :: C :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HABCApBpeq HABCApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Cp ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HCpM : rk(Cp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCpeq HCpM1).
assert(HCpm : rk(Cp ::  nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpCp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HAApBpCpM : rk(A :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpm : rk(A :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HAApBpCpeq HAApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApBpCp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBApBpCpM : rk(B :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApBpCpm : rk(B :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HBApBpCpeq HBApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(As ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HAsM : rk(As ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HAseq HAsM1).
assert(HAsm : rk(As ::  nil) >= 1) by (solve_hyps_min HAseq HAsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCAs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: As ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HABCAsM : rk(A :: B :: C :: As ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCAsm : rk(A :: B :: C :: As ::  nil) >= 1) by (solve_hyps_min HABCAseq HABCAsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApAs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: C :: Ap :: As ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBCApAsM : rk(B :: C :: Ap :: As ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApAsm : rk(B :: C :: Ap :: As ::  nil) >= 1) by (solve_hyps_min HBCApAseq HBCApAsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApAs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAs requis par la preuve de (?)ABCApAs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsm4 : rk(A :: B :: C :: Ap :: As :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsM : rk(A :: B :: C :: Ap :: As ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsm : rk(A :: B :: C :: Ap :: As ::  nil) >= 1) by (solve_hyps_min HABCApAseq HABCApAsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpAs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: C :: Bp :: As ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBCBpAsM : rk(B :: C :: Bp :: As ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpAsm : rk(B :: C :: Bp :: As ::  nil) >= 1) by (solve_hyps_min HBCBpAseq HBCBpAsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAs requis par la preuve de (?)ABCBpAs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsm4 : rk(A :: B :: C :: Bp :: As :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsM : rk(A :: B :: C :: Bp :: As ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsm : rk(A :: B :: C :: Bp :: As ::  nil) >= 1) by (solve_hyps_min HABCBpAseq HABCBpAsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpAs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: As ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAs requis par la preuve de (?)ABCApBpAs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsm4 : rk(A :: B :: C :: Ap :: Bp :: As :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpAsM : rk(A :: B :: C :: Ap :: Bp :: As ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpAsm : rk(A :: B :: C :: Ap :: Bp :: As ::  nil) >= 1) by (solve_hyps_min HABCApBpAseq HABCApBpAsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpCpAs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: As ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HApBpCpAsM : rk(Ap :: Bp :: Cp :: As ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpAsm : rk(Ap :: Bp :: Cp :: As ::  nil) >= 1) by (solve_hyps_min HApBpCpAseq HApBpCpAsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpCpAs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: Cp :: As ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpAs requis par la preuve de (?)AApBpCpAs pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpAs requis par la preuve de (?)AApBpCpAs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAs requis par la preuve de (?)ABCApBpCpAs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpAs pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)AApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)ABCApBpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalpham4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BCalpha requis par la preuve de (?)AApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -1 et 5*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpAs requis par la preuve de (?)AApBpCpAs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: As ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpAsm2 : rk(A :: Ap :: Bp :: Cp :: As :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpAsmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: nil) >= 4) by (solve_hyps_min HABCApBpCpAseq HABCApBpCpAsm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: As :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: As :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpAsmtmp;try rewrite HT2 in HABCApBpCpAsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpAsmtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpAsM1. try clear HABCApBpCpAsM2. try clear HABCApBpCpAsM3. try clear HABCApBpCpAsm4. try clear HABCApBpCpAsm3. try clear HABCApBpCpAsm2. try clear HABCApBpCpAsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpAsm4 : rk(A :: Ap :: Bp :: Cp :: As :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


assert(HAApBpCpAsM : rk(A :: Ap :: Bp :: Cp :: As ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpAsm : rk(A :: Ap :: Bp :: Cp :: As ::  nil) >= 1) by (solve_hyps_min HAApBpCpAseq HAApBpCpAsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpAs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: As ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAs requis par la preuve de (?)ABCApBpCpAs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpCpAsM : rk(A :: B :: C :: Ap :: Bp :: Cp :: As ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpAsm : rk(A :: B :: C :: Ap :: Bp :: Cp :: As ::  nil) >= 1) by (solve_hyps_min HABCApBpCpAseq HABCApBpCpAsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bs ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBsM : rk(Bs ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBseq HBsM1).
assert(HBsm : rk(Bs ::  nil) >= 1) by (solve_hyps_min HBseq HBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HABCBsM : rk(A :: B :: C :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBsm : rk(A :: B :: C :: Bs ::  nil) >= 1) by (solve_hyps_min HABCBseq HABCBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBs requis par la preuve de (?)ABCBpBs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsm4 : rk(A :: B :: C :: Bp :: Bs :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpBsM : rk(A :: B :: C :: Bp :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpBsm : rk(A :: B :: C :: Bp :: Bs ::  nil) >= 1) by (solve_hyps_min HABCBpBseq HABCBpBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpBs requis par la preuve de (?)ABCApBpBs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpBsm4 : rk(A :: B :: C :: Ap :: Bp :: Bs :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Bs :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Bs :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpBsM : rk(A :: B :: C :: Ap :: Bp :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpBsm : rk(A :: B :: C :: Ap :: Bp :: Bs ::  nil) >= 1) by (solve_hyps_min HABCApBpBseq HABCApBpBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpCpBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HApBpCpBsM : rk(Ap :: Bp :: Cp :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpBsm : rk(Ap :: Bp :: Cp :: Bs ::  nil) >= 1) by (solve_hyps_min HApBpCpBseq HApBpCpBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpCpBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: Cp :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpBs requis par la preuve de (?)AApBpCpBs pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpBs requis par la preuve de (?)AApBpCpBs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpBs requis par la preuve de (?)ABCApBpCpBs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpBsm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpBs pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)AApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)ABCApBpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalpham4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BCalpha requis par la preuve de (?)AApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -1 et 5*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpBs requis par la preuve de (?)AApBpCpBs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: Bs ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpBsm2 : rk(A :: Ap :: Bp :: Cp :: Bs :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpBsmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: nil) >= 4) by (solve_hyps_min HABCApBpCpBseq HABCApBpCpBsm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: Bs :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: Bs :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: Bs :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpBsmtmp;try rewrite HT2 in HABCApBpCpBsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpBsmtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpBsM1. try clear HABCApBpCpBsM2. try clear HABCApBpCpBsM3. try clear HABCApBpCpBsm4. try clear HABCApBpCpBsm3. try clear HABCApBpCpBsm2. try clear HABCApBpCpBsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpBsm4 : rk(A :: Ap :: Bp :: Cp :: Bs :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


assert(HAApBpCpBsM : rk(A :: Ap :: Bp :: Cp :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpBsm : rk(A :: Ap :: Bp :: Cp :: Bs ::  nil) >= 1) by (solve_hyps_min HAApBpCpBseq HAApBpCpBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpBs requis par la preuve de (?)ABCApBpCpBs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpBsm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpCpBsM : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpBsm : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs ::  nil) >= 1) by (solve_hyps_min HABCApBpCpBseq HABCApBpCpBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApAsBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: As :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HAApAsBsM : rk(A :: Ap :: As :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApAsBsm : rk(A :: Ap :: As :: Bs ::  nil) >= 1) by (solve_hyps_min HAApAsBseq HAApAsBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpAsBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Bp :: As :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HABpAsBsM : rk(A :: Bp :: As :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpAsBsm : rk(A :: Bp :: As :: Bs ::  nil) >= 1) by (solve_hyps_min HABpAsBseq HABpAsBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpAsBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: As :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBBpAsBsM : rk(B :: Bp :: As :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpAsBsm : rk(B :: Bp :: As :: Bs ::  nil) >= 1) by (solve_hyps_min HBBpAsBseq HBBpAsBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBpAsBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: Bp :: As :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpAsBs requis par la preuve de (?)ABBpAsBs pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBs requis par la preuve de (?)ABBpAsBs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBs requis par la preuve de (?)ABCBpAsBs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsm4 : rk(A :: B :: C :: Bp :: As :: Bs :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAs requis par la preuve de (?)ABBpAsBs pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpAsBs requis par la preuve de (?)ABBpAsBs pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBs requis par la preuve de (?)ABBpAsBs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBs requis par la preuve de (?)ABCApBpAsBs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsm4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBpAsBs pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)ABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)ABCApBpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalpham4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BCalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HABBpm2 : rk(A :: B :: Bp :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: B :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApBpalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpAsBs requis par la preuve de (?)ABBpAsBs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs ::  de rang :  4 et 4 	 AiB : A :: B :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HABBpAsBsm2 : rk(A :: B :: Bp :: As :: Bs :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsmtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HABCApBpAsBseq HABCApBpAsBsm4).
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 2) by (solve_hyps_min HABBpeq HABBpm2).
	assert(Hincl : incl (A :: B :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: As :: Bs :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: nil) (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: As :: Bs :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: As :: Bs :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: B :: Bp :: As :: Bs :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsmtmp;try rewrite HT2 in HABCApBpAsBsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: As :: Bs :: nil) (A :: B :: Bp :: nil) 4 2 4 HABCApBpAsBsmtmp HABBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsBsM1. try clear HABCApBpAsBsM2. try clear HABCApBpAsBsM3. try clear HABCApBpAsBsm4. try clear HABCApBpAsBsm3. try clear HABCApBpAsBsm2. try clear HABCApBpAsBsm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : C :: As ::   de rang : 1 et 2 *)
assert(HABBpAsBsm3 : rk(A :: B :: Bp :: As :: Bs :: nil) >= 3).
{
	assert(HCAsMtmp : rk(C :: As :: nil) <= 2) by (solve_hyps_max HCAseq HCAsM2).
	assert(HABCBpAsBsmtmp : rk(A :: B :: C :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HABCBpAsBseq HABCBpAsBsm4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (C :: As :: nil) (A :: B :: Bp :: As :: Bs :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: nil) (C :: As :: A :: B :: Bp :: As :: Bs :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: As :: A :: B :: Bp :: As :: Bs :: nil) ((C :: As :: nil) ++ (A :: B :: Bp :: As :: Bs :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsmtmp;try rewrite HT2 in HABCBpAsBsmtmp.
	assert(HT := rule_4 (C :: As :: nil) (A :: B :: Bp :: As :: Bs :: nil) (As :: nil) 4 1 2 HABCBpAsBsmtmp HAsmtmp HCAsMtmp Hincl); apply HT.
}
try clear HABCBpAsBsM1. try clear HABCBpAsBsM2. try clear HABCBpAsBsM3. try clear HABCBpAsBsm4. try clear HABCBpAsBsm3. try clear HABCBpAsBsm2. try clear HABCBpAsBsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABBpAsBsm4 : rk(A :: B :: Bp :: As :: Bs :: nil) >= 4).
{
	try assert(HABpAsBseq : rk(A :: Bp :: As :: Bs :: nil) = 4) by (apply LABpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABpAsBsmtmp : rk(A :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HABpAsBseq HABpAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: As :: Bs :: nil) (A :: B :: Bp :: As :: Bs :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: As :: Bs :: nil) (A :: B :: Bp :: As :: Bs :: nil) 4 4 HABpAsBsmtmp Hcomp Hincl);apply HT.
}


assert(HABBpAsBsM : rk(A :: B :: Bp :: As :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBpAsBsm : rk(A :: B :: Bp :: As :: Bs ::  nil) >= 1) by (solve_hyps_min HABBpAsBseq HABBpAsBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAsBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBs requis par la preuve de (?)ABCBpAsBs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsm4 : rk(A :: B :: C :: Bp :: As :: Bs :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsBsM : rk(A :: B :: C :: Bp :: As :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsBsm : rk(A :: B :: C :: Bp :: As :: Bs ::  nil) >= 1) by (solve_hyps_min HABCBpAsBseq HABCBpAsBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpAsBs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: As :: Bs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBs requis par la preuve de (?)ABCApBpAsBs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsm4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpAsBsM : rk(A :: B :: C :: Ap :: Bp :: As :: Bs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpAsBsm : rk(A :: B :: C :: Ap :: Bp :: As :: Bs ::  nil) >= 1) by (solve_hyps_min HABCApBpAsBseq HABCApBpAsBsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Cs ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HCsM : rk(Cs ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCseq HCsM1).
assert(HCsm : rk(Cs ::  nil) >= 1) by (solve_hyps_min HCseq HCsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApAsCs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: As :: Cs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HAApAsCsM : rk(A :: Ap :: As :: Cs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApAsCsm : rk(A :: Ap :: As :: Cs ::  nil) >= 1) by (solve_hyps_min HAApAsCseq HAApAsCsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpAsCs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Bp :: As :: Cs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HABpAsCsM : rk(A :: Bp :: As :: Cs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpAsCsm : rk(A :: Bp :: As :: Cs ::  nil) >= 1) by (solve_hyps_min HABpAsCseq HABpAsCsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpBsCs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: Bs :: Cs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBBpBsCsM : rk(B :: Bp :: Bs :: Cs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpBsCsm : rk(B :: Bp :: Bs :: Cs ::  nil) >= 1) by (solve_hyps_min HBBpBsCseq HBBpBsCsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpAsBsCs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bp :: As :: Bs :: Cs ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBpAsBsCsM : rk(Bp :: As :: Bs :: Cs ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpAsBsCsm : rk(Bp :: As :: Bs :: Cs ::  nil) >= 1) by (solve_hyps_min HBpAsBsCseq HBpAsBsCsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(alpha ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HalphaM : rk(alpha ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Halphaeq HalphaM1).
assert(Halpham : rk(alpha ::  nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LAalpha *)
(* dans la couche 0 *)
Lemma LABCApalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalpha requis par la preuve de (?)ABCApalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalpham4 : rk(A :: B :: C :: Ap :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApalphaM : rk(A :: B :: C :: Ap :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApalpham : rk(A :: B :: C :: Ap :: alpha ::  nil) >= 1) by (solve_hyps_min HABCApalphaeq HABCApalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LAalpha *)
(* dans la couche 0 *)
Lemma LAalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: alpha ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)Aalpha pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)ABCApBpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalpham4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BCalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aalpha requis par la preuve de (?)Aalpha pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HAalpham2 : rk(A :: alpha :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApalphaeq : rk(A :: B :: C :: Ap :: alpha :: nil) = 4) by (apply LABCApalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApalphamtmp : rk(A :: B :: C :: Ap :: alpha :: nil) >= 4) by (solve_hyps_min HABCApalphaeq HABCApalpham4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (A :: alpha :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: alpha :: nil) (A :: alpha :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: alpha :: B :: C :: Ap :: alpha :: nil) ((A :: alpha :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApalphamtmp;try rewrite HT2 in HABCApalphamtmp.
	assert(HT := rule_2 (A :: alpha :: nil) (B :: C :: Ap :: alpha :: nil) (alpha :: nil) 4 1 3 HABCApalphamtmp Halphamtmp HBCApalphaMtmp Hincl);apply HT.
}


assert(HAalphaM : rk(A :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAalphaeq HAalphaM2).
assert(HAalpham : rk(A :: alpha ::  nil) >= 1) by (solve_hyps_min HAalphaeq HAalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LBalpha *)
(* dans la couche 0 *)
Lemma LBApBpCpalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Ap :: Bp :: Cp :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApBpCpalpha requis par la preuve de (?)BApBpCpalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpalpha requis par la preuve de (?)BApBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpalpha requis par la preuve de (?)ABCApBpCpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpalpham4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApBp requis par la preuve de (?)BApBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)BApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)ABCApBpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalpham4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCalpha requis par la preuve de (?)BApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApBp requis par la preuve de (?)ABCalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCalpha requis par la preuve de (?)ABCalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BCalpha requis par la preuve de (?)ABCalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCalpha requis par la preuve de (?)ABCalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HABCalphaM3 : rk(A :: B :: C :: alpha :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: alpha :: nil) (A :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: alpha :: nil) ((A :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HAMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: Bp ::   de rang : 1 et 2 *)
assert(HABCalpham2 : rk(A :: B :: C :: alpha :: nil) >= 2).
{
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: nil) (A :: B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (Ap :: Bp :: A :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: A :: B :: C :: alpha :: nil) ((Ap :: Bp :: nil) ++ (A :: B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (A :: B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HApBpMtmp Hincl); apply HT.
}
try clear HApBpM1. try clear HApBpM2. try clear HApBpM3. try clear HApBpm4. try clear HApBpm3. try clear HApBpm2. try clear HApBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApBp requis par la preuve de (?)BApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HBApBpm2 : rk(B :: Ap :: Bp :: nil) >= 2).
{
	assert(HABCalphaMtmp : rk(A :: B :: C :: alpha :: nil) <= 3) by (solve_hyps_max HABCalphaeq HABCalphaM3).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Ap :: Bp :: nil) (A :: B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (B :: Ap :: Bp :: A :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Bp :: A :: B :: C :: alpha :: nil) ((B :: Ap :: Bp :: nil) ++ (A :: B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (B :: Ap :: Bp :: nil) (A :: B :: C :: alpha :: nil) (B :: nil) 4 1 3 HABCApBpalphamtmp HBmtmp HABCalphaMtmp Hincl);apply HT.
}
try clear HABCalphaM1. try clear HABCalphaM2. try clear HABCalphaM3. try clear HABCalpham4. try clear HABCalpham3. try clear HABCalpham2. try clear HABCalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApBpCpalpha requis par la preuve de (?)BApBpCpalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: alpha ::  de rang :  4 et 4 	 AiB : B :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBApBpCpalpham2 : rk(B :: Ap :: Bp :: Cp :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpCpalphaeq HABCApBpCpalpham4).
	assert(HBApBpmtmp : rk(B :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HBApBpeq HBApBpm2).
	assert(Hincl : incl (B :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: Ap :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: Ap :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: Ap :: Bp :: Cp :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: Ap :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpalphamtmp;try rewrite HT2 in HABCApBpCpalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: Ap :: Bp :: Cp :: alpha :: nil) (B :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpalphamtmp HBApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HBApBpM1. try clear HBApBpM2. try clear HBApBpM3. try clear HBApBpm4. try clear HBApBpm3. try clear HBApBpm2. try clear HBApBpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApBpCpalpham4 : rk(B :: Ap :: Bp :: Cp :: alpha :: nil) >= 4).
{
	try assert(HBApBpCpeq : rk(B :: Ap :: Bp :: Cp :: nil) = 4) by (apply LBApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBApBpCpmtmp : rk(B :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HBApBpCpeq HBApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Bp :: Cp :: nil) (B :: Ap :: Bp :: Cp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Bp :: Cp :: nil) (B :: Ap :: Bp :: Cp :: alpha :: nil) 4 4 HBApBpCpmtmp Hcomp Hincl);apply HT.
}
try clear HBApBpCpM1. try clear HBApBpCpM2. try clear HBApBpCpM3. try clear HBApBpCpm4. try clear HBApBpCpm3. try clear HBApBpCpm2. try clear HBApBpCpm1. 

assert(HBApBpCpalphaM : rk(B :: Ap :: Bp :: Cp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApBpCpalpham : rk(B :: Ap :: Bp :: Cp :: alpha ::  nil) >= 1) by (solve_hyps_min HBApBpCpalphaeq HBApBpCpalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LBalpha *)
(* dans constructLemma(), requis par LApBpCpalpha *)
(* dans la couche 0 *)
Lemma LAApBpCpalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: Cp :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpalpha requis par la preuve de (?)AApBpCpalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpalpha requis par la preuve de (?)AApBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpalpha requis par la preuve de (?)ABCApBpCpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpalpham4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)AApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)ABCApBpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalpham4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BCalpha requis par la preuve de (?)AApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -1 et 5*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpalpha requis par la preuve de (?)AApBpCpalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: alpha ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpalpham2 : rk(A :: Ap :: Bp :: Cp :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpCpalphaeq HABCApBpCpalpham4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpalphamtmp;try rewrite HT2 in HABCApBpCpalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: alpha :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpalphamtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpalpham4 : rk(A :: Ap :: Bp :: Cp :: alpha :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: alpha :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


assert(HAApBpCpalphaM : rk(A :: Ap :: Bp :: Cp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpalpham : rk(A :: Ap :: Bp :: Cp :: alpha ::  nil) >= 1) by (solve_hyps_min HAApBpCpalphaeq HAApBpCpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpCpalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: alpha ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpCpalpha requis par la preuve de (?)ApBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AApBpCpAsalpha requis par la preuve de (?)ApBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpAsalpha requis par la preuve de (?)AApBpCpAsalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpAsalpha requis par la preuve de (?)AApBpCpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAsalpha requis par la preuve de (?)ABCApBpCpAsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsalpham4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)AApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)ABCApBpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalpham4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BCalpha requis par la preuve de (?)AApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 -1 et 5*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpAsalpha requis par la preuve de (?)AApBpCpAsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpAsalpham2 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpAsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpCpAsalphaeq HABCApBpCpAsalpham4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpAsalphamtmp;try rewrite HT2 in HABCApBpCpAsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpAsalphamtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpAsalphaM1. try clear HABCApBpCpAsalphaM2. try clear HABCApBpCpAsalphaM3. try clear HABCApBpCpAsalpham4. try clear HABCApBpCpAsalpham3. try clear HABCApBpCpAsalpham2. try clear HABCApBpCpAsalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpAsalpham4 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)ApBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpCpalpha requis par la preuve de (?)ApBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BpCpalpha requis par la preuve de (?)ApBpCpalpha pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpCpalpha requis par la preuve de (?)ApBpCpalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HApBpCpalphaM3 : rk(Ap :: Bp :: Cp :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HBpCpalphaMtmp : rk(Bp :: Cp :: alpha :: nil) <= 2) by (solve_hyps_max HBpCpalphaeq HBpCpalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: alpha :: nil) (Ap :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: alpha :: nil) ((Ap :: nil) ++ (Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (Bp :: Cp :: alpha :: nil) (nil) 1 2 0 HApMtmp HBpCpalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: Ap :: Bp :: Cp :: As :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HApBpCpalpham2 : rk(Ap :: Bp :: Cp :: alpha :: nil) >= 2).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HAApBpCpAsalphamtmp : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HAApBpCpAsalphaeq HAApBpCpAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: As :: nil) (Ap :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: As :: alpha :: nil) (A :: As :: Ap :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: Ap :: Bp :: Cp :: alpha :: nil) ((A :: As :: nil) ++ (Ap :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpAsalphamtmp;try rewrite HT2 in HAApBpCpAsalphamtmp.
	assert(HT := rule_4 (A :: As :: nil) (Ap :: Bp :: Cp :: alpha :: nil) (nil) 4 0 2 HAApBpCpAsalphamtmp Hmtmp HAAsMtmp Hincl); apply HT.
}
try clear HAApBpCpAsalphaM1. try clear HAApBpCpAsalphaM2. try clear HAApBpCpAsalphaM3. try clear HAApBpCpAsalpham4. try clear HAApBpCpAsalpham3. try clear HAApBpCpAsalpham2. try clear HAApBpCpAsalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: Cp :: alpha ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : A :: alpha ::   de rang : 2 et 2 *)
assert(HApBpCpalpham3 : rk(Ap :: Bp :: Cp :: alpha :: nil) >= 3).
{
	try assert(HAalphaeq : rk(A :: alpha :: nil) = 2) by (apply LAalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAalphaMtmp : rk(A :: alpha :: nil) <= 2) by (solve_hyps_max HAalphaeq HAalphaM2).
	try assert(HAApBpCpalphaeq : rk(A :: Ap :: Bp :: Cp :: alpha :: nil) = 4) by (apply LAApBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpalphamtmp : rk(A :: Ap :: Bp :: Cp :: alpha :: nil) >= 4) by (solve_hyps_min HAApBpCpalphaeq HAApBpCpalpham4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (A :: alpha :: nil) (Ap :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: alpha :: nil) (A :: alpha :: Ap :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: alpha :: Ap :: Bp :: Cp :: alpha :: nil) ((A :: alpha :: nil) ++ (Ap :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpalphamtmp;try rewrite HT2 in HAApBpCpalphamtmp.
	assert(HT := rule_4 (A :: alpha :: nil) (Ap :: Bp :: Cp :: alpha :: nil) (alpha :: nil) 4 1 2 HAApBpCpalphamtmp Halphamtmp HAalphaMtmp Hincl); apply HT.
}


assert(HApBpCpalphaM : rk(Ap :: Bp :: Cp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpalpham : rk(Ap :: Bp :: Cp :: alpha ::  nil) >= 1) by (solve_hyps_min HApBpCpalphaeq HApBpCpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: alpha ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Balpha requis par la preuve de (?)Balpha pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBalpham2 : rk(B :: alpha :: nil) >= 2).
{
	try assert(HApBpCpalphaeq : rk(Ap :: Bp :: Cp :: alpha :: nil) = 3) by (apply LApBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpCpalphaMtmp : rk(Ap :: Bp :: Cp :: alpha :: nil) <= 3) by (solve_hyps_max HApBpCpalphaeq HApBpCpalphaM3).
	try assert(HBApBpCpalphaeq : rk(B :: Ap :: Bp :: Cp :: alpha :: nil) = 4) by (apply LBApBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBApBpCpalphamtmp : rk(B :: Ap :: Bp :: Cp :: alpha :: nil) >= 4) by (solve_hyps_min HBApBpCpalphaeq HBApBpCpalpham4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (B :: alpha :: nil) (Ap :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: Cp :: alpha :: nil) (B :: alpha :: Ap :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: alpha :: Ap :: Bp :: Cp :: alpha :: nil) ((B :: alpha :: nil) ++ (Ap :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApBpCpalphamtmp;try rewrite HT2 in HBApBpCpalphamtmp.
	assert(HT := rule_2 (B :: alpha :: nil) (Ap :: Bp :: Cp :: alpha :: nil) (alpha :: nil) 4 1 3 HBApBpCpalphamtmp Halphamtmp HApBpCpalphaMtmp Hincl);apply HT.
}


assert(HBalphaM : rk(B :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBalphaeq HBalphaM2).
assert(HBalpham : rk(B :: alpha ::  nil) >= 1) by (solve_hyps_min HBalphaeq HBalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: C :: alpha ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBCalphaM : rk(B :: C :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCalphaeq HBCalphaM3).
assert(HBCalpham : rk(B :: C :: alpha ::  nil) >= 1) by (solve_hyps_min HBCalphaeq HBCalpham1).
intuition.
Qed.

(* dans constructLemma(), requis par LApalpha *)
(* dans la couche 0 *)
Lemma LBCApalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: C :: Ap :: alpha ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)ABCApBpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalpham4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: alpha ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : A :: alpha ::   de rang : 2 et 2 *)
assert(HBCApalpham3 : rk(B :: C :: Ap :: alpha :: nil) >= 3).
{
	try assert(HAalphaeq : rk(A :: alpha :: nil) = 2) by (apply LAalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAalphaMtmp : rk(A :: alpha :: nil) <= 2) by (solve_hyps_max HAalphaeq HAalphaM2).
	try assert(HABCApalphaeq : rk(A :: B :: C :: Ap :: alpha :: nil) = 4) by (apply LABCApalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApalphamtmp : rk(A :: B :: C :: Ap :: alpha :: nil) >= 4) by (solve_hyps_min HABCApalphaeq HABCApalpham4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (A :: alpha :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: alpha :: nil) (A :: alpha :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: alpha :: B :: C :: Ap :: alpha :: nil) ((A :: alpha :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApalphamtmp;try rewrite HT2 in HABCApalphamtmp.
	assert(HT := rule_4 (A :: alpha :: nil) (B :: C :: Ap :: alpha :: nil) (alpha :: nil) 4 1 2 HABCApalphamtmp Halphamtmp HAalphaMtmp Hincl); apply HT.
}
try clear HABCApalphaM1. try clear HABCApalphaM2. try clear HABCApalphaM3. try clear HABCApalpham4. try clear HABCApalpham3. try clear HABCApalpham2. try clear HABCApalpham1. 

assert(HBCApalphaM : rk(B :: C :: Ap :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApalpham : rk(B :: C :: Ap :: alpha ::  nil) >= 1) by (solve_hyps_min HBCApalphaeq HBCApalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: alpha ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Apalpha requis par la preuve de (?)Apalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: alpha ::  de rang :  3 et 3 	 AiB : alpha ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HApalpham2 : rk(Ap :: alpha :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HBCApalphaeq : rk(B :: C :: Ap :: alpha :: nil) = 3) by (apply LBCApalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCApalphamtmp : rk(B :: C :: Ap :: alpha :: nil) >= 3) by (solve_hyps_min HBCApalphaeq HBCApalpham3).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (B :: C :: alpha :: nil) (Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (B :: C :: alpha :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: Ap :: alpha :: nil) ((B :: C :: alpha :: nil) ++ (Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApalphamtmp;try rewrite HT2 in HBCApalphamtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (Ap :: alpha :: nil) (alpha :: nil) 3 1 2 HBCApalphamtmp Halphamtmp HBCalphaMtmp Hincl); apply HT.
}


assert(HApalphaM : rk(Ap :: alpha ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApalphaeq HApalphaM2).
assert(HApalpham : rk(Ap :: alpha ::  nil) >= 1) by (solve_hyps_min HApalphaeq HApalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalpha requis par la preuve de (?)ABCApBpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalpham4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpalphaM : rk(A :: B :: C :: Ap :: Bp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpalpham : rk(A :: B :: C :: Ap :: Bp :: alpha ::  nil) >= 1) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpCpalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bp :: Cp :: alpha ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBpCpalphaM : rk(Bp :: Cp :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpCpalphaeq HBpCpalphaM3).
assert(HBpCpalpham : rk(Bp :: Cp :: alpha ::  nil) >= 1) by (solve_hyps_min HBpCpalphaeq HBpCpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpCpalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: Cp :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpCpalpha requis par la preuve de (?)ABCBpCpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpCpalpham4 : rk(A :: B :: C :: Bp :: Cp :: alpha :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Cp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Cp :: alpha :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpCpalphaM : rk(A :: B :: C :: Bp :: Cp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpCpalpham : rk(A :: B :: C :: Bp :: Cp :: alpha ::  nil) >= 1) by (solve_hyps_min HABCBpCpalphaeq HABCBpCpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpalpha requis par la preuve de (?)ABCApBpCpalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpalpham4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpCpalphaM : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpalpham : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha ::  nil) >= 1) by (solve_hyps_min HABCApBpCpalphaeq HABCApBpCpalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApAsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsalpha requis par la preuve de (?)ABCApAsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsalpham4 : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsalphaM : rk(A :: B :: C :: Ap :: As :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsalpham : rk(A :: B :: C :: Ap :: As :: alpha ::  nil) >= 1) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsalpha requis par la preuve de (?)ABCBpAsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsalpham4 : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: alpha :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsalphaM : rk(A :: B :: C :: Bp :: As :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsalpham : rk(A :: B :: C :: Bp :: As :: alpha ::  nil) >= 1) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApBpAsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: C :: Ap :: Bp :: As :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApBpAsalpha requis par la preuve de (?)BCApBpAsalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsalpha requis par la preuve de (?)BCApBpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsalpha requis par la preuve de (?)ABCApBpAsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsalpham4 : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApBp requis par la preuve de (?)BCApBpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpbeta requis par la preuve de (?)BCApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpbeta requis par la preuve de (?)ABCApBpbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpbetam4 : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: beta :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ACbeta requis par la preuve de (?)BCApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApBp requis par la preuve de (?)BCApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApBp requis par la preuve de (?)BCApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp ::   de rang : 4 et 4 *)
assert(HBCApBpm2 : rk(B :: C :: Ap :: Bp :: nil) >= 2).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpMtmp : rk(A :: B :: C :: Bp :: nil) <= 4) by (solve_hyps_max HABCBpeq HABCBpM4).
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpmtmp : rk(A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCApBpeq HABCApBpm4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Bp :: nil) (B :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Bp :: B :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: B :: C :: Ap :: Bp :: nil) ((A :: B :: C :: Bp :: nil) ++ (B :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpmtmp;try rewrite HT2 in HABCApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: nil) (B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpmtmp HBCBpmtmp HABCBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HBCApBpm3 : rk(B :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Ap :: Bp :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Ap :: Bp :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: Bp :: A :: C :: beta :: nil) ((B :: C :: Ap :: Bp :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Ap :: Bp :: nil) (A :: C :: beta :: nil) (C :: nil) 4 1 2 HABCApBpbetamtmp HCmtmp HACbetaMtmp Hincl);apply HT.
}
try clear HACbetaM1. try clear HACbetaM2. try clear HACbetaM3. try clear HACbetam4. try clear HACbetam3. try clear HACbetam2. try clear HACbetam1. try clear HABCApBpbetaM1. try clear HABCApBpbetaM2. try clear HABCApBpbetaM3. try clear HABCApBpbetam4. try clear HABCApBpbetam3. try clear HABCApBpbetam2. try clear HABCApBpbetam1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCApBpAsalpha requis par la preuve de (?)BCApBpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApBpAsalpha requis par la preuve de (?)BCApBpAsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp ::   de rang : 4 et 4 *)
assert(HBCApBpAsalpham2 : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 2).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpMtmp : rk(A :: B :: C :: Bp :: nil) <= 4) by (solve_hyps_max HABCBpeq HABCBpM4).
	assert(HABCApBpAsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpAsalphaeq HABCApBpAsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Bp :: nil) (B :: C :: Ap :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) (A :: B :: C :: Bp :: B :: C :: Ap :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: B :: C :: Ap :: Bp :: As :: alpha :: nil) ((A :: B :: C :: Bp :: nil) ++ (B :: C :: Ap :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsalphamtmp;try rewrite HT2 in HABCApBpAsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: nil) (B :: C :: Ap :: Bp :: As :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsalphamtmp HBCBpmtmp HABCBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Ap :: Bp ::  de rang :  3 et 4 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCApBpAsalpham3 : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 3).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpAsalphaeq HABCApBpAsalpham4).
	assert(HBCApBpmtmp : rk(B :: C :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HBCApBpeq HBCApBpm3).
	assert(Hincl : incl (B :: C :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Ap :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Ap :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Ap :: Bp :: As :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Ap :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsalphamtmp;try rewrite HT2 in HABCApBpAsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Ap :: Bp :: As :: alpha :: nil) (B :: C :: Ap :: Bp :: nil) 4 3 4 HABCApBpAsalphamtmp HBCApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HBCApBpM1. try clear HBCApBpM2. try clear HBCApBpM3. try clear HBCApBpm4. try clear HBCApBpm3. try clear HBCApBpm2. try clear HBCApBpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCApBpAsalpham4 : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4).
{
	try assert(HBCApAseq : rk(B :: C :: Ap :: As :: nil) = 4) by (apply LBCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCApAsmtmp : rk(B :: C :: Ap :: As :: nil) >= 4) by (solve_hyps_min HBCApAseq HBCApAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Ap :: As :: nil) (B :: C :: Ap :: Bp :: As :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Ap :: As :: nil) (B :: C :: Ap :: Bp :: As :: alpha :: nil) 4 4 HBCApAsmtmp Hcomp Hincl);apply HT.
}
try clear HBCApAsM1. try clear HBCApAsM2. try clear HBCApAsM3. try clear HBCApAsm4. try clear HBCApAsm3. try clear HBCApAsm2. try clear HBCApAsm1. 

assert(HBCApBpAsalphaM : rk(B :: C :: Ap :: Bp :: As :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApBpAsalpham : rk(B :: C :: Ap :: Bp :: As :: alpha ::  nil) >= 1) by (solve_hyps_min HBCApBpAsalphaeq HBCApBpAsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpAsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: As :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsalpha requis par la preuve de (?)ABCApBpAsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsalpham4 : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpAsalphaM : rk(A :: B :: C :: Ap :: Bp :: As :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpAsalpham : rk(A :: B :: C :: Ap :: Bp :: As :: alpha ::  nil) >= 1) by (solve_hyps_min HABCApBpAsalphaeq HABCApBpAsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpCpAsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: Cp :: As :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpAsalpha requis par la preuve de (?)AApBpCpAsalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpAsalpha requis par la preuve de (?)AApBpCpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAsalpha requis par la preuve de (?)ABCApBpCpAsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsalpham4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpAsalpha requis par la preuve de (?)AApBpCpAsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpAsalpham2 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpAsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpCpAsalphaeq HABCApBpCpAsalpham4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpAsalphamtmp;try rewrite HT2 in HABCApBpCpAsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpAsalphamtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpAsalphaM1. try clear HABCApBpCpAsalphaM2. try clear HABCApBpCpAsalphaM3. try clear HABCApBpCpAsalpham4. try clear HABCApBpCpAsalpham3. try clear HABCApBpCpAsalpham2. try clear HABCApBpCpAsalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpAsalpham4 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


assert(HAApBpCpAsalphaM : rk(A :: Ap :: Bp :: Cp :: As :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpAsalpham : rk(A :: Ap :: Bp :: Cp :: As :: alpha ::  nil) >= 1) by (solve_hyps_min HAApBpCpAsalphaeq HAApBpCpAsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpAsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAsalpha requis par la preuve de (?)ABCApBpCpAsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsalpham4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpCpAsalphaM : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpAsalpham : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha ::  nil) >= 1) by (solve_hyps_min HABCApBpCpAsalphaeq HABCApBpCpAsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bs :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBsalpha requis par la preuve de (?)ABCApBsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBsalpham4 : rk(A :: B :: C :: Ap :: Bs :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bs :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBsalphaM : rk(A :: B :: C :: Ap :: Bs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBsalpham : rk(A :: B :: C :: Ap :: Bs :: alpha ::  nil) >= 1) by (solve_hyps_min HABCApBsalphaeq HABCApBsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpBsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: Bs :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBsalpha requis par la preuve de (?)ABCBpBsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsalpham4 : rk(A :: B :: C :: Bp :: Bs :: alpha :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: alpha :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpBsalphaM : rk(A :: B :: C :: Bp :: Bs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpBsalpham : rk(A :: B :: C :: Bp :: Bs :: alpha ::  nil) >= 1) by (solve_hyps_min HABCBpBsalphaeq HABCBpBsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpBsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Bs :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpBsalpha requis par la preuve de (?)ABCApBpBsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpBsalpham4 : rk(A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpBsalphaM : rk(A :: B :: C :: Ap :: Bp :: Bs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpBsalpham : rk(A :: B :: C :: Ap :: Bp :: Bs :: alpha ::  nil) >= 1) by (solve_hyps_min HABCApBpBsalphaeq HABCApBpBsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpCpBsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: Cp :: Bs :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpBsalpha requis par la preuve de (?)AApBpCpBsalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpBsalpha requis par la preuve de (?)AApBpCpBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpBsalpha requis par la preuve de (?)ABCApBpCpBsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpBsalpham4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpBsalpha requis par la preuve de (?)AApBpCpBsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpBsalpham2 : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpBsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpCpBsalphaeq HABCApBpCpBsalpham4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpBsalphamtmp;try rewrite HT2 in HABCApBpCpBsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpBsalphamtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpBsalphaM1. try clear HABCApBpCpBsalphaM2. try clear HABCApBpCpBsalphaM3. try clear HABCApBpCpBsalpham4. try clear HABCApBpCpBsalpham3. try clear HABCApBpCpBsalpham2. try clear HABCApBpCpBsalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpBsalpham4 : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


assert(HAApBpCpBsalphaM : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpBsalpham : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha ::  nil) >= 1) by (solve_hyps_min HAApBpCpBsalphaeq HAApBpCpBsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpBsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpBsalpha requis par la preuve de (?)ABCApBpCpBsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpBsalpham4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpCpBsalphaM : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpBsalpham : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha ::  nil) >= 1) by (solve_hyps_min HABCApBpCpBsalphaeq HABCApBpCpBsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpAsBsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: C :: Bp :: As :: Bs :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsBsalpha requis par la preuve de (?)BCBpAsBsalpha pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsalpha requis par la preuve de (?)BCBpAsBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsalpha requis par la preuve de (?)ABCBpAsBsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsalpham4 : rk(A :: B :: C :: Bp :: As :: Bs :: alpha :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: alpha :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsBsalpha requis par la preuve de (?)BCBpAsBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsalpha requis par la preuve de (?)BCBpAsBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsalpha requis par la preuve de (?)ABCApBpAsBsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsalpham4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpbeta requis par la preuve de (?)ABCApBpbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpbetam4 : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: beta :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ACbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsBsalpha requis par la preuve de (?)BCBpAsBsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsBsalpham2 : rk(B :: C :: Bp :: As :: Bs :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsalphaeq HABCApBpAsBsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: Bs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsalphamtmp;try rewrite HT2 in HABCApBpAsBsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsBsalphamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsBsalphaM1. try clear HABCApBpAsBsalphaM2. try clear HABCApBpAsBsalphaM3. try clear HABCApBpAsBsalpham4. try clear HABCApBpAsBsalpham3. try clear HABCApBpAsBsalpham2. try clear HABCApBpAsBsalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: alpha ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsBsalpham3 : rk(B :: C :: Bp :: As :: Bs :: alpha :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsBsalphamtmp : rk(A :: B :: C :: Bp :: As :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsBsalphaeq HABCBpAsBsalpham4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: alpha :: nil) (A :: As :: B :: C :: Bp :: As :: Bs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: Bs :: alpha :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: Bs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsalphamtmp;try rewrite HT2 in HABCBpAsBsalphamtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: alpha :: nil) (As :: nil) 4 1 2 HABCBpAsBsalphamtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}
try clear HABCBpAsBsalphaM1. try clear HABCBpAsBsalphaM2. try clear HABCBpAsBsalphaM3. try clear HABCBpAsBsalpham4. try clear HABCBpAsBsalpham3. try clear HABCBpAsBsalpham2. try clear HABCBpAsBsalpham1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsBsalpham4 : rk(B :: C :: Bp :: As :: Bs :: alpha :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: alpha :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}


assert(HBCBpAsBsalphaM : rk(B :: C :: Bp :: As :: Bs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpAsBsalpham : rk(B :: C :: Bp :: As :: Bs :: alpha ::  nil) >= 1) by (solve_hyps_min HBCBpAsBsalphaeq HBCBpAsBsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAsBsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As :: Bs :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsalpha requis par la preuve de (?)ABCBpAsBsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsalpham4 : rk(A :: B :: C :: Bp :: As :: Bs :: alpha :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: alpha :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsBsalphaM : rk(A :: B :: C :: Bp :: As :: Bs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsBsalpham : rk(A :: B :: C :: Bp :: As :: Bs :: alpha ::  nil) >= 1) by (solve_hyps_min HABCBpAsBsalphaeq HABCBpAsBsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpAsBsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsalpha requis par la preuve de (?)ABCApBpAsBsalpha pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsalpham4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpAsBsalphaM : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpAsBsalpham : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: alpha ::  nil) >= 1) by (solve_hyps_min HABCApBpAsBsalphaeq HABCApBpAsBsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBsCsalpha : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBsCsalphaM : rk(Bs :: Cs :: alpha ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBsCsalphaeq HBsCsalphaM3).
assert(HBsCsalpham : rk(Bs :: Cs :: alpha ::  nil) >= 1) by (solve_hyps_min HBsCsalphaeq HBsCsalpham1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACbeta : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HACbetaM : rk(A :: C :: beta ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACbetaeq HACbetaM3).
assert(HACbetam : rk(A :: C :: beta ::  nil) >= 1) by (solve_hyps_min HACbetaeq HACbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpbeta : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: beta ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpbeta requis par la preuve de (?)ABCApBpbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpbetam4 : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: beta :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpbetaM : rk(A :: B :: C :: Ap :: Bp :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpbetam : rk(A :: B :: C :: Ap :: Bp :: beta ::  nil) >= 1) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApAsbeta : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As :: beta ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsbeta requis par la preuve de (?)ABCApAsbeta pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsbetam4 : rk(A :: B :: C :: Ap :: As :: beta :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: beta :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: beta :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsbetaM : rk(A :: B :: C :: Ap :: As :: beta ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsbetam : rk(A :: B :: C :: Ap :: As :: beta ::  nil) >= 1) by (solve_hyps_min HABCApAsbetaeq HABCApAsbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAsCsbeta : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HAsCsbetaM : rk(As :: Cs :: beta ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAsCsbetaeq HAsCsbetaM3).
assert(HAsCsbetam : rk(As :: Cs :: beta ::  nil) >= 1) by (solve_hyps_min HAsCsbetaeq HAsCsbetam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(gamma ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HgammaM : rk(gamma ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Hgammaeq HgammaM1).
assert(Hgammam : rk(gamma ::  nil) >= 1) by (solve_hyps_min Hgammaeq Hgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LAgamma *)
(* dans constructLemma(), requis par LAApBpgamma *)
(* dans la couche 0 *)
Lemma LAApBpCpalphagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: Cp :: alpha :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpalphagamma requis par la preuve de (?)AApBpCpalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpalphagamma requis par la preuve de (?)AApBpCpalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpalphagamma requis par la preuve de (?)ABCApBpCpalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpalphagammam4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpalphagamma requis par la preuve de (?)AApBpCpalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpalphagammam2 : rk(A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpalphagammamtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HABCApBpCpalphagammaeq HABCApBpCpalphagammam4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpalphagammamtmp;try rewrite HT2 in HABCApBpCpalphagammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpalphagammamtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpalphagammaM1. try clear HABCApBpCpalphagammaM2. try clear HABCApBpCpalphagammaM3. try clear HABCApBpCpalphagammam4. try clear HABCApBpCpalphagammam3. try clear HABCApBpCpalphagammam2. try clear HABCApBpCpalphagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpalphagammam4 : rk(A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


assert(HAApBpCpalphagammaM : rk(A :: Ap :: Bp :: Cp :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpalphagammam : rk(A :: Ap :: Bp :: Cp :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HAApBpCpalphagammaeq HAApBpCpalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: gamma ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBpgamma requis par la preuve de (?)AApBpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpgamma requis par la preuve de (?)AApBpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpgamma requis par la preuve de (?)ABCApBpgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpgammam4 : rk(A :: B :: C :: Ap :: Bp :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)AApBpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBpgamma requis par la preuve de (?)AApBpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApBpgamma requis par la preuve de (?)AApBpgamma pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpgamma requis par la preuve de (?)AApBpgamma pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HAApBpgammaM3 : rk(A :: Ap :: Bp :: gamma :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApBpgammaMtmp : rk(Ap :: Bp :: gamma :: nil) <= 2) by (solve_hyps_max HApBpgammaeq HApBpgammaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Bp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: gamma :: nil) (A :: Ap :: Bp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: gamma :: nil) ((A :: nil) ++ (Ap :: Bp :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Bp :: gamma :: nil) (nil) 1 2 0 HAMtmp HApBpgammaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: gamma ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: C :: Bp ::   de rang : 2 et 3 *)
assert(HAApBpgammam2 : rk(A :: Ap :: Bp :: gamma :: nil) >= 2).
{
	assert(HBCBpMtmp : rk(B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HBCBpeq HBCBpM3).
	assert(HABCApBpgammamtmp : rk(A :: B :: C :: Ap :: Bp :: gamma :: nil) >= 4) by (solve_hyps_min HABCApBpgammaeq HABCApBpgammam4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: C :: Bp :: nil) (A :: Ap :: Bp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: gamma :: nil) (B :: C :: Bp :: A :: Ap :: Bp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: Ap :: Bp :: gamma :: nil) ((B :: C :: Bp :: nil) ++ (A :: Ap :: Bp :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpgammamtmp;try rewrite HT2 in HABCApBpgammamtmp.
	assert(HT := rule_4 (B :: C :: Bp :: nil) (A :: Ap :: Bp :: gamma :: nil) (Bp :: nil) 4 1 3 HABCApBpgammamtmp HBpmtmp HBCBpMtmp Hincl); apply HT.
}
try clear HABCApBpgammaM1. try clear HABCApBpgammaM2. try clear HABCApBpgammaM3. try clear HABCApBpgammam4. try clear HABCApBpgammam3. try clear HABCApBpgammam2. try clear HABCApBpgammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: Cp :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Bp :: Cp :: alpha ::   de rang : 2 et 2 *)
assert(HAApBpgammam3 : rk(A :: Ap :: Bp :: gamma :: nil) >= 3).
{
	try assert(HBpCpalphaeq : rk(Bp :: Cp :: alpha :: nil) = 2) by (apply LBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpCpalphaMtmp : rk(Bp :: Cp :: alpha :: nil) <= 2) by (solve_hyps_max HBpCpalphaeq HBpCpalphaM2).
	try assert(HAApBpCpalphagammaeq : rk(A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) = 4) by (apply LAApBpCpalphagamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpalphagammamtmp : rk(A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HAApBpCpalphagammaeq HAApBpCpalphagammam4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Bp :: Cp :: alpha :: nil) (A :: Ap :: Bp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) (Bp :: Cp :: alpha :: A :: Ap :: Bp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Cp :: alpha :: A :: Ap :: Bp :: gamma :: nil) ((Bp :: Cp :: alpha :: nil) ++ (A :: Ap :: Bp :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpalphagammamtmp;try rewrite HT2 in HAApBpCpalphagammamtmp.
	assert(HT := rule_4 (Bp :: Cp :: alpha :: nil) (A :: Ap :: Bp :: gamma :: nil) (Bp :: nil) 4 1 2 HAApBpCpalphagammamtmp HBpmtmp HBpCpalphaMtmp Hincl); apply HT.
}


assert(HAApBpgammaM : rk(A :: Ap :: Bp :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpgammam : rk(A :: Ap :: Bp :: gamma ::  nil) >= 1) by (solve_hyps_min HAApBpgammaeq HAApBpgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LAgamma *)
(* dans la couche 0 *)
Lemma LApBpgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Bp :: gamma ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HApBpgammaM : rk(Ap :: Bp :: gamma ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpgammaeq HApBpgammaM3).
assert(HApBpgammam : rk(Ap :: Bp :: gamma ::  nil) >= 1) by (solve_hyps_min HApBpgammaeq HApBpgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: gamma ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Agamma requis par la preuve de (?)Agamma pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAgammam2 : rk(A :: gamma :: nil) >= 2).
{
	try assert(HApBpgammaeq : rk(Ap :: Bp :: gamma :: nil) = 2) by (apply LApBpgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpgammaMtmp : rk(Ap :: Bp :: gamma :: nil) <= 2) by (solve_hyps_max HApBpgammaeq HApBpgammaM2).
	try assert(HAApBpgammaeq : rk(A :: Ap :: Bp :: gamma :: nil) = 3) by (apply LAApBpgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpgammamtmp : rk(A :: Ap :: Bp :: gamma :: nil) >= 3) by (solve_hyps_min HAApBpgammaeq HAApBpgammam3).
	try assert(Hgammaeq : rk(gamma :: nil) = 1) by (apply Lgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Hgammamtmp : rk(gamma :: nil) >= 1) by (solve_hyps_min Hgammaeq Hgammam1).
	assert(Hincl : incl (gamma :: nil) (list_inter (A :: gamma :: nil) (Ap :: Bp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: gamma :: nil) (A :: gamma :: Ap :: Bp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: gamma :: Ap :: Bp :: gamma :: nil) ((A :: gamma :: nil) ++ (Ap :: Bp :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpgammamtmp;try rewrite HT2 in HAApBpgammamtmp.
	assert(HT := rule_2 (A :: gamma :: nil) (Ap :: Bp :: gamma :: nil) (gamma :: nil) 3 1 2 HAApBpgammamtmp Hgammamtmp HApBpgammaMtmp Hincl);apply HT.
}


assert(HAgammaM : rk(A :: gamma ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAgammaeq HAgammaM2).
assert(HAgammam : rk(A :: gamma ::  nil) >= 1) by (solve_hyps_min HAgammaeq HAgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HABgammaM : rk(A :: B :: gamma ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABgammaeq HABgammaM3).
assert(HABgammam : rk(A :: B :: gamma ::  nil) >= 1) by (solve_hyps_min HABgammaeq HABgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpgamma *)
(* dans constructLemma(), requis par LABBpgamma *)
(* dans la couche 0 *)
Lemma LABCBpalphagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: alpha :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphagamma requis par la preuve de (?)ABCBpalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphagammam4 : rk(A :: B :: C :: Bp :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: gamma :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpalphagammaM : rk(A :: B :: C :: Bp :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpalphagammam : rk(A :: B :: C :: Bp :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HABCBpalphagammaeq HABCBpalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBpgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: Bp :: gamma ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBpgamma requis par la preuve de (?)ABBpgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBpgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABBpm2 : rk(A :: B :: Bp :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: B :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApBpalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBpgamma requis par la preuve de (?)ABBpgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpgamma requis par la preuve de (?)ABBpgamma pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABBpgammaM3 : rk(A :: B :: Bp :: gamma :: nil) <= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HABgammaeq : rk(A :: B :: gamma :: nil) = 2) by (apply LABgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABgammaMtmp : rk(A :: B :: gamma :: nil) <= 2) by (solve_hyps_max HABgammaeq HABgammaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: B :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: gamma :: nil) (Bp :: A :: B :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: B :: gamma :: nil) ((Bp :: nil) ++ (A :: B :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (A :: B :: gamma :: nil) (nil) 1 2 0 HBpMtmp HABgammaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABBpgammam2 : rk(A :: B :: Bp :: gamma :: nil) >= 2).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 2) by (solve_hyps_min HABBpeq HABBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (A :: B :: Bp :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (A :: B :: Bp :: gamma :: nil) 2 2 HABBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HABBpgammam3 : rk(A :: B :: Bp :: gamma :: nil) >= 3).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCBpalphagammaeq : rk(A :: B :: C :: Bp :: alpha :: gamma :: nil) = 4) by (apply LABCBpalphagamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpalphagammamtmp : rk(A :: B :: C :: Bp :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HABCBpalphagammaeq HABCBpalphagammam4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (A :: B :: Bp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: alpha :: gamma :: nil) (B :: C :: alpha :: A :: B :: Bp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: B :: Bp :: gamma :: nil) ((B :: C :: alpha :: nil) ++ (A :: B :: Bp :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpalphagammamtmp;try rewrite HT2 in HABCBpalphagammamtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: B :: Bp :: gamma :: nil) (B :: nil) 4 1 2 HABCBpalphagammamtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCBpalphagammaM1. try clear HABCBpalphagammaM2. try clear HABCBpalphagammaM3. try clear HABCBpalphagammam4. try clear HABCBpalphagammam3. try clear HABCBpalphagammam2. try clear HABCBpalphagammam1. 

assert(HABBpgammaM : rk(A :: B :: Bp :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBpgammam : rk(A :: B :: Bp :: gamma ::  nil) >= 1) by (solve_hyps_min HABBpgammaeq HABBpgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bp :: gamma ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bpgamma requis par la preuve de (?)Bpgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Bp :: gamma ::  de rang :  3 et 3 	 AiB : gamma ::  de rang :  1 et 1 	 A : A :: B :: gamma ::   de rang : 2 et 2 *)
assert(HBpgammam2 : rk(Bp :: gamma :: nil) >= 2).
{
	try assert(HABgammaeq : rk(A :: B :: gamma :: nil) = 2) by (apply LABgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABgammaMtmp : rk(A :: B :: gamma :: nil) <= 2) by (solve_hyps_max HABgammaeq HABgammaM2).
	try assert(HABBpgammaeq : rk(A :: B :: Bp :: gamma :: nil) = 3) by (apply LABBpgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABBpgammamtmp : rk(A :: B :: Bp :: gamma :: nil) >= 3) by (solve_hyps_min HABBpgammaeq HABBpgammam3).
	try assert(Hgammaeq : rk(gamma :: nil) = 1) by (apply Lgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Hgammamtmp : rk(gamma :: nil) >= 1) by (solve_hyps_min Hgammaeq Hgammam1).
	assert(Hincl : incl (gamma :: nil) (list_inter (A :: B :: gamma :: nil) (Bp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: gamma :: nil) (A :: B :: gamma :: Bp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: gamma :: Bp :: gamma :: nil) ((A :: B :: gamma :: nil) ++ (Bp :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpgammamtmp;try rewrite HT2 in HABBpgammamtmp.
	assert(HT := rule_4 (A :: B :: gamma :: nil) (Bp :: gamma :: nil) (gamma :: nil) 3 1 2 HABBpgammamtmp Hgammamtmp HABgammaMtmp Hincl); apply HT.
}


assert(HBpgammaM : rk(Bp :: gamma ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpgammaeq HBpgammaM2).
assert(HBpgammam : rk(Bp :: gamma ::  nil) >= 1) by (solve_hyps_min HBpgammaeq HBpgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpgamma requis par la preuve de (?)ABCApBpgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpgammam4 : rk(A :: B :: C :: Ap :: Bp :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpgammaM : rk(A :: B :: C :: Ap :: Bp :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpgammam : rk(A :: B :: C :: Ap :: Bp :: gamma ::  nil) >= 1) by (solve_hyps_min HABCApBpgammaeq HABCApBpgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LAsgamma *)
(* dans constructLemma(), requis par LABAsgamma *)
(* dans la couche 0 *)
Lemma LABCAsalphagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: As :: alpha :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAsalphagamma requis par la preuve de (?)ABCAsalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCAsalphagammam4 : rk(A :: B :: C :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCAseq : rk(A :: B :: C :: As :: nil) = 4) by (apply LABCAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsmtmp : rk(A :: B :: C :: As :: nil) >= 4) by (solve_hyps_min HABCAseq HABCAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: gamma :: nil) 4 4 HABCAsmtmp Hcomp Hincl);apply HT.
}


assert(HABCAsalphagammaM : rk(A :: B :: C :: As :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCAsalphagammam : rk(A :: B :: C :: As :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HABCAsalphagammaeq HABCAsalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: As :: gamma ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAsgamma requis par la preuve de (?)ABAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAs requis par la preuve de (?)ABAsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAs requis par la preuve de (?)ABAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABAsm2 : rk(A :: B :: As :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: As :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: B :: As :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: As :: B :: C :: Ap :: alpha :: nil) ((A :: B :: As :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: B :: As :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApAsalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAsgamma requis par la preuve de (?)ABAsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABAsgamma requis par la preuve de (?)ABAsgamma pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABAsgammaM3 : rk(A :: B :: As :: gamma :: nil) <= 3).
{
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsMtmp : rk(As :: nil) <= 1) by (solve_hyps_max HAseq HAsM1).
	try assert(HABgammaeq : rk(A :: B :: gamma :: nil) = 2) by (apply LABgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABgammaMtmp : rk(A :: B :: gamma :: nil) <= 2) by (solve_hyps_max HABgammaeq HABgammaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (As :: nil) (A :: B :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: As :: gamma :: nil) (As :: A :: B :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: A :: B :: gamma :: nil) ((As :: nil) ++ (A :: B :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (As :: nil) (A :: B :: gamma :: nil) (nil) 1 2 0 HAsMtmp HABgammaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABAsgammam2 : rk(A :: B :: As :: gamma :: nil) >= 2).
{
	assert(HABAsmtmp : rk(A :: B :: As :: nil) >= 2) by (solve_hyps_min HABAseq HABAsm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: As :: nil) (A :: B :: As :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: As :: nil) (A :: B :: As :: gamma :: nil) 2 2 HABAsmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: As :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HABAsgammam3 : rk(A :: B :: As :: gamma :: nil) >= 3).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCAsalphagammaeq : rk(A :: B :: C :: As :: alpha :: gamma :: nil) = 4) by (apply LABCAsalphagamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsalphagammamtmp : rk(A :: B :: C :: As :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HABCAsalphagammaeq HABCAsalphagammam4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (A :: B :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: As :: alpha :: gamma :: nil) (B :: C :: alpha :: A :: B :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: B :: As :: gamma :: nil) ((B :: C :: alpha :: nil) ++ (A :: B :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCAsalphagammamtmp;try rewrite HT2 in HABCAsalphagammamtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: B :: As :: gamma :: nil) (B :: nil) 4 1 2 HABCAsalphagammamtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCAsalphagammaM1. try clear HABCAsalphagammaM2. try clear HABCAsalphagammaM3. try clear HABCAsalphagammam4. try clear HABCAsalphagammam3. try clear HABCAsalphagammam2. try clear HABCAsalphagammam1. 

assert(HABAsgammaM : rk(A :: B :: As :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABAsgammam : rk(A :: B :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HABAsgammaeq HABAsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(As :: gamma ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Asgamma requis par la preuve de (?)Asgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: As :: gamma ::  de rang :  3 et 3 	 AiB : gamma ::  de rang :  1 et 1 	 A : A :: B :: gamma ::   de rang : 2 et 2 *)
assert(HAsgammam2 : rk(As :: gamma :: nil) >= 2).
{
	try assert(HABgammaeq : rk(A :: B :: gamma :: nil) = 2) by (apply LABgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABgammaMtmp : rk(A :: B :: gamma :: nil) <= 2) by (solve_hyps_max HABgammaeq HABgammaM2).
	try assert(HABAsgammaeq : rk(A :: B :: As :: gamma :: nil) = 3) by (apply LABAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABAsgammamtmp : rk(A :: B :: As :: gamma :: nil) >= 3) by (solve_hyps_min HABAsgammaeq HABAsgammam3).
	try assert(Hgammaeq : rk(gamma :: nil) = 1) by (apply Lgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Hgammamtmp : rk(gamma :: nil) >= 1) by (solve_hyps_min Hgammaeq Hgammam1).
	assert(Hincl : incl (gamma :: nil) (list_inter (A :: B :: gamma :: nil) (As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: As :: gamma :: nil) (A :: B :: gamma :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: gamma :: As :: gamma :: nil) ((A :: B :: gamma :: nil) ++ (As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABAsgammamtmp;try rewrite HT2 in HABAsgammamtmp.
	assert(HT := rule_4 (A :: B :: gamma :: nil) (As :: gamma :: nil) (gamma :: nil) 3 1 2 HABAsgammamtmp Hgammamtmp HABgammaMtmp Hincl); apply HT.
}
try clear HgammaM1. try clear HgammaM2. try clear HgammaM3. try clear Hgammam4. try clear Hgammam3. try clear Hgammam2. try clear Hgammam1. 

assert(HAsgammaM : rk(As :: gamma ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAsgammaeq HAsgammaM2).
assert(HAsgammam : rk(As :: gamma ::  nil) >= 1) by (solve_hyps_min HAsgammaeq HAsgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApAsgamma *)
(* dans la couche 0 *)
Lemma LAApAsBsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: As :: Bs :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApAsBsgamma requis par la preuve de (?)AApAsBsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApAsBsgamma requis par la preuve de (?)AApAsBsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsBsgamma requis par la preuve de (?)ABCApAsBsgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsBsgammam4 : rk(A :: B :: C :: Ap :: As :: Bs :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Bs :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Bs :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAsBsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApAsm2 : rk(A :: Ap :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: Ap :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: As :: B :: C :: alpha :: nil) ((A :: Ap :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: Ap :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApAsBsgamma requis par la preuve de (?)AApAsBsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: Bs :: gamma ::  de rang :  4 et 4 	 AiB : A :: Ap :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: As ::   de rang : 4 et 4 *)
assert(HAApAsBsgammam2 : rk(A :: Ap :: As :: Bs :: gamma :: nil) >= 2).
{
	try assert(HABCApAseq : rk(A :: B :: C :: Ap :: As :: nil) = 4) by (apply LABCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsMtmp : rk(A :: B :: C :: Ap :: As :: nil) <= 4) by (solve_hyps_max HABCApAseq HABCApAsM4).
	assert(HABCApAsBsgammamtmp : rk(A :: B :: C :: Ap :: As :: Bs :: gamma :: nil) >= 4) by (solve_hyps_min HABCApAsBsgammaeq HABCApAsBsgammam4).
	assert(HAApAsmtmp : rk(A :: Ap :: As :: nil) >= 2) by (solve_hyps_min HAApAseq HAApAsm2).
	assert(Hincl : incl (A :: Ap :: As :: nil) (list_inter (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Bs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: Bs :: gamma :: nil) (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Bs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Bs :: gamma :: nil) ((A :: B :: C :: Ap :: As :: nil) ++ (A :: Ap :: As :: Bs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsBsgammamtmp;try rewrite HT2 in HABCApAsBsgammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Bs :: gamma :: nil) (A :: Ap :: As :: nil) 4 2 4 HABCApAsBsgammamtmp HAApAsmtmp HABCApAsMtmp Hincl); apply HT.
}
try clear HABCApAsBsgammaM1. try clear HABCApAsBsgammaM2. try clear HABCApAsBsgammaM3. try clear HABCApAsBsgammam4. try clear HABCApAsBsgammam3. try clear HABCApAsBsgammam2. try clear HABCApAsBsgammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApAsBsgammam4 : rk(A :: Ap :: As :: Bs :: gamma :: nil) >= 4).
{
	try assert(HAApAsBseq : rk(A :: Ap :: As :: Bs :: nil) = 4) by (apply LAApAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsBsmtmp : rk(A :: Ap :: As :: Bs :: nil) >= 4) by (solve_hyps_min HAApAsBseq HAApAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: As :: Bs :: nil) (A :: Ap :: As :: Bs :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: As :: Bs :: nil) (A :: Ap :: As :: Bs :: gamma :: nil) 4 4 HAApAsBsmtmp Hcomp Hincl);apply HT.
}
try clear HAApAsBsM1. try clear HAApAsBsM2. try clear HAApAsBsM3. try clear HAApAsBsm4. try clear HAApAsBsm3. try clear HAApAsBsm2. try clear HAApAsBsm1. 

assert(HAApAsBsgammaM : rk(A :: Ap :: As :: Bs :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApAsBsgammam : rk(A :: Ap :: As :: Bs :: gamma ::  nil) >= 1) by (solve_hyps_min HAApAsBsgammaeq HAApAsBsgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApAsgamma *)
(* dans la couche 0 *)
Lemma LAsBsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HAsBsgammaM : rk(As :: Bs :: gamma ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAsBsgammaeq HAsBsgammaM3).
assert(HAsBsgammam : rk(As :: Bs :: gamma ::  nil) >= 1) by (solve_hyps_min HAsBsgammaeq HAsBsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: As :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApAsgamma requis par la preuve de (?)AApAsgamma pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AApAsCsbetagamma requis par la preuve de (?)AApAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApAsCsbetagamma requis par la preuve de (?)AApAsCsbetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApAsCsbetagamma requis par la preuve de (?)AApAsCsbetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsCsbetagamma requis par la preuve de (?)ABCApAsCsbetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsCsbetagammam4 : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAsCsbetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApAsm2 : rk(A :: Ap :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: Ap :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: As :: B :: C :: alpha :: nil) ((A :: Ap :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: Ap :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApAsCsbetagamma requis par la preuve de (?)AApAsCsbetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: Cs :: beta :: gamma ::  de rang :  4 et 4 	 AiB : A :: Ap :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: As ::   de rang : 4 et 4 *)
assert(HAApAsCsbetagammam2 : rk(A :: Ap :: As :: Cs :: beta :: gamma :: nil) >= 2).
{
	try assert(HABCApAseq : rk(A :: B :: C :: Ap :: As :: nil) = 4) by (apply LABCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsMtmp : rk(A :: B :: C :: Ap :: As :: nil) <= 4) by (solve_hyps_max HABCApAseq HABCApAsM4).
	assert(HABCApAsCsbetagammamtmp : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HABCApAsCsbetagammaeq HABCApAsCsbetagammam4).
	assert(HAApAsmtmp : rk(A :: Ap :: As :: nil) >= 2) by (solve_hyps_min HAApAseq HAApAsm2).
	assert(Hincl : incl (A :: Ap :: As :: nil) (list_inter (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Cs :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil) (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Cs :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Cs :: beta :: gamma :: nil) ((A :: B :: C :: Ap :: As :: nil) ++ (A :: Ap :: As :: Cs :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsCsbetagammamtmp;try rewrite HT2 in HABCApAsCsbetagammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Cs :: beta :: gamma :: nil) (A :: Ap :: As :: nil) 4 2 4 HABCApAsCsbetagammamtmp HAApAsmtmp HABCApAsMtmp Hincl); apply HT.
}
try clear HABCApAsCsbetagammaM1. try clear HABCApAsCsbetagammaM2. try clear HABCApAsCsbetagammaM3. try clear HABCApAsCsbetagammam4. try clear HABCApAsCsbetagammam3. try clear HABCApAsCsbetagammam2. try clear HABCApAsCsbetagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApAsCsbetagammam4 : rk(A :: Ap :: As :: Cs :: beta :: gamma :: nil) >= 4).
{
	try assert(HAApAsCseq : rk(A :: Ap :: As :: Cs :: nil) = 4) by (apply LAApAsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsCsmtmp : rk(A :: Ap :: As :: Cs :: nil) >= 4) by (solve_hyps_min HAApAsCseq HAApAsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: As :: Cs :: nil) (A :: Ap :: As :: Cs :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: As :: Cs :: nil) (A :: Ap :: As :: Cs :: beta :: gamma :: nil) 4 4 HAApAsCsmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApAsgamma requis par la preuve de (?)AApAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApAsgamma requis par la preuve de (?)AApAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsgamma requis par la preuve de (?)ABCApAsgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsgammam4 : rk(A :: B :: C :: Ap :: As :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApAsgamma requis par la preuve de (?)AApAsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: gamma ::  de rang :  4 et 4 	 AiB : A :: Ap :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: As ::   de rang : 4 et 4 *)
assert(HAApAsgammam2 : rk(A :: Ap :: As :: gamma :: nil) >= 2).
{
	try assert(HABCApAseq : rk(A :: B :: C :: Ap :: As :: nil) = 4) by (apply LABCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsMtmp : rk(A :: B :: C :: Ap :: As :: nil) <= 4) by (solve_hyps_max HABCApAseq HABCApAsM4).
	assert(HABCApAsgammamtmp : rk(A :: B :: C :: Ap :: As :: gamma :: nil) >= 4) by (solve_hyps_min HABCApAsgammaeq HABCApAsgammam4).
	assert(HAApAsmtmp : rk(A :: Ap :: As :: nil) >= 2) by (solve_hyps_min HAApAseq HAApAsm2).
	assert(Hincl : incl (A :: Ap :: As :: nil) (list_inter (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: gamma :: nil) (A :: B :: C :: Ap :: As :: A :: Ap :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: As :: A :: Ap :: As :: gamma :: nil) ((A :: B :: C :: Ap :: As :: nil) ++ (A :: Ap :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsgammamtmp;try rewrite HT2 in HABCApAsgammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: gamma :: nil) (A :: Ap :: As :: nil) 4 2 4 HABCApAsgammamtmp HAApAsmtmp HABCApAsMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: As :: Cs :: beta :: gamma ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : As :: Cs :: beta ::   de rang : 2 et 2 *)
assert(HAApAsgammam3 : rk(A :: Ap :: As :: gamma :: nil) >= 3).
{
	try assert(HAsCsbetaeq : rk(As :: Cs :: beta :: nil) = 2) by (apply LAsCsbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsCsbetaMtmp : rk(As :: Cs :: beta :: nil) <= 2) by (solve_hyps_max HAsCsbetaeq HAsCsbetaM2).
	assert(HAApAsCsbetagammamtmp : rk(A :: Ap :: As :: Cs :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HAApAsCsbetagammaeq HAApAsCsbetagammam4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (As :: Cs :: beta :: nil) (A :: Ap :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: As :: Cs :: beta :: gamma :: nil) (As :: Cs :: beta :: A :: Ap :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: Cs :: beta :: A :: Ap :: As :: gamma :: nil) ((As :: Cs :: beta :: nil) ++ (A :: Ap :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApAsCsbetagammamtmp;try rewrite HT2 in HAApAsCsbetagammamtmp.
	assert(HT := rule_4 (As :: Cs :: beta :: nil) (A :: Ap :: As :: gamma :: nil) (As :: nil) 4 1 2 HAApAsCsbetagammamtmp HAsmtmp HAsCsbetaMtmp Hincl); apply HT.
}
try clear HAApAsCsbetagammaM1. try clear HAApAsCsbetagammaM2. try clear HAApAsCsbetagammaM3. try clear HAApAsCsbetagammam4. try clear HAApAsCsbetagammam3. try clear HAApAsCsbetagammam2. try clear HAApAsCsbetagammam1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApAsgammam4 : rk(A :: Ap :: As :: gamma :: nil) >= 4).
{
	try assert(HAsBsgammaeq : rk(As :: Bs :: gamma :: nil) = 2) by (apply LAsBsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsBsgammaMtmp : rk(As :: Bs :: gamma :: nil) <= 2) by (solve_hyps_max HAsBsgammaeq HAsBsgammaM2).
	try assert(HAApAsBsgammaeq : rk(A :: Ap :: As :: Bs :: gamma :: nil) = 4) by (apply LAApAsBsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsBsgammamtmp : rk(A :: Ap :: As :: Bs :: gamma :: nil) >= 4) by (solve_hyps_min HAApAsBsgammaeq HAApAsBsgammam4).
	try assert(HAsgammaeq : rk(As :: gamma :: nil) = 2) by (apply LAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsgammamtmp : rk(As :: gamma :: nil) >= 2) by (solve_hyps_min HAsgammaeq HAsgammam2).
	assert(Hincl : incl (As :: gamma :: nil) (list_inter (A :: Ap :: As :: gamma :: nil) (As :: Bs :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: As :: Bs :: gamma :: nil) (A :: Ap :: As :: gamma :: As :: Bs :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: As :: gamma :: As :: Bs :: gamma :: nil) ((A :: Ap :: As :: gamma :: nil) ++ (As :: Bs :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApAsBsgammamtmp;try rewrite HT2 in HAApAsBsgammamtmp.
	assert(HT := rule_2 (A :: Ap :: As :: gamma :: nil) (As :: Bs :: gamma :: nil) (As :: gamma :: nil) 4 2 2 HAApAsBsgammamtmp HAsgammamtmp HAsBsgammaMtmp Hincl);apply HT.
}
try clear HAsBsgammaM1. try clear HAsBsgammaM2. try clear HAsBsgammaM3. try clear HAsBsgammam4. try clear HAsBsgammam3. try clear HAsBsgammam2. try clear HAsBsgammam1. try clear HAsgammaM1. try clear HAsgammaM2. try clear HAsgammaM3. try clear HAsgammam4. try clear HAsgammam3. try clear HAsgammam2. try clear HAsgammam1. 

assert(HAApAsgammaM : rk(A :: Ap :: As :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApAsgammam : rk(A :: Ap :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HAApAsgammaeq HAApAsgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LACApAsgamma *)
(* dans la couche 0 *)
Lemma LABCApAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsgamma requis par la preuve de (?)ABCApAsgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsgammam4 : rk(A :: B :: C :: Ap :: As :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsgammaM : rk(A :: B :: C :: Ap :: As :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsgammam : rk(A :: B :: C :: Ap :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HABCApAsgammaeq HABCApAsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: C :: Ap :: As :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApAsgamma requis par la preuve de (?)ACApAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApAs requis par la preuve de (?)ACApAsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApAs requis par la preuve de (?)ACApAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAs requis par la preuve de (?)ACApAs pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ACAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAs requis par la preuve de (?)ACAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HACAsm2 : rk(A :: C :: As :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: As :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: C :: As :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: As :: B :: C :: Ap :: alpha :: nil) ((A :: C :: As :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: C :: As :: nil) (B :: C :: Ap :: alpha :: nil) (C :: nil) 4 1 3 HABCApAsalphamtmp HCmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApAs requis par la preuve de (?)ACApAs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As ::  de rang :  4 et 4 	 AiB : A :: C :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: As ::   de rang : 4 et 4 *)
assert(HACApAsm2 : rk(A :: C :: Ap :: As :: nil) >= 2).
{
	try assert(HABCAseq : rk(A :: B :: C :: As :: nil) = 4) by (apply LABCAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsMtmp : rk(A :: B :: C :: As :: nil) <= 4) by (solve_hyps_max HABCAseq HABCAsM4).
	try assert(HABCApAseq : rk(A :: B :: C :: Ap :: As :: nil) = 4) by (apply LABCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsmtmp : rk(A :: B :: C :: Ap :: As :: nil) >= 4) by (solve_hyps_min HABCApAseq HABCApAsm4).
	assert(HACAsmtmp : rk(A :: C :: As :: nil) >= 2) by (solve_hyps_min HACAseq HACAsm2).
	assert(Hincl : incl (A :: C :: As :: nil) (list_inter (A :: B :: C :: As :: nil) (A :: C :: Ap :: As :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: nil) (A :: B :: C :: As :: A :: C :: Ap :: As :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: As :: A :: C :: Ap :: As :: nil) ((A :: B :: C :: As :: nil) ++ (A :: C :: Ap :: As :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsmtmp;try rewrite HT2 in HABCApAsmtmp.
	assert(HT := rule_4 (A :: B :: C :: As :: nil) (A :: C :: Ap :: As :: nil) (A :: C :: As :: nil) 4 2 4 HABCApAsmtmp HACAsmtmp HABCAsMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACApAsm3 : rk(A :: C :: Ap :: As :: nil) >= 3).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: Ap :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: C :: Ap :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: As :: B :: C :: alpha :: nil) ((A :: C :: Ap :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: C :: Ap :: As :: nil) (B :: C :: alpha :: nil) (C :: nil) 4 1 2 HABCApAsalphamtmp HCmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApAsgamma requis par la preuve de (?)ACApAsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApAsgamma requis par la preuve de (?)ACApAsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: gamma ::  de rang :  4 et 4 	 AiB : A :: C :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: As ::   de rang : 4 et 4 *)
assert(HACApAsgammam2 : rk(A :: C :: Ap :: As :: gamma :: nil) >= 2).
{
	try assert(HABCAseq : rk(A :: B :: C :: As :: nil) = 4) by (apply LABCAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsMtmp : rk(A :: B :: C :: As :: nil) <= 4) by (solve_hyps_max HABCAseq HABCAsM4).
	try assert(HABCApAsgammaeq : rk(A :: B :: C :: Ap :: As :: gamma :: nil) = 4) by (apply LABCApAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsgammamtmp : rk(A :: B :: C :: Ap :: As :: gamma :: nil) >= 4) by (solve_hyps_min HABCApAsgammaeq HABCApAsgammam4).
	assert(HACAsmtmp : rk(A :: C :: As :: nil) >= 2) by (solve_hyps_min HACAseq HACAsm2).
	assert(Hincl : incl (A :: C :: As :: nil) (list_inter (A :: B :: C :: As :: nil) (A :: C :: Ap :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: gamma :: nil) (A :: B :: C :: As :: A :: C :: Ap :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: As :: A :: C :: Ap :: As :: gamma :: nil) ((A :: B :: C :: As :: nil) ++ (A :: C :: Ap :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsgammamtmp;try rewrite HT2 in HABCApAsgammamtmp.
	assert(HT := rule_4 (A :: B :: C :: As :: nil) (A :: C :: Ap :: As :: gamma :: nil) (A :: C :: As :: nil) 4 2 4 HABCApAsgammamtmp HACAsmtmp HABCAsMtmp Hincl); apply HT.
}
try clear HACAsM1. try clear HACAsM2. try clear HACAsM3. try clear HACAsm4. try clear HACAsm3. try clear HACAsm2. try clear HACAsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HACApAsgammam3 : rk(A :: C :: Ap :: As :: gamma :: nil) >= 3).
{
	assert(HACApAsmtmp : rk(A :: C :: Ap :: As :: nil) >= 3) by (solve_hyps_min HACApAseq HACApAsm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: As :: nil) (A :: C :: Ap :: As :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: As :: nil) (A :: C :: Ap :: As :: gamma :: nil) 3 3 HACApAsmtmp Hcomp Hincl);apply HT.
}
try clear HACApAsM1. try clear HACApAsM2. try clear HACApAsM3. try clear HACApAsm4. try clear HACApAsm3. try clear HACApAsm2. try clear HACApAsm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: gamma ::  de rang :  4 et 4 	 AiB : A :: gamma ::  de rang :  2 et 2 	 A : A :: B :: gamma ::   de rang : 2 et 2 *)
assert(HACApAsgammam4 : rk(A :: C :: Ap :: As :: gamma :: nil) >= 4).
{
	try assert(HABgammaeq : rk(A :: B :: gamma :: nil) = 2) by (apply LABgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABgammaMtmp : rk(A :: B :: gamma :: nil) <= 2) by (solve_hyps_max HABgammaeq HABgammaM2).
	try assert(HABCApAsgammaeq : rk(A :: B :: C :: Ap :: As :: gamma :: nil) = 4) by (apply LABCApAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsgammamtmp : rk(A :: B :: C :: Ap :: As :: gamma :: nil) >= 4) by (solve_hyps_min HABCApAsgammaeq HABCApAsgammam4).
	try assert(HAgammaeq : rk(A :: gamma :: nil) = 2) by (apply LAgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAgammamtmp : rk(A :: gamma :: nil) >= 2) by (solve_hyps_min HAgammaeq HAgammam2).
	assert(Hincl : incl (A :: gamma :: nil) (list_inter (A :: B :: gamma :: nil) (A :: C :: Ap :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: gamma :: nil) (A :: B :: gamma :: A :: C :: Ap :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: gamma :: A :: C :: Ap :: As :: gamma :: nil) ((A :: B :: gamma :: nil) ++ (A :: C :: Ap :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsgammamtmp;try rewrite HT2 in HABCApAsgammamtmp.
	assert(HT := rule_4 (A :: B :: gamma :: nil) (A :: C :: Ap :: As :: gamma :: nil) (A :: gamma :: nil) 4 2 2 HABCApAsgammamtmp HAgammamtmp HABgammaMtmp Hincl); apply HT.
}


assert(HACApAsgammaM : rk(A :: C :: Ap :: As :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApAsgammam : rk(A :: C :: Ap :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HACApAsgammaeq HACApAsgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpAsgamma *)
(* dans constructLemma(), requis par LApBpAsgamma *)
(* dans la couche 0 *)
Lemma LApBpCpAsalphagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: As :: alpha :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpCpAsalphagamma requis par la preuve de (?)ApBpCpAsalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AApBpCpAsalphagamma requis par la preuve de (?)ApBpCpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpAsalphagamma requis par la preuve de (?)AApBpCpAsalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpAsalphagamma requis par la preuve de (?)AApBpCpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAsalphagamma requis par la preuve de (?)ABCApBpCpAsalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsalphagammam4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpAsalphagamma requis par la preuve de (?)AApBpCpAsalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpAsalphagammam2 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpAsalphagammamtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HABCApBpCpAsalphagammaeq HABCApBpCpAsalphagammam4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpAsalphagammamtmp;try rewrite HT2 in HABCApBpCpAsalphagammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpAsalphagammamtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpAsalphagammaM1. try clear HABCApBpCpAsalphagammaM2. try clear HABCApBpCpAsalphagammaM3. try clear HABCApBpCpAsalphagammam4. try clear HABCApBpCpAsalphagammam3. try clear HABCApBpCpAsalphagammam2. try clear HABCApBpCpAsalphagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpAsalphagammam4 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpAs requis par la preuve de (?)ApBpCpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpAs requis par la preuve de (?)ApBpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HApBpAsm2 : rk(Ap :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HBCApBpAsalphaeq : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) = 4) by (apply LBCApBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCApBpAsalphamtmp : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HBCApBpAsalphaeq HBCApBpAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Bp :: As :: alpha :: nil) (Ap :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: As :: B :: C :: alpha :: nil) ((Ap :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApBpAsalphamtmp;try rewrite HT2 in HBCApBpAsalphamtmp.
	assert(HT := rule_2 (Ap :: Bp :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HBCApBpAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpAs requis par la preuve de (?)ApBpCpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpAs requis par la preuve de (?)AApBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpAs requis par la preuve de (?)AApBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpAs requis par la preuve de (?)AApBpAs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpAsm2 : rk(A :: Ap :: Bp :: As :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpAseq : rk(A :: B :: C :: Ap :: Bp :: As :: nil) = 4) by (apply LABCApBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsmtmp : rk(A :: B :: C :: Ap :: Bp :: As :: nil) >= 4) by (solve_hyps_min HABCApBpAseq HABCApBpAsm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: As :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: As :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: As :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: As :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsmtmp;try rewrite HT2 in HABCApBpAsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: As :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpAsmtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsM1. try clear HABCApBpAsM2. try clear HABCApBpAsM3. try clear HABCApBpAsm4. try clear HABCApBpAsm3. try clear HABCApBpAsm2. try clear HABCApBpAsm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HAApBpAsm3 : rk(A :: Ap :: Bp :: As :: nil) >= 3).
{
	assert(HCpAsMtmp : rk(Cp :: As :: nil) <= 2) by (solve_hyps_max HCpAseq HCpAsM2).
	try assert(HAApBpCpAseq : rk(A :: Ap :: Bp :: Cp :: As :: nil) = 4) by (apply LAApBpCpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpAsmtmp : rk(A :: Ap :: Bp :: Cp :: As :: nil) >= 4) by (solve_hyps_min HAApBpCpAseq HAApBpCpAsm4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: Ap :: Bp :: As :: nil) (Cp :: As :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: As :: nil) (A :: Ap :: Bp :: As :: Cp :: As :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: As :: Cp :: As :: nil) ((A :: Ap :: Bp :: As :: nil) ++ (Cp :: As :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpAsmtmp;try rewrite HT2 in HAApBpCpAsmtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: As :: nil) (Cp :: As :: nil) (As :: nil) 4 1 2 HAApBpCpAsmtmp HAsmtmp HCpAsMtmp Hincl);apply HT.
}
try clear HCpAsM1. try clear HCpAsM2. try clear HCpAsM3. try clear HCpAsm4. try clear HCpAsm3. try clear HCpAsm2. try clear HCpAsm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpCpAsalphagamma requis par la preuve de (?)ApBpCpAsalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: Ap :: Bp :: Cp :: As :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: As ::  de rang :  2 et 3 	 A : A :: Ap :: Bp :: As ::   de rang : 3 et 4 *)
assert(HApBpCpAsalphagammam2 : rk(Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 2).
{
	assert(HAApBpAsMtmp : rk(A :: Ap :: Bp :: As :: nil) <= 4) by (solve_hyps_max HAApBpAseq HAApBpAsM4).
	assert(HAApBpCpAsalphagammamtmp : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HAApBpCpAsalphagammaeq HAApBpCpAsalphagammam4).
	assert(HApBpAsmtmp : rk(Ap :: Bp :: As :: nil) >= 2) by (solve_hyps_min HApBpAseq HApBpAsm2).
	assert(Hincl : incl (Ap :: Bp :: As :: nil) (list_inter (A :: Ap :: Bp :: As :: nil) (Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) (A :: Ap :: Bp :: As :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: As :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) ((A :: Ap :: Bp :: As :: nil) ++ (Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpAsalphagammamtmp;try rewrite HT2 in HAApBpCpAsalphagammamtmp.
	assert(HT := rule_4 (A :: Ap :: Bp :: As :: nil) (Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) (Ap :: Bp :: As :: nil) 4 2 4 HAApBpCpAsalphagammamtmp HApBpAsmtmp HAApBpAsMtmp Hincl); apply HT.
}
try clear HAApBpCpAsalphagammaM1. try clear HAApBpCpAsalphagammaM2. try clear HAApBpCpAsalphagammaM3. try clear HAApBpCpAsalphagammam4. try clear HAApBpCpAsalphagammam3. try clear HAApBpCpAsalphagammam2. try clear HAApBpCpAsalphagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpAsalphagammam4 : rk(Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HApBpCpAseq : rk(Ap :: Bp :: Cp :: As :: nil) = 4) by (apply LApBpCpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpCpAsmtmp : rk(Ap :: Bp :: Cp :: As :: nil) >= 4) by (solve_hyps_min HApBpCpAseq HApBpCpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: As :: nil) (Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: As :: nil) (Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) 4 4 HApBpCpAsmtmp Hcomp Hincl);apply HT.
}


assert(HApBpCpAsalphagammaM : rk(Ap :: Bp :: Cp :: As :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpAsalphagammam : rk(Ap :: Bp :: Cp :: As :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HApBpCpAsalphagammaeq HApBpCpAsalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Bp :: As :: gamma ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpAsgamma requis par la preuve de (?)ApBpAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpAs requis par la preuve de (?)ApBpAsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpAs requis par la preuve de (?)ApBpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HApBpAsm2 : rk(Ap :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HBCApBpAsalphaeq : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) = 4) by (apply LBCApBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCApBpAsalphamtmp : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HBCApBpAsalphaeq HBCApBpAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Bp :: As :: alpha :: nil) (Ap :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: As :: B :: C :: alpha :: nil) ((Ap :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApBpAsalphamtmp;try rewrite HT2 in HBCApBpAsalphamtmp.
	assert(HT := rule_2 (Ap :: Bp :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HBCApBpAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpAsgamma requis par la preuve de (?)ApBpAsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpAsgamma requis par la preuve de (?)ApBpAsgamma pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApBpAsgammaM3 : rk(Ap :: Bp :: As :: gamma :: nil) <= 3).
{
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsMtmp : rk(As :: nil) <= 1) by (solve_hyps_max HAseq HAsM1).
	try assert(HApBpgammaeq : rk(Ap :: Bp :: gamma :: nil) = 2) by (apply LApBpgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpgammaMtmp : rk(Ap :: Bp :: gamma :: nil) <= 2) by (solve_hyps_max HApBpgammaeq HApBpgammaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (As :: nil) (Ap :: Bp :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: As :: gamma :: nil) (As :: Ap :: Bp :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: Ap :: Bp :: gamma :: nil) ((As :: nil) ++ (Ap :: Bp :: gamma :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (As :: nil) (Ap :: Bp :: gamma :: nil) (nil) 1 2 0 HAsMtmp HApBpgammaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HApBpAsgammam2 : rk(Ap :: Bp :: As :: gamma :: nil) >= 2).
{
	assert(HApBpAsmtmp : rk(Ap :: Bp :: As :: nil) >= 2) by (solve_hyps_min HApBpAseq HApBpAsm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: As :: nil) (Ap :: Bp :: As :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: As :: nil) (Ap :: Bp :: As :: gamma :: nil) 2 2 HApBpAsmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Cp :: As :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Bp :: Cp :: alpha ::   de rang : 2 et 2 *)
assert(HApBpAsgammam3 : rk(Ap :: Bp :: As :: gamma :: nil) >= 3).
{
	try assert(HBpCpalphaeq : rk(Bp :: Cp :: alpha :: nil) = 2) by (apply LBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpCpalphaMtmp : rk(Bp :: Cp :: alpha :: nil) <= 2) by (solve_hyps_max HBpCpalphaeq HBpCpalphaM2).
	try assert(HApBpCpAsalphagammaeq : rk(Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) = 4) by (apply LApBpCpAsalphagamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpCpAsalphagammamtmp : rk(Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HApBpCpAsalphagammaeq HApBpCpAsalphagammam4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Bp :: Cp :: alpha :: nil) (Ap :: Bp :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) (Bp :: Cp :: alpha :: Ap :: Bp :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Cp :: alpha :: Ap :: Bp :: As :: gamma :: nil) ((Bp :: Cp :: alpha :: nil) ++ (Ap :: Bp :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpCpAsalphagammamtmp;try rewrite HT2 in HApBpCpAsalphagammamtmp.
	assert(HT := rule_4 (Bp :: Cp :: alpha :: nil) (Ap :: Bp :: As :: gamma :: nil) (Bp :: nil) 4 1 2 HApBpCpAsalphagammamtmp HBpmtmp HBpCpalphaMtmp Hincl); apply HT.
}


assert(HApBpAsgammaM : rk(Ap :: Bp :: As :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpAsgammam : rk(Ap :: Bp :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HApBpAsgammaeq HApBpAsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bp :: As :: gamma ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpAsgamma requis par la preuve de (?)BpAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCBpAsalphagamma requis par la preuve de (?)BpAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsalphagamma requis par la preuve de (?)BCBpAsalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsalphagamma requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsalphagamma requis par la preuve de (?)ABCBpAsalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsalphagammam4 : rk(A :: B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: alpha :: gamma :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsalphagamma requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsalphagamma requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsalphagamma requis par la preuve de (?)ABCApBpAsalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsalphagammam4 : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsalphagamma requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsalphagammam2 : rk(B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsalphagammamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HABCApBpAsalphagammaeq HABCApBpAsalphagammam4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: gamma :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsalphagammamtmp;try rewrite HT2 in HABCApBpAsalphagammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsalphagammamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsalphagammaM1. try clear HABCApBpAsalphagammaM2. try clear HABCApBpAsalphagammaM3. try clear HABCApBpAsalphagammam4. try clear HABCApBpAsalphagammam3. try clear HABCApBpAsalphagammam2. try clear HABCApBpAsalphagammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsalphagammam3 : rk(B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsalphagammamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HABCBpAsalphagammaeq HABCBpAsalphagammam4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: gamma :: nil) (A :: As :: B :: C :: Bp :: As :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: alpha :: gamma :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphagammamtmp;try rewrite HT2 in HABCBpAsalphagammamtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil) (As :: nil) 4 1 2 HABCBpAsalphagammamtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}
try clear HABCBpAsalphagammaM1. try clear HABCBpAsalphagammaM2. try clear HABCBpAsalphagammaM3. try clear HABCBpAsalphagammam4. try clear HABCBpAsalphagammam3. try clear HABCBpAsalphagammam2. try clear HABCBpAsalphagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsalphagammam4 : rk(B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpAsgamma requis par la preuve de (?)BpAsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: As :: alpha :: gamma ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HBpAsgammam2 : rk(Bp :: As :: gamma :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpAsalphagammamtmp : rk(B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HBCBpAsalphagammaeq HBCBpAsalphagammam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C :: alpha :: nil) (Bp :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: alpha :: gamma :: nil) (B :: C :: alpha :: Bp :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: Bp :: As :: gamma :: nil) ((B :: C :: alpha :: nil) ++ (Bp :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsalphagammamtmp;try rewrite HT2 in HBCBpAsalphagammamtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (Bp :: As :: gamma :: nil) (nil) 4 0 2 HBCBpAsalphagammamtmp Hmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HBCBpAsalphagammaM1. try clear HBCBpAsalphagammaM2. try clear HBCBpAsalphagammaM3. try clear HBCBpAsalphagammam4. try clear HBCBpAsalphagammam3. try clear HBCBpAsalphagammam2. try clear HBCBpAsalphagammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: As :: gamma ::  de rang :  3 et 3 	 AiB : Bp :: gamma ::  de rang :  2 et 2 	 A : Ap :: Bp :: gamma ::   de rang : 2 et 2 *)
assert(HBpAsgammam3 : rk(Bp :: As :: gamma :: nil) >= 3).
{
	try assert(HApBpgammaeq : rk(Ap :: Bp :: gamma :: nil) = 2) by (apply LApBpgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpgammaMtmp : rk(Ap :: Bp :: gamma :: nil) <= 2) by (solve_hyps_max HApBpgammaeq HApBpgammaM2).
	try assert(HApBpAsgammaeq : rk(Ap :: Bp :: As :: gamma :: nil) = 3) by (apply LApBpAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpAsgammamtmp : rk(Ap :: Bp :: As :: gamma :: nil) >= 3) by (solve_hyps_min HApBpAsgammaeq HApBpAsgammam3).
	try assert(HBpgammaeq : rk(Bp :: gamma :: nil) = 2) by (apply LBpgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpgammamtmp : rk(Bp :: gamma :: nil) >= 2) by (solve_hyps_min HBpgammaeq HBpgammam2).
	assert(Hincl : incl (Bp :: gamma :: nil) (list_inter (Ap :: Bp :: gamma :: nil) (Bp :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: As :: gamma :: nil) (Ap :: Bp :: gamma :: Bp :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: gamma :: Bp :: As :: gamma :: nil) ((Ap :: Bp :: gamma :: nil) ++ (Bp :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpAsgammamtmp;try rewrite HT2 in HApBpAsgammamtmp.
	assert(HT := rule_4 (Ap :: Bp :: gamma :: nil) (Bp :: As :: gamma :: nil) (Bp :: gamma :: nil) 3 2 2 HApBpAsgammamtmp HBpgammamtmp HApBpgammaMtmp Hincl); apply HT.
}
try clear HBpgammaM1. try clear HBpgammaM2. try clear HBpgammaM3. try clear HBpgammam4. try clear HBpgammam3. try clear HBpgammam2. try clear HBpgammam1. 

assert(HBpAsgammaM : rk(Bp :: As :: gamma ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpAsgammaeq HBpAsgammaM3).
assert(HBpAsgammam : rk(Bp :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HBpAsgammaeq HBpAsgammam1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpAsgamma *)
(* dans constructLemma(), requis par LAApBpAsgamma *)
(* dans constructLemma(), requis par LACApBpAsgamma *)
(* dans la couche 0 *)
Lemma LABCApBpAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: As :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsgamma requis par la preuve de (?)ABCApBpAsgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsgammam4 : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpAsgammaM : rk(A :: B :: C :: Ap :: Bp :: As :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpAsgammam : rk(A :: B :: C :: Ap :: Bp :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HABCApBpAsgammaeq HABCApBpAsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBpAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: C :: Ap :: Bp :: As :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpAsgamma requis par la preuve de (?)ACApBpAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBpAsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACBp requis par la preuve de (?)ACApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ACBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HACBpm2 : rk(A :: C :: Bp :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: C :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: C :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: C :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (C :: nil) 4 1 3 HABCApBpalphamtmp HCmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB : A :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp ::   de rang : 4 et 4 *)
assert(HACApBpm2 : rk(A :: C :: Ap :: Bp :: nil) >= 2).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpMtmp : rk(A :: B :: C :: Bp :: nil) <= 4) by (solve_hyps_max HABCBpeq HABCBpM4).
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpmtmp : rk(A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HABCApBpeq HABCApBpm4).
	assert(HACBpmtmp : rk(A :: C :: Bp :: nil) >= 2) by (solve_hyps_min HACBpeq HACBpm2).
	assert(Hincl : incl (A :: C :: Bp :: nil) (list_inter (A :: B :: C :: Bp :: nil) (A :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: C :: Bp :: A :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: A :: C :: Ap :: Bp :: nil) ((A :: B :: C :: Bp :: nil) ++ (A :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpmtmp;try rewrite HT2 in HABCApBpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: nil) (A :: C :: Ap :: Bp :: nil) (A :: C :: Bp :: nil) 4 2 4 HABCApBpmtmp HACBpmtmp HABCBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACApBpm3 : rk(A :: C :: Ap :: Bp :: nil) >= 3).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: C :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: C :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: C :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (C :: nil) 4 1 2 HABCApBpalphamtmp HCmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpAsgamma requis par la preuve de (?)ACApBpAsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpAsgamma requis par la preuve de (?)ACApBpAsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: gamma ::  de rang :  4 et 4 	 AiB : A :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp ::   de rang : 4 et 4 *)
assert(HACApBpAsgammam2 : rk(A :: C :: Ap :: Bp :: As :: gamma :: nil) >= 2).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpMtmp : rk(A :: B :: C :: Bp :: nil) <= 4) by (solve_hyps_max HABCBpeq HABCBpM4).
	try assert(HABCApBpAsgammaeq : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) = 4) by (apply LABCApBpAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsgammamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) >= 4) by (solve_hyps_min HABCApBpAsgammaeq HABCApBpAsgammam4).
	assert(HACBpmtmp : rk(A :: C :: Bp :: nil) >= 2) by (solve_hyps_min HACBpeq HACBpm2).
	assert(Hincl : incl (A :: C :: Bp :: nil) (list_inter (A :: B :: C :: Bp :: nil) (A :: C :: Ap :: Bp :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) (A :: B :: C :: Bp :: A :: C :: Ap :: Bp :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: A :: C :: Ap :: Bp :: As :: gamma :: nil) ((A :: B :: C :: Bp :: nil) ++ (A :: C :: Ap :: Bp :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsgammamtmp;try rewrite HT2 in HABCApBpAsgammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: nil) (A :: C :: Ap :: Bp :: As :: gamma :: nil) (A :: C :: Bp :: nil) 4 2 4 HABCApBpAsgammamtmp HACBpmtmp HABCBpMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HACApBpAsgammam3 : rk(A :: C :: Ap :: Bp :: As :: gamma :: nil) >= 3).
{
	assert(HACApBpmtmp : rk(A :: C :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HACApBpeq HACApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: As :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: As :: gamma :: nil) 3 3 HACApBpmtmp Hcomp Hincl);apply HT.
}
try clear HACApBpM1. try clear HACApBpM2. try clear HACApBpM3. try clear HACApBpm4. try clear HACApBpm3. try clear HACApBpm2. try clear HACApBpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: gamma ::  de rang :  4 et 4 	 AiB : A :: gamma ::  de rang :  2 et 2 	 A : A :: B :: gamma ::   de rang : 2 et 2 *)
assert(HACApBpAsgammam4 : rk(A :: C :: Ap :: Bp :: As :: gamma :: nil) >= 4).
{
	try assert(HABgammaeq : rk(A :: B :: gamma :: nil) = 2) by (apply LABgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABgammaMtmp : rk(A :: B :: gamma :: nil) <= 2) by (solve_hyps_max HABgammaeq HABgammaM2).
	try assert(HABCApBpAsgammaeq : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) = 4) by (apply LABCApBpAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsgammamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) >= 4) by (solve_hyps_min HABCApBpAsgammaeq HABCApBpAsgammam4).
	try assert(HAgammaeq : rk(A :: gamma :: nil) = 2) by (apply LAgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAgammamtmp : rk(A :: gamma :: nil) >= 2) by (solve_hyps_min HAgammaeq HAgammam2).
	assert(Hincl : incl (A :: gamma :: nil) (list_inter (A :: B :: gamma :: nil) (A :: C :: Ap :: Bp :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) (A :: B :: gamma :: A :: C :: Ap :: Bp :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: gamma :: A :: C :: Ap :: Bp :: As :: gamma :: nil) ((A :: B :: gamma :: nil) ++ (A :: C :: Ap :: Bp :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsgammamtmp;try rewrite HT2 in HABCApBpAsgammamtmp.
	assert(HT := rule_4 (A :: B :: gamma :: nil) (A :: C :: Ap :: Bp :: As :: gamma :: nil) (A :: gamma :: nil) 4 2 2 HABCApBpAsgammamtmp HAgammamtmp HABgammaMtmp Hincl); apply HT.
}
try clear HAgammaM1. try clear HAgammaM2. try clear HAgammaM3. try clear HAgammam4. try clear HAgammam3. try clear HAgammam2. try clear HAgammam1. 

assert(HACApBpAsgammaM : rk(A :: C :: Ap :: Bp :: As :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpAsgammam : rk(A :: C :: Ap :: Bp :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HACApBpAsgammaeq HACApBpAsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: As :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpAsgamma requis par la preuve de (?)AApBpAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpAs requis par la preuve de (?)AApBpAsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpAs requis par la preuve de (?)AApBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpAs requis par la preuve de (?)AApBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpAs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpAs requis par la preuve de (?)AApBpAs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpAsm2 : rk(A :: Ap :: Bp :: As :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpAseq : rk(A :: B :: C :: Ap :: Bp :: As :: nil) = 4) by (apply LABCApBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsmtmp : rk(A :: B :: C :: Ap :: Bp :: As :: nil) >= 4) by (solve_hyps_min HABCApBpAseq HABCApBpAsm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: As :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: As :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: As :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: As :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsmtmp;try rewrite HT2 in HABCApBpAsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: As :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpAsmtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsM1. try clear HABCApBpAsM2. try clear HABCApBpAsM3. try clear HABCApBpAsm4. try clear HABCApBpAsm3. try clear HABCApBpAsm2. try clear HABCApBpAsm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HAApBpAsm3 : rk(A :: Ap :: Bp :: As :: nil) >= 3).
{
	assert(HCpAsMtmp : rk(Cp :: As :: nil) <= 2) by (solve_hyps_max HCpAseq HCpAsM2).
	try assert(HAApBpCpAseq : rk(A :: Ap :: Bp :: Cp :: As :: nil) = 4) by (apply LAApBpCpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpAsmtmp : rk(A :: Ap :: Bp :: Cp :: As :: nil) >= 4) by (solve_hyps_min HAApBpCpAseq HAApBpCpAsm4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: Ap :: Bp :: As :: nil) (Cp :: As :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: As :: nil) (A :: Ap :: Bp :: As :: Cp :: As :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: As :: Cp :: As :: nil) ((A :: Ap :: Bp :: As :: nil) ++ (Cp :: As :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpAsmtmp;try rewrite HT2 in HAApBpCpAsmtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: As :: nil) (Cp :: As :: nil) (As :: nil) 4 1 2 HAApBpCpAsmtmp HAsmtmp HCpAsMtmp Hincl);apply HT.
}
try clear HCpAsM1. try clear HCpAsM2. try clear HCpAsM3. try clear HCpAsm4. try clear HCpAsm3. try clear HCpAsm2. try clear HCpAsm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpAsgamma requis par la preuve de (?)AApBpAsgamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpAsgamma requis par la preuve de (?)AApBpAsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: gamma ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpAsgammam2 : rk(A :: Ap :: Bp :: As :: gamma :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpAsgammaeq : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) = 4) by (apply LABCApBpAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsgammamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) >= 4) by (solve_hyps_min HABCApBpAsgammaeq HABCApBpAsgammam4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: gamma :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: As :: gamma :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsgammamtmp;try rewrite HT2 in HABCApBpAsgammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: As :: gamma :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpAsgammamtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HAApBpAsgammam3 : rk(A :: Ap :: Bp :: As :: gamma :: nil) >= 3).
{
	assert(HAApBpAsmtmp : rk(A :: Ap :: Bp :: As :: nil) >= 3) by (solve_hyps_min HAApBpAseq HAApBpAsm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: As :: nil) (A :: Ap :: Bp :: As :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: As :: nil) (A :: Ap :: Bp :: As :: gamma :: nil) 3 3 HAApBpAsmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Bp :: As :: gamma ::  de rang :  4 et 4 	 AiB : A :: Ap :: As :: gamma ::  de rang :  4 et 4 	 A : A :: C :: Ap :: As :: gamma ::   de rang : 4 et 4 *)
assert(HAApBpAsgammam4 : rk(A :: Ap :: Bp :: As :: gamma :: nil) >= 4).
{
	try assert(HACApAsgammaeq : rk(A :: C :: Ap :: As :: gamma :: nil) = 4) by (apply LACApAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACApAsgammaMtmp : rk(A :: C :: Ap :: As :: gamma :: nil) <= 4) by (solve_hyps_max HACApAsgammaeq HACApAsgammaM4).
	try assert(HACApBpAsgammaeq : rk(A :: C :: Ap :: Bp :: As :: gamma :: nil) = 4) by (apply LACApBpAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACApBpAsgammamtmp : rk(A :: C :: Ap :: Bp :: As :: gamma :: nil) >= 4) by (solve_hyps_min HACApBpAsgammaeq HACApBpAsgammam4).
	try assert(HAApAsgammaeq : rk(A :: Ap :: As :: gamma :: nil) = 4) by (apply LAApAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsgammamtmp : rk(A :: Ap :: As :: gamma :: nil) >= 4) by (solve_hyps_min HAApAsgammaeq HAApAsgammam4).
	assert(Hincl : incl (A :: Ap :: As :: gamma :: nil) (list_inter (A :: C :: Ap :: As :: gamma :: nil) (A :: Ap :: Bp :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: As :: gamma :: nil) (A :: C :: Ap :: As :: gamma :: A :: Ap :: Bp :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: As :: gamma :: A :: Ap :: Bp :: As :: gamma :: nil) ((A :: C :: Ap :: As :: gamma :: nil) ++ (A :: Ap :: Bp :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpAsgammamtmp;try rewrite HT2 in HACApBpAsgammamtmp.
	assert(HT := rule_4 (A :: C :: Ap :: As :: gamma :: nil) (A :: Ap :: Bp :: As :: gamma :: nil) (A :: Ap :: As :: gamma :: nil) 4 4 4 HACApBpAsgammamtmp HAApAsgammamtmp HACApAsgammaMtmp Hincl); apply HT.
}


assert(HAApBpAsgammaM : rk(A :: Ap :: Bp :: As :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpAsgammam : rk(A :: Ap :: Bp :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HAApBpAsgammaeq HAApBpAsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Bp :: As :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABpAsgamma requis par la preuve de (?)ABpAsgamma pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABpAsCsbetagamma requis par la preuve de (?)ABpAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpAsCsbetagamma requis par la preuve de (?)ABpAsCsbetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsCsbetagamma requis par la preuve de (?)ABpAsCsbetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsCsbetagamma requis par la preuve de (?)ABCBpAsCsbetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsCsbetagammam4 : rk(A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpAs requis par la preuve de (?)ABpAsCsbetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpAs requis par la preuve de (?)ABpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HABpAsm2 : rk(A :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCBpAsalphaeq : rk(A :: B :: C :: Bp :: As :: alpha :: nil) = 4) by (apply LABCBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsalphamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: nil) (A :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: As :: B :: C :: alpha :: nil) ((A :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphamtmp;try rewrite HT2 in HABCBpAsalphamtmp.
	assert(HT := rule_2 (A :: Bp :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCBpAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpAsCsbetagamma requis par la preuve de (?)ABpAsCsbetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Cs :: beta :: gamma ::  de rang :  4 et 4 	 AiB : A :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HABpAsCsbetagammam2 : rk(A :: Bp :: As :: Cs :: beta :: gamma :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsCsbetagammamtmp : rk(A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HABCBpAsCsbetagammaeq HABCBpAsCsbetagammam4).
	assert(HABpAsmtmp : rk(A :: Bp :: As :: nil) >= 2) by (solve_hyps_min HABpAseq HABpAsm2).
	assert(Hincl : incl (A :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (A :: Bp :: As :: Cs :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil) (A :: B :: C :: Bp :: As :: A :: Bp :: As :: Cs :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: A :: Bp :: As :: Cs :: beta :: gamma :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (A :: Bp :: As :: Cs :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsCsbetagammamtmp;try rewrite HT2 in HABCBpAsCsbetagammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (A :: Bp :: As :: Cs :: beta :: gamma :: nil) (A :: Bp :: As :: nil) 4 2 4 HABCBpAsCsbetagammamtmp HABpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}
try clear HABCBpAsCsbetagammaM1. try clear HABCBpAsCsbetagammaM2. try clear HABCBpAsCsbetagammaM3. try clear HABCBpAsCsbetagammam4. try clear HABCBpAsCsbetagammam3. try clear HABCBpAsCsbetagammam2. try clear HABCBpAsCsbetagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpAsCsbetagammam4 : rk(A :: Bp :: As :: Cs :: beta :: gamma :: nil) >= 4).
{
	try assert(HABpAsCseq : rk(A :: Bp :: As :: Cs :: nil) = 4) by (apply LABpAsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABpAsCsmtmp : rk(A :: Bp :: As :: Cs :: nil) >= 4) by (solve_hyps_min HABpAsCseq HABpAsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: As :: Cs :: nil) (A :: Bp :: As :: Cs :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: As :: Cs :: nil) (A :: Bp :: As :: Cs :: beta :: gamma :: nil) 4 4 HABpAsCsmtmp Hcomp Hincl);apply HT.
}
try clear HABpAsCsM1. try clear HABpAsCsM2. try clear HABpAsCsM3. try clear HABpAsCsm4. try clear HABpAsCsm3. try clear HABpAsCsm2. try clear HABpAsCsm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpAsgamma requis par la preuve de (?)ABpAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsgamma requis par la preuve de (?)ABpAsgamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsgamma requis par la preuve de (?)ABCBpAsgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsgammam4 : rk(A :: B :: C :: Bp :: As :: gamma :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: gamma :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpAsgamma requis par la preuve de (?)ABpAsgamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: gamma ::  de rang :  4 et 4 	 AiB : A :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HABpAsgammam2 : rk(A :: Bp :: As :: gamma :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsgammamtmp : rk(A :: B :: C :: Bp :: As :: gamma :: nil) >= 4) by (solve_hyps_min HABCBpAsgammaeq HABCBpAsgammam4).
	assert(HABpAsmtmp : rk(A :: Bp :: As :: nil) >= 2) by (solve_hyps_min HABpAseq HABpAsm2).
	assert(Hincl : incl (A :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (A :: Bp :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: gamma :: nil) (A :: B :: C :: Bp :: As :: A :: Bp :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: A :: Bp :: As :: gamma :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (A :: Bp :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsgammamtmp;try rewrite HT2 in HABCBpAsgammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (A :: Bp :: As :: gamma :: nil) (A :: Bp :: As :: nil) 4 2 4 HABCBpAsgammamtmp HABpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}
try clear HABCBpAsgammaM1. try clear HABCBpAsgammaM2. try clear HABCBpAsgammaM3. try clear HABCBpAsgammam4. try clear HABCBpAsgammam3. try clear HABCBpAsgammam2. try clear HABCBpAsgammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: Bp :: As :: Cs :: beta :: gamma ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : As :: Cs :: beta ::   de rang : 2 et 2 *)
assert(HABpAsgammam3 : rk(A :: Bp :: As :: gamma :: nil) >= 3).
{
	try assert(HAsCsbetaeq : rk(As :: Cs :: beta :: nil) = 2) by (apply LAsCsbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsCsbetaMtmp : rk(As :: Cs :: beta :: nil) <= 2) by (solve_hyps_max HAsCsbetaeq HAsCsbetaM2).
	assert(HABpAsCsbetagammamtmp : rk(A :: Bp :: As :: Cs :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HABpAsCsbetagammaeq HABpAsCsbetagammam4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (As :: Cs :: beta :: nil) (A :: Bp :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: As :: Cs :: beta :: gamma :: nil) (As :: Cs :: beta :: A :: Bp :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: Cs :: beta :: A :: Bp :: As :: gamma :: nil) ((As :: Cs :: beta :: nil) ++ (A :: Bp :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpAsCsbetagammamtmp;try rewrite HT2 in HABpAsCsbetagammamtmp.
	assert(HT := rule_4 (As :: Cs :: beta :: nil) (A :: Bp :: As :: gamma :: nil) (As :: nil) 4 1 2 HABpAsCsbetagammamtmp HAsmtmp HAsCsbetaMtmp Hincl); apply HT.
}
try clear HABpAsCsbetagammaM1. try clear HABpAsCsbetagammaM2. try clear HABpAsCsbetagammaM3. try clear HABpAsCsbetagammam4. try clear HABpAsCsbetagammam3. try clear HABpAsCsbetagammam2. try clear HABpAsCsbetagammam1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABpAsgammam4 : rk(A :: Bp :: As :: gamma :: nil) >= 4).
{
	try assert(HApBpAsgammaeq : rk(Ap :: Bp :: As :: gamma :: nil) = 3) by (apply LApBpAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpAsgammaMtmp : rk(Ap :: Bp :: As :: gamma :: nil) <= 3) by (solve_hyps_max HApBpAsgammaeq HApBpAsgammaM3).
	try assert(HAApBpAsgammaeq : rk(A :: Ap :: Bp :: As :: gamma :: nil) = 4) by (apply LAApBpAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpAsgammamtmp : rk(A :: Ap :: Bp :: As :: gamma :: nil) >= 4) by (solve_hyps_min HAApBpAsgammaeq HAApBpAsgammam4).
	try assert(HBpAsgammaeq : rk(Bp :: As :: gamma :: nil) = 3) by (apply LBpAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpAsgammamtmp : rk(Bp :: As :: gamma :: nil) >= 3) by (solve_hyps_min HBpAsgammaeq HBpAsgammam3).
	assert(Hincl : incl (Bp :: As :: gamma :: nil) (list_inter (A :: Bp :: As :: gamma :: nil) (Ap :: Bp :: As :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: As :: gamma :: nil) (A :: Bp :: As :: gamma :: Ap :: Bp :: As :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: As :: gamma :: Ap :: Bp :: As :: gamma :: nil) ((A :: Bp :: As :: gamma :: nil) ++ (Ap :: Bp :: As :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpAsgammamtmp;try rewrite HT2 in HAApBpAsgammamtmp.
	assert(HT := rule_2 (A :: Bp :: As :: gamma :: nil) (Ap :: Bp :: As :: gamma :: nil) (Bp :: As :: gamma :: nil) 4 3 3 HAApBpAsgammamtmp HBpAsgammamtmp HApBpAsgammaMtmp Hincl);apply HT.
}


assert(HABpAsgammaM : rk(A :: Bp :: As :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpAsgammam : rk(A :: Bp :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HABpAsgammaeq HABpAsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsgamma requis par la preuve de (?)ABCBpAsgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsgammam4 : rk(A :: B :: C :: Bp :: As :: gamma :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: gamma :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsgammaM : rk(A :: B :: C :: Bp :: As :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsgammam : rk(A :: B :: C :: Bp :: As :: gamma ::  nil) >= 1) by (solve_hyps_min HABCBpAsgammaeq HABCBpAsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApAsBsgamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As :: Bs :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsBsgamma requis par la preuve de (?)ABCApAsBsgamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsBsgammam4 : rk(A :: B :: C :: Ap :: As :: Bs :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Bs :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Bs :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsBsgammaM : rk(A :: B :: C :: Ap :: As :: Bs :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsBsgammam : rk(A :: B :: C :: Ap :: As :: Bs :: gamma ::  nil) >= 1) by (solve_hyps_min HABCApAsBsgammaeq HABCApAsBsgammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpalphagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpalphagamma requis par la preuve de (?)ABCApBpCpalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpalphagammam4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpCpalphagammaM : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpalphagammam : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HABCApBpCpalphagammaeq HABCApBpCpalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpAsalphagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: C :: Bp :: As :: alpha :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsalphagamma requis par la preuve de (?)BCBpAsalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsalphagamma requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsalphagamma requis par la preuve de (?)ABCBpAsalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsalphagammam4 : rk(A :: B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: alpha :: gamma :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsalphagamma requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsalphagamma requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsalphagamma requis par la preuve de (?)ABCApBpAsalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsalphagammam4 : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsalphagamma requis par la preuve de (?)BCBpAsalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsalphagammam2 : rk(B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsalphagammamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HABCApBpAsalphagammaeq HABCApBpAsalphagammam4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: gamma :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsalphagammamtmp;try rewrite HT2 in HABCApBpAsalphagammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsalphagammamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsalphagammaM1. try clear HABCApBpAsalphagammaM2. try clear HABCApBpAsalphagammaM3. try clear HABCApBpAsalphagammam4. try clear HABCApBpAsalphagammam3. try clear HABCApBpAsalphagammam2. try clear HABCApBpAsalphagammam1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsalphagammam3 : rk(B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsalphagammamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HABCBpAsalphagammaeq HABCBpAsalphagammam4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: gamma :: nil) (A :: As :: B :: C :: Bp :: As :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: alpha :: gamma :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphagammamtmp;try rewrite HT2 in HABCBpAsalphagammamtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil) (As :: nil) 4 1 2 HABCBpAsalphagammamtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}
try clear HABCBpAsalphagammaM1. try clear HABCBpAsalphagammaM2. try clear HABCBpAsalphagammaM3. try clear HABCBpAsalphagammam4. try clear HABCBpAsalphagammam3. try clear HABCBpAsalphagammam2. try clear HABCBpAsalphagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsalphagammam4 : rk(B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: alpha :: gamma :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}


assert(HBCBpAsalphagammaM : rk(B :: C :: Bp :: As :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpAsalphagammam : rk(B :: C :: Bp :: As :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HBCBpAsalphagammaeq HBCBpAsalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAsalphagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As :: alpha :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsalphagamma requis par la preuve de (?)ABCBpAsalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsalphagammam4 : rk(A :: B :: C :: Bp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: alpha :: gamma :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsalphagammaM : rk(A :: B :: C :: Bp :: As :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsalphagammam : rk(A :: B :: C :: Bp :: As :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HABCBpAsalphagammaeq HABCBpAsalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpAsalphagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsalphagamma requis par la preuve de (?)ABCApBpAsalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsalphagammam4 : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpAsalphagammaM : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpAsalphagammam : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HABCApBpAsalphagammaeq HABCApBpAsalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpCpAsalphagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: Cp :: As :: alpha :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpAsalphagamma requis par la preuve de (?)AApBpCpAsalphagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpAsalphagamma requis par la preuve de (?)AApBpCpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAsalphagamma requis par la preuve de (?)ABCApBpCpAsalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsalphagammam4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpAsalphagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpAsalphagamma requis par la preuve de (?)AApBpCpAsalphagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpAsalphagammam2 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpAsalphagammamtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 4) by (solve_hyps_min HABCApBpCpAsalphagammaeq HABCApBpCpAsalphagammam4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpAsalphagammamtmp;try rewrite HT2 in HABCApBpCpAsalphagammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpAsalphagammamtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpAsalphagammaM1. try clear HABCApBpCpAsalphagammaM2. try clear HABCApBpCpAsalphagammaM3. try clear HABCApBpCpAsalphagammam4. try clear HABCApBpCpAsalphagammam3. try clear HABCApBpCpAsalphagammam2. try clear HABCApBpCpAsalphagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpAsalphagammam4 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


assert(HAApBpCpAsalphagammaM : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpAsalphagammam : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HAApBpCpAsalphagammaeq HAApBpCpAsalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpAsalphagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAsalphagamma requis par la preuve de (?)ABCApBpCpAsalphagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsalphagammam4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpCpAsalphagammaM : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpAsalphagammam : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: gamma ::  nil) >= 1) by (solve_hyps_min HABCApBpCpAsalphagammaeq HABCApBpCpAsalphagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApAsCsbetagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: As :: Cs :: beta :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApAsCsbetagamma requis par la preuve de (?)AApAsCsbetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApAsCsbetagamma requis par la preuve de (?)AApAsCsbetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsCsbetagamma requis par la preuve de (?)ABCApAsCsbetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsCsbetagammam4 : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAsCsbetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApAsm2 : rk(A :: Ap :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: Ap :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: As :: B :: C :: alpha :: nil) ((A :: Ap :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: Ap :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApAsCsbetagamma requis par la preuve de (?)AApAsCsbetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: Cs :: beta :: gamma ::  de rang :  4 et 4 	 AiB : A :: Ap :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: As ::   de rang : 4 et 4 *)
assert(HAApAsCsbetagammam2 : rk(A :: Ap :: As :: Cs :: beta :: gamma :: nil) >= 2).
{
	try assert(HABCApAseq : rk(A :: B :: C :: Ap :: As :: nil) = 4) by (apply LABCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsMtmp : rk(A :: B :: C :: Ap :: As :: nil) <= 4) by (solve_hyps_max HABCApAseq HABCApAsM4).
	assert(HABCApAsCsbetagammamtmp : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HABCApAsCsbetagammaeq HABCApAsCsbetagammam4).
	assert(HAApAsmtmp : rk(A :: Ap :: As :: nil) >= 2) by (solve_hyps_min HAApAseq HAApAsm2).
	assert(Hincl : incl (A :: Ap :: As :: nil) (list_inter (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Cs :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil) (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Cs :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Cs :: beta :: gamma :: nil) ((A :: B :: C :: Ap :: As :: nil) ++ (A :: Ap :: As :: Cs :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsCsbetagammamtmp;try rewrite HT2 in HABCApAsCsbetagammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Cs :: beta :: gamma :: nil) (A :: Ap :: As :: nil) 4 2 4 HABCApAsCsbetagammamtmp HAApAsmtmp HABCApAsMtmp Hincl); apply HT.
}
try clear HABCApAsCsbetagammaM1. try clear HABCApAsCsbetagammaM2. try clear HABCApAsCsbetagammaM3. try clear HABCApAsCsbetagammam4. try clear HABCApAsCsbetagammam3. try clear HABCApAsCsbetagammam2. try clear HABCApAsCsbetagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApAsCsbetagammam4 : rk(A :: Ap :: As :: Cs :: beta :: gamma :: nil) >= 4).
{
	try assert(HAApAsCseq : rk(A :: Ap :: As :: Cs :: nil) = 4) by (apply LAApAsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsCsmtmp : rk(A :: Ap :: As :: Cs :: nil) >= 4) by (solve_hyps_min HAApAsCseq HAApAsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: As :: Cs :: nil) (A :: Ap :: As :: Cs :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: As :: Cs :: nil) (A :: Ap :: As :: Cs :: beta :: gamma :: nil) 4 4 HAApAsCsmtmp Hcomp Hincl);apply HT.
}


assert(HAApAsCsbetagammaM : rk(A :: Ap :: As :: Cs :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApAsCsbetagammam : rk(A :: Ap :: As :: Cs :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HAApAsCsbetagammaeq HAApAsCsbetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApAsCsbetagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As :: Cs :: beta :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsCsbetagamma requis par la preuve de (?)ABCApAsCsbetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsCsbetagammam4 : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: gamma :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsCsbetagammaM : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsCsbetagammam : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HABCApAsCsbetagammaeq HABCApAsCsbetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpAsCsbetagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Bp :: As :: Cs :: beta :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpAsCsbetagamma requis par la preuve de (?)ABpAsCsbetagamma pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsCsbetagamma requis par la preuve de (?)ABpAsCsbetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsCsbetagamma requis par la preuve de (?)ABCBpAsCsbetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsCsbetagammam4 : rk(A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpAs requis par la preuve de (?)ABpAsCsbetagamma pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpAs requis par la preuve de (?)ABpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HABpAsm2 : rk(A :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCBpAsalphaeq : rk(A :: B :: C :: Bp :: As :: alpha :: nil) = 4) by (apply LABCBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsalphamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: nil) (A :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: As :: B :: C :: alpha :: nil) ((A :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphamtmp;try rewrite HT2 in HABCBpAsalphamtmp.
	assert(HT := rule_2 (A :: Bp :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCBpAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpAsCsbetagamma requis par la preuve de (?)ABpAsCsbetagamma pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Cs :: beta :: gamma ::  de rang :  4 et 4 	 AiB : A :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HABpAsCsbetagammam2 : rk(A :: Bp :: As :: Cs :: beta :: gamma :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsCsbetagammamtmp : rk(A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil) >= 4) by (solve_hyps_min HABCBpAsCsbetagammaeq HABCBpAsCsbetagammam4).
	assert(HABpAsmtmp : rk(A :: Bp :: As :: nil) >= 2) by (solve_hyps_min HABpAseq HABpAsm2).
	assert(Hincl : incl (A :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (A :: Bp :: As :: Cs :: beta :: gamma :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil) (A :: B :: C :: Bp :: As :: A :: Bp :: As :: Cs :: beta :: gamma :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: A :: Bp :: As :: Cs :: beta :: gamma :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (A :: Bp :: As :: Cs :: beta :: gamma :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsCsbetagammamtmp;try rewrite HT2 in HABCBpAsCsbetagammamtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (A :: Bp :: As :: Cs :: beta :: gamma :: nil) (A :: Bp :: As :: nil) 4 2 4 HABCBpAsCsbetagammamtmp HABpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}
try clear HABCBpAsCsbetagammaM1. try clear HABCBpAsCsbetagammaM2. try clear HABCBpAsCsbetagammaM3. try clear HABCBpAsCsbetagammam4. try clear HABCBpAsCsbetagammam3. try clear HABCBpAsCsbetagammam2. try clear HABCBpAsCsbetagammam1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpAsCsbetagammam4 : rk(A :: Bp :: As :: Cs :: beta :: gamma :: nil) >= 4).
{
	try assert(HABpAsCseq : rk(A :: Bp :: As :: Cs :: nil) = 4) by (apply LABpAsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABpAsCsmtmp : rk(A :: Bp :: As :: Cs :: nil) >= 4) by (solve_hyps_min HABpAsCseq HABpAsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: As :: Cs :: nil) (A :: Bp :: As :: Cs :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: As :: Cs :: nil) (A :: Bp :: As :: Cs :: beta :: gamma :: nil) 4 4 HABpAsCsmtmp Hcomp Hincl);apply HT.
}
try clear HABpAsCsM1. try clear HABpAsCsM2. try clear HABpAsCsM3. try clear HABpAsCsm4. try clear HABpAsCsm3. try clear HABpAsCsm2. try clear HABpAsCsm1. 

assert(HABpAsCsbetagammaM : rk(A :: Bp :: As :: Cs :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpAsCsbetagammam : rk(A :: Bp :: As :: Cs :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HABpAsCsbetagammaeq HABpAsCsbetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAsCsbetagamma : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As :: Cs :: beta :: gamma ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsCsbetagamma requis par la preuve de (?)ABCBpAsCsbetagamma pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsCsbetagammam4 : rk(A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Cs :: beta :: gamma :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsCsbetagammaM : rk(A :: B :: C :: Bp :: As :: Cs :: beta :: gamma ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsCsbetagammam : rk(A :: B :: C :: Bp :: As :: Cs :: beta :: gamma ::  nil) >= 1) by (solve_hyps_min HABCBpAsCsbetagammaeq HABCBpAsCsbetagammam1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Oo ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HOoM : rk(Oo ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HOoeq HOoM1).
assert(HOom : rk(Oo ::  nil) >= 1) by (solve_hyps_min HOoeq HOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LAOo *)
(* dans constructLemma(), requis par LAApAsOo *)
(* dans la couche 0 *)
Lemma LAApAsCsbetaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: As :: Cs :: beta :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApAsCsbetaOo requis par la preuve de (?)AApAsCsbetaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApAsCsbetaOo requis par la preuve de (?)AApAsCsbetaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsCsbetaOo requis par la preuve de (?)ABCApAsCsbetaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsCsbetaOom4 : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAsCsbetaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApAsm2 : rk(A :: Ap :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: Ap :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: As :: B :: C :: alpha :: nil) ((A :: Ap :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: Ap :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApAsCsbetaOo requis par la preuve de (?)AApAsCsbetaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: Cs :: beta :: Oo ::  de rang :  4 et 4 	 AiB : A :: Ap :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: As ::   de rang : 4 et 4 *)
assert(HAApAsCsbetaOom2 : rk(A :: Ap :: As :: Cs :: beta :: Oo :: nil) >= 2).
{
	try assert(HABCApAseq : rk(A :: B :: C :: Ap :: As :: nil) = 4) by (apply LABCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsMtmp : rk(A :: B :: C :: Ap :: As :: nil) <= 4) by (solve_hyps_max HABCApAseq HABCApAsM4).
	assert(HABCApAsCsbetaOomtmp : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: nil) >= 4) by (solve_hyps_min HABCApAsCsbetaOoeq HABCApAsCsbetaOom4).
	assert(HAApAsmtmp : rk(A :: Ap :: As :: nil) >= 2) by (solve_hyps_min HAApAseq HAApAsm2).
	assert(Hincl : incl (A :: Ap :: As :: nil) (list_inter (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: nil) (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Cs :: beta :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Cs :: beta :: Oo :: nil) ((A :: B :: C :: Ap :: As :: nil) ++ (A :: Ap :: As :: Cs :: beta :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsCsbetaOomtmp;try rewrite HT2 in HABCApAsCsbetaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: nil) (A :: Ap :: As :: nil) 4 2 4 HABCApAsCsbetaOomtmp HAApAsmtmp HABCApAsMtmp Hincl); apply HT.
}
try clear HABCApAsCsbetaOoM1. try clear HABCApAsCsbetaOoM2. try clear HABCApAsCsbetaOoM3. try clear HABCApAsCsbetaOom4. try clear HABCApAsCsbetaOom3. try clear HABCApAsCsbetaOom2. try clear HABCApAsCsbetaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApAsCsbetaOom4 : rk(A :: Ap :: As :: Cs :: beta :: Oo :: nil) >= 4).
{
	try assert(HAApAsCseq : rk(A :: Ap :: As :: Cs :: nil) = 4) by (apply LAApAsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsCsmtmp : rk(A :: Ap :: As :: Cs :: nil) >= 4) by (solve_hyps_min HAApAsCseq HAApAsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: As :: Cs :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: As :: Cs :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: nil) 4 4 HAApAsCsmtmp Hcomp Hincl);apply HT.
}


assert(HAApAsCsbetaOoM : rk(A :: Ap :: As :: Cs :: beta :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApAsCsbetaOom : rk(A :: Ap :: As :: Cs :: beta :: Oo ::  nil) >= 1) by (solve_hyps_min HAApAsCsbetaOoeq HAApAsCsbetaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApAsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: As :: Oo ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApAsOo requis par la preuve de (?)AApAsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApAsOo requis par la preuve de (?)AApAsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsOo requis par la preuve de (?)ABCApAsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsOom4 : rk(A :: B :: C :: Ap :: As :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCAs requis par la preuve de (?)AApAsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCAs requis par la preuve de (?)BCAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCAsm2 : rk(B :: C :: As :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApAsbetaeq : rk(A :: B :: C :: Ap :: As :: beta :: nil) = 4) by (apply LABCApAsbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsbetamtmp : rk(A :: B :: C :: Ap :: As :: beta :: nil) >= 4) by (solve_hyps_min HABCApAsbetaeq HABCApAsbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: As :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: beta :: nil) (B :: C :: As :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: As :: A :: C :: Ap :: beta :: nil) ((B :: C :: As :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsbetamtmp;try rewrite HT2 in HABCApAsbetamtmp.
	assert(HT := rule_2 (B :: C :: As :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApAsbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}
try clear HABCApAsbetaM1. try clear HABCApAsbetaM2. try clear HABCApAsbetaM3. try clear HABCApAsbetam4. try clear HABCApAsbetam3. try clear HABCApAsbetam2. try clear HABCApAsbetam1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApAsOo requis par la preuve de (?)AApAsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApAsOo requis par la preuve de (?)AApAsOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApAsOo requis par la preuve de (?)AApAsOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HAApAsOoM3 : rk(A :: Ap :: As :: Oo :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApAsOoMtmp : rk(Ap :: As :: Oo :: nil) <= 2) by (solve_hyps_max HApAsOoeq HApAsOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: As :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: As :: Oo :: nil) (A :: Ap :: As :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: As :: Oo :: nil) ((A :: nil) ++ (Ap :: As :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: As :: Oo :: nil) (nil) 1 2 0 HAMtmp HApAsOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: Oo ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : B :: C :: As ::   de rang : 2 et 3 *)
assert(HAApAsOom2 : rk(A :: Ap :: As :: Oo :: nil) >= 2).
{
	assert(HBCAsMtmp : rk(B :: C :: As :: nil) <= 3) by (solve_hyps_max HBCAseq HBCAsM3).
	assert(HABCApAsOomtmp : rk(A :: B :: C :: Ap :: As :: Oo :: nil) >= 4) by (solve_hyps_min HABCApAsOoeq HABCApAsOom4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (B :: C :: As :: nil) (A :: Ap :: As :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: Oo :: nil) (B :: C :: As :: A :: Ap :: As :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: As :: A :: Ap :: As :: Oo :: nil) ((B :: C :: As :: nil) ++ (A :: Ap :: As :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsOomtmp;try rewrite HT2 in HABCApAsOomtmp.
	assert(HT := rule_4 (B :: C :: As :: nil) (A :: Ap :: As :: Oo :: nil) (As :: nil) 4 1 3 HABCApAsOomtmp HAsmtmp HBCAsMtmp Hincl); apply HT.
}
try clear HBCAsM1. try clear HBCAsM2. try clear HBCAsM3. try clear HBCAsm4. try clear HBCAsm3. try clear HBCAsm2. try clear HBCAsm1. try clear HABCApAsOoM1. try clear HABCApAsOoM2. try clear HABCApAsOoM3. try clear HABCApAsOom4. try clear HABCApAsOom3. try clear HABCApAsOom2. try clear HABCApAsOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: As :: Cs :: beta :: Oo ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : As :: Cs :: beta ::   de rang : 2 et 2 *)
assert(HAApAsOom3 : rk(A :: Ap :: As :: Oo :: nil) >= 3).
{
	try assert(HAsCsbetaeq : rk(As :: Cs :: beta :: nil) = 2) by (apply LAsCsbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsCsbetaMtmp : rk(As :: Cs :: beta :: nil) <= 2) by (solve_hyps_max HAsCsbetaeq HAsCsbetaM2).
	try assert(HAApAsCsbetaOoeq : rk(A :: Ap :: As :: Cs :: beta :: Oo :: nil) = 4) by (apply LAApAsCsbetaOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsCsbetaOomtmp : rk(A :: Ap :: As :: Cs :: beta :: Oo :: nil) >= 4) by (solve_hyps_min HAApAsCsbetaOoeq HAApAsCsbetaOom4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (As :: Cs :: beta :: nil) (A :: Ap :: As :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: As :: Cs :: beta :: Oo :: nil) (As :: Cs :: beta :: A :: Ap :: As :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: Cs :: beta :: A :: Ap :: As :: Oo :: nil) ((As :: Cs :: beta :: nil) ++ (A :: Ap :: As :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApAsCsbetaOomtmp;try rewrite HT2 in HAApAsCsbetaOomtmp.
	assert(HT := rule_4 (As :: Cs :: beta :: nil) (A :: Ap :: As :: Oo :: nil) (As :: nil) 4 1 2 HAApAsCsbetaOomtmp HAsmtmp HAsCsbetaMtmp Hincl); apply HT.
}


assert(HAApAsOoM : rk(A :: Ap :: As :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApAsOom : rk(A :: Ap :: As :: Oo ::  nil) >= 1) by (solve_hyps_min HAApAsOoeq HAApAsOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LAOo *)
(* dans la couche 0 *)
Lemma LApAsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HApAsOoM : rk(Ap :: As :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApAsOoeq HApAsOoM3).
assert(HApAsOom : rk(Ap :: As :: Oo ::  nil) >= 1) by (solve_hyps_min HApAsOoeq HApAsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Oo ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AOo requis par la preuve de (?)AOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAOom2 : rk(A :: Oo :: nil) >= 2).
{
	try assert(HApAsOoeq : rk(Ap :: As :: Oo :: nil) = 2) by (apply LApAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApAsOoMtmp : rk(Ap :: As :: Oo :: nil) <= 2) by (solve_hyps_max HApAsOoeq HApAsOoM2).
	try assert(HAApAsOoeq : rk(A :: Ap :: As :: Oo :: nil) = 3) by (apply LAApAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsOomtmp : rk(A :: Ap :: As :: Oo :: nil) >= 3) by (solve_hyps_min HAApAsOoeq HAApAsOom3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (A :: Oo :: nil) (Ap :: As :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: As :: Oo :: nil) (A :: Oo :: Ap :: As :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Oo :: Ap :: As :: Oo :: nil) ((A :: Oo :: nil) ++ (Ap :: As :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApAsOomtmp;try rewrite HT2 in HAApAsOomtmp.
	assert(HT := rule_2 (A :: Oo :: nil) (Ap :: As :: Oo :: nil) (Oo :: nil) 3 1 2 HAApAsOomtmp HOomtmp HApAsOoMtmp Hincl);apply HT.
}


assert(HAOoM : rk(A :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAOoeq HAOoM2).
assert(HAOom : rk(A :: Oo ::  nil) >= 1) by (solve_hyps_min HAOoeq HAOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LApOo *)
(* dans constructLemma(), requis par LApBpBsOo *)
(* dans la couche 0 *)
Lemma LApBpCpBsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpCpBsalphaOo requis par la preuve de (?)ApBpCpBsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AApBpCpBsalphaOo requis par la preuve de (?)ApBpCpBsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpBsalphaOo requis par la preuve de (?)AApBpCpBsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpBsalphaOo requis par la preuve de (?)AApBpCpBsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpBsalphaOo requis par la preuve de (?)ABCApBpCpBsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpBsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpBsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpBsalphaOo requis par la preuve de (?)AApBpCpBsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpBsalphaOom2 : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpBsalphaOomtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpCpBsalphaOoeq HABCApBpCpBsalphaOom4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpBsalphaOomtmp;try rewrite HT2 in HABCApBpCpBsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpBsalphaOomtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpBsalphaOoM1. try clear HABCApBpCpBsalphaOoM2. try clear HABCApBpCpBsalphaOoM3. try clear HABCApBpCpBsalphaOom4. try clear HABCApBpCpBsalphaOom3. try clear HABCApBpCpBsalphaOom2. try clear HABCApBpCpBsalphaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpBsalphaOom4 : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpBs requis par la preuve de (?)ApBpCpBsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpCpalpha requis par la preuve de (?)ApBpBs pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpCpalpha requis par la preuve de (?)ABpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpCpalpha requis par la preuve de (?)ACBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ACBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HACBpm2 : rk(A :: C :: Bp :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: C :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: C :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: C :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (C :: nil) 4 1 3 HABCApBpalphamtmp HCmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpCpalpha requis par la preuve de (?)ACBpCpalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: alpha ::  de rang :  4 et 4 	 AiB : A :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HACBpCpalpham2 : rk(A :: C :: Bp :: Cp :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpCpalphaeq : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) = 4) by (apply LABCApBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpCpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpCpalphaeq HABCApBpCpalpham4).
	assert(HACBpmtmp : rk(A :: C :: Bp :: nil) >= 2) by (solve_hyps_min HACBpeq HACBpm2).
	assert(Hincl : incl (A :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: Bp :: Cp :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpalphamtmp;try rewrite HT2 in HABCApBpCpalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: Bp :: Cp :: alpha :: nil) (A :: C :: Bp :: nil) 4 2 4 HABCApBpCpalphamtmp HACBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: Cp :: alpha ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACBpCpalpham3 : rk(A :: C :: Bp :: Cp :: alpha :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	try assert(HABCBpCpalphaeq : rk(A :: B :: C :: Bp :: Cp :: alpha :: nil) = 4) by (apply LABCBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpCpalphamtmp : rk(A :: B :: C :: Bp :: Cp :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpCpalphaeq HABCBpCpalpham4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: Cp :: nil) (A :: C :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: Cp :: alpha :: nil) (B :: Cp :: A :: C :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: Bp :: Cp :: alpha :: nil) ((B :: Cp :: nil) ++ (A :: C :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpCpalphamtmp;try rewrite HT2 in HABCBpCpalphamtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: Bp :: Cp :: alpha :: nil) (Cp :: nil) 4 1 2 HABCBpCpalphamtmp HCpmtmp HBCpMtmp Hincl); apply HT.
}
try clear HBCpM1. try clear HBCpM2. try clear HBCpM3. try clear HBCpm4. try clear HBCpm3. try clear HBCpm2. try clear HBCpm1. try clear HABCBpCpalphaM1. try clear HABCBpCpalphaM2. try clear HABCBpCpalphaM3. try clear HABCBpCpalpham4. try clear HABCBpCpalpham3. try clear HABCBpCpalpham2. try clear HABCBpCpalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)ABpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpCpalpha requis par la preuve de (?)ABpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpCpalpha requis par la preuve de (?)ABpCpalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABpCpalphaM3 : rk(A :: Bp :: Cp :: alpha :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	try assert(HBpCpalphaeq : rk(Bp :: Cp :: alpha :: nil) = 2) by (apply LBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpCpalphaMtmp : rk(Bp :: Cp :: alpha :: nil) <= 2) by (solve_hyps_max HBpCpalphaeq HBpCpalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: Cp :: alpha :: nil) (A :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: Cp :: alpha :: nil) ((A :: nil) ++ (Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Bp :: Cp :: alpha :: nil) (nil) 1 2 0 HAMtmp HBpCpalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: C :: Bp :: Cp :: alpha ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : C :: Cp ::   de rang : 1 et 2 *)
assert(HABpCpalpham2 : rk(A :: Bp :: Cp :: alpha :: nil) >= 2).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HACBpCpalphamtmp : rk(A :: C :: Bp :: Cp :: alpha :: nil) >= 3) by (solve_hyps_min HACBpCpalphaeq HACBpCpalpham3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (C :: Cp :: nil) (A :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: Cp :: alpha :: nil) (C :: Cp :: A :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: A :: Bp :: Cp :: alpha :: nil) ((C :: Cp :: nil) ++ (A :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACBpCpalphamtmp;try rewrite HT2 in HACBpCpalphamtmp.
	assert(HT := rule_4 (C :: Cp :: nil) (A :: Bp :: Cp :: alpha :: nil) (Cp :: nil) 3 1 2 HACBpCpalphamtmp HCpmtmp HCCpMtmp Hincl); apply HT.
}
try clear HCCpM1. try clear HCCpM2. try clear HCCpM3. try clear HCCpm4. try clear HCCpm3. try clear HCCpm2. try clear HCCpm1. try clear HCpM1. try clear HCpM2. try clear HCpM3. try clear HCpm4. try clear HCpm3. try clear HCpm2. try clear HCpm1. try clear HACBpCpalphaM1. try clear HACBpCpalphaM2. try clear HACBpCpalphaM3. try clear HACBpCpalpham4. try clear HACBpCpalpham3. try clear HACBpCpalpham2. try clear HACBpCpalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpBs requis par la preuve de (?)ApBpBs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HApBpBsm2 : rk(Ap :: Bp :: Bs :: nil) >= 2).
{
	assert(HABpCpalphaMtmp : rk(A :: Bp :: Cp :: alpha :: nil) <= 3) by (solve_hyps_max HABpCpalphaeq HABpCpalphaM3).
	try assert(HAApBpCpBsalphaeq : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) = 4) by (apply LAApBpCpBsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpBsalphamtmp : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HAApBpCpBsalphaeq HAApBpCpBsalpham4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: Bs :: nil) (A :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) (Ap :: Bp :: Bs :: A :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Bs :: A :: Bp :: Cp :: alpha :: nil) ((Ap :: Bp :: Bs :: nil) ++ (A :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpBsalphamtmp;try rewrite HT2 in HAApBpCpBsalphamtmp.
	assert(HT := rule_2 (Ap :: Bp :: Bs :: nil) (A :: Bp :: Cp :: alpha :: nil) (Bp :: nil) 4 1 3 HAApBpCpBsalphamtmp HBpmtmp HABpCpalphaMtmp Hincl);apply HT.
}
try clear HABpCpalphaM1. try clear HABpCpalphaM2. try clear HABpCpalphaM3. try clear HABpCpalpham4. try clear HABpCpalpham3. try clear HABpCpalpham2. try clear HABpCpalpham1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpBs requis par la preuve de (?)ApBpCpBsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpBs requis par la preuve de (?)AApBpBs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpBs requis par la preuve de (?)AApBpBs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpBs requis par la preuve de (?)AApBpBs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Bs ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpBsm2 : rk(A :: Ap :: Bp :: Bs :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpBseq : rk(A :: B :: C :: Ap :: Bp :: Bs :: nil) = 4) by (apply LABCApBpBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpBsmtmp : rk(A :: B :: C :: Ap :: Bp :: Bs :: nil) >= 4) by (solve_hyps_min HABCApBpBseq HABCApBpBsm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Bs :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Bs :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Bs :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Bs :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Bs :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpBsmtmp;try rewrite HT2 in HABCApBpBsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Bs :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpBsmtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpBsM1. try clear HABCApBpBsM2. try clear HABCApBpBsM3. try clear HABCApBpBsm4. try clear HABCApBpBsm3. try clear HABCApBpBsm2. try clear HABCApBpBsm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HAApBpBsm3 : rk(A :: Ap :: Bp :: Bs :: nil) >= 3).
{
	assert(HCpBsMtmp : rk(Cp :: Bs :: nil) <= 2) by (solve_hyps_max HCpBseq HCpBsM2).
	try assert(HAApBpCpBseq : rk(A :: Ap :: Bp :: Cp :: Bs :: nil) = 4) by (apply LAApBpCpBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpBsmtmp : rk(A :: Ap :: Bp :: Cp :: Bs :: nil) >= 4) by (solve_hyps_min HAApBpCpBseq HAApBpCpBsm4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (A :: Ap :: Bp :: Bs :: nil) (Cp :: Bs :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: Bs :: nil) (A :: Ap :: Bp :: Bs :: Cp :: Bs :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: Bs :: Cp :: Bs :: nil) ((A :: Ap :: Bp :: Bs :: nil) ++ (Cp :: Bs :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpBsmtmp;try rewrite HT2 in HAApBpCpBsmtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: Bs :: nil) (Cp :: Bs :: nil) (Bs :: nil) 4 1 2 HAApBpCpBsmtmp HBsmtmp HCpBsMtmp Hincl);apply HT.
}
try clear HCpBsM1. try clear HCpBsM2. try clear HCpBsM3. try clear HCpBsm4. try clear HCpBsm3. try clear HCpBsm2. try clear HCpBsm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpCpBsalphaOo requis par la preuve de (?)ApBpCpBsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: Bs ::  de rang :  2 et 3 	 A : A :: Ap :: Bp :: Bs ::   de rang : 3 et 4 *)
assert(HApBpCpBsalphaOom2 : rk(Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 2).
{
	assert(HAApBpBsMtmp : rk(A :: Ap :: Bp :: Bs :: nil) <= 4) by (solve_hyps_max HAApBpBseq HAApBpBsM4).
	assert(HAApBpCpBsalphaOomtmp : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HAApBpCpBsalphaOoeq HAApBpCpBsalphaOom4).
	assert(HApBpBsmtmp : rk(Ap :: Bp :: Bs :: nil) >= 2) by (solve_hyps_min HApBpBseq HApBpBsm2).
	assert(Hincl : incl (Ap :: Bp :: Bs :: nil) (list_inter (A :: Ap :: Bp :: Bs :: nil) (Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) (A :: Ap :: Bp :: Bs :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: Bs :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) ((A :: Ap :: Bp :: Bs :: nil) ++ (Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpBsalphaOomtmp;try rewrite HT2 in HAApBpCpBsalphaOomtmp.
	assert(HT := rule_4 (A :: Ap :: Bp :: Bs :: nil) (Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) (Ap :: Bp :: Bs :: nil) 4 2 4 HAApBpCpBsalphaOomtmp HApBpBsmtmp HAApBpBsMtmp Hincl); apply HT.
}
try clear HAApBpBsM1. try clear HAApBpBsM2. try clear HAApBpBsM3. try clear HAApBpBsm4. try clear HAApBpBsm3. try clear HAApBpBsm2. try clear HAApBpBsm1. try clear HAApBpCpBsalphaOoM1. try clear HAApBpCpBsalphaOoM2. try clear HAApBpCpBsalphaOoM3. try clear HAApBpCpBsalphaOom4. try clear HAApBpCpBsalphaOom3. try clear HAApBpCpBsalphaOom2. try clear HAApBpCpBsalphaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpBsalphaOom4 : rk(Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HApBpCpBseq : rk(Ap :: Bp :: Cp :: Bs :: nil) = 4) by (apply LApBpCpBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpCpBsmtmp : rk(Ap :: Bp :: Cp :: Bs :: nil) >= 4) by (solve_hyps_min HApBpCpBseq HApBpCpBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: Bs :: nil) (Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: Bs :: nil) (Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) 4 4 HApBpCpBsmtmp Hcomp Hincl);apply HT.
}
try clear HApBpCpBsM1. try clear HApBpCpBsM2. try clear HApBpCpBsM3. try clear HApBpCpBsm4. try clear HApBpCpBsm3. try clear HApBpCpBsm2. try clear HApBpCpBsm1. 

assert(HApBpCpBsalphaOoM : rk(Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpBsalphaOom : rk(Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HApBpCpBsalphaOoeq HApBpCpBsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpBsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Bp :: Bs :: Oo ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpBsOo requis par la preuve de (?)ApBpBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpBs requis par la preuve de (?)ApBpBsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpCpalpha requis par la preuve de (?)ApBpBs pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACBpCpalpha requis par la preuve de (?)ABpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)ACBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpCpalpha requis par la preuve de (?)ACBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ACBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HACBpm2 : rk(A :: C :: Bp :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: C :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: C :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: C :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (C :: nil) 4 1 3 HABCApBpalphamtmp HCmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpCpalpha requis par la preuve de (?)ACBpCpalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: alpha ::  de rang :  4 et 4 	 AiB : A :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HACBpCpalpham2 : rk(A :: C :: Bp :: Cp :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpCpalphaeq : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) = 4) by (apply LABCApBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpCpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpCpalphaeq HABCApBpCpalpham4).
	assert(HACBpmtmp : rk(A :: C :: Bp :: nil) >= 2) by (solve_hyps_min HACBpeq HACBpm2).
	assert(Hincl : incl (A :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: A :: C :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: C :: Bp :: Cp :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: C :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpalphamtmp;try rewrite HT2 in HABCApBpCpalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: C :: Bp :: Cp :: alpha :: nil) (A :: C :: Bp :: nil) 4 2 4 HABCApBpCpalphamtmp HACBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: Cp :: alpha ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : B :: Cp ::   de rang : 1 et 2 *)
assert(HACBpCpalpham3 : rk(A :: C :: Bp :: Cp :: alpha :: nil) >= 3).
{
	assert(HBCpMtmp : rk(B :: Cp :: nil) <= 2) by (solve_hyps_max HBCpeq HBCpM2).
	try assert(HABCBpCpalphaeq : rk(A :: B :: C :: Bp :: Cp :: alpha :: nil) = 4) by (apply LABCBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpCpalphamtmp : rk(A :: B :: C :: Bp :: Cp :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpCpalphaeq HABCBpCpalpham4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (B :: Cp :: nil) (A :: C :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: Cp :: alpha :: nil) (B :: Cp :: A :: C :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: A :: C :: Bp :: Cp :: alpha :: nil) ((B :: Cp :: nil) ++ (A :: C :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpCpalphamtmp;try rewrite HT2 in HABCBpCpalphamtmp.
	assert(HT := rule_4 (B :: Cp :: nil) (A :: C :: Bp :: Cp :: alpha :: nil) (Cp :: nil) 4 1 2 HABCBpCpalphamtmp HCpmtmp HBCpMtmp Hincl); apply HT.
}
try clear HBCpM1. try clear HBCpM2. try clear HBCpM3. try clear HBCpm4. try clear HBCpm3. try clear HBCpm2. try clear HBCpm1. try clear HABCBpCpalphaM1. try clear HABCBpCpalphaM2. try clear HABCBpCpalphaM3. try clear HABCBpCpalpham4. try clear HABCBpCpalpham3. try clear HABCBpCpalpham2. try clear HABCBpCpalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)ABpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpCpalpha requis par la preuve de (?)ABpCpalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpCpalpha requis par la preuve de (?)ABpCpalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABpCpalphaM3 : rk(A :: Bp :: Cp :: alpha :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	try assert(HBpCpalphaeq : rk(Bp :: Cp :: alpha :: nil) = 2) by (apply LBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpCpalphaMtmp : rk(Bp :: Cp :: alpha :: nil) <= 2) by (solve_hyps_max HBpCpalphaeq HBpCpalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: Cp :: alpha :: nil) (A :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: Cp :: alpha :: nil) ((A :: nil) ++ (Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Bp :: Cp :: alpha :: nil) (nil) 1 2 0 HAMtmp HBpCpalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: C :: Bp :: Cp :: alpha ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : C :: Cp ::   de rang : 1 et 2 *)
assert(HABpCpalpham2 : rk(A :: Bp :: Cp :: alpha :: nil) >= 2).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HACBpCpalphamtmp : rk(A :: C :: Bp :: Cp :: alpha :: nil) >= 3) by (solve_hyps_min HACBpCpalphaeq HACBpCpalpham3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (C :: Cp :: nil) (A :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: Cp :: alpha :: nil) (C :: Cp :: A :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: A :: Bp :: Cp :: alpha :: nil) ((C :: Cp :: nil) ++ (A :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACBpCpalphamtmp;try rewrite HT2 in HACBpCpalphamtmp.
	assert(HT := rule_4 (C :: Cp :: nil) (A :: Bp :: Cp :: alpha :: nil) (Cp :: nil) 3 1 2 HACBpCpalphamtmp HCpmtmp HCCpMtmp Hincl); apply HT.
}
try clear HCCpM1. try clear HCCpM2. try clear HCCpM3. try clear HCCpm4. try clear HCCpm3. try clear HCCpm2. try clear HCCpm1. try clear HCpM1. try clear HCpM2. try clear HCpM3. try clear HCpm4. try clear HCpm3. try clear HCpm2. try clear HCpm1. try clear HACBpCpalphaM1. try clear HACBpCpalphaM2. try clear HACBpCpalphaM3. try clear HACBpCpalpham4. try clear HACBpCpalpham3. try clear HACBpCpalpham2. try clear HACBpCpalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpBs requis par la preuve de (?)ApBpBs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HApBpBsm2 : rk(Ap :: Bp :: Bs :: nil) >= 2).
{
	assert(HABpCpalphaMtmp : rk(A :: Bp :: Cp :: alpha :: nil) <= 3) by (solve_hyps_max HABpCpalphaeq HABpCpalphaM3).
	try assert(HAApBpCpBsalphaeq : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) = 4) by (apply LAApBpCpBsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpBsalphamtmp : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HAApBpCpBsalphaeq HAApBpCpBsalpham4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: Bs :: nil) (A :: Bp :: Cp :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: Bs :: alpha :: nil) (Ap :: Bp :: Bs :: A :: Bp :: Cp :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Bs :: A :: Bp :: Cp :: alpha :: nil) ((Ap :: Bp :: Bs :: nil) ++ (A :: Bp :: Cp :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpBsalphamtmp;try rewrite HT2 in HAApBpCpBsalphamtmp.
	assert(HT := rule_2 (Ap :: Bp :: Bs :: nil) (A :: Bp :: Cp :: alpha :: nil) (Bp :: nil) 4 1 3 HAApBpCpBsalphamtmp HBpmtmp HABpCpalphaMtmp Hincl);apply HT.
}
try clear HABpCpalphaM1. try clear HABpCpalphaM2. try clear HABpCpalphaM3. try clear HABpCpalpham4. try clear HABpCpalpham3. try clear HABpCpalpham2. try clear HABpCpalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpBsOo requis par la preuve de (?)ApBpBsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BpBsOo requis par la preuve de (?)ApBpBsOo pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpBsOo requis par la preuve de (?)ApBpBsOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HApBpBsOoM3 : rk(Ap :: Bp :: Bs :: Oo :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HBpBsOoMtmp : rk(Bp :: Bs :: Oo :: nil) <= 2) by (solve_hyps_max HBpBsOoeq HBpBsOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Bs :: Oo :: nil) (Ap :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Bs :: Oo :: nil) ((Ap :: nil) ++ (Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (Bp :: Bs :: Oo :: nil) (nil) 1 2 0 HApMtmp HBpBsOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HApBpBsOom2 : rk(Ap :: Bp :: Bs :: Oo :: nil) >= 2).
{
	assert(HApBpBsmtmp : rk(Ap :: Bp :: Bs :: nil) >= 2) by (solve_hyps_min HApBpBseq HApBpBsm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Bs :: nil) (Ap :: Bp :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Bs :: nil) (Ap :: Bp :: Bs :: Oo :: nil) 2 2 HApBpBsmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Bp :: Cp :: alpha ::   de rang : 2 et 2 *)
assert(HApBpBsOom3 : rk(Ap :: Bp :: Bs :: Oo :: nil) >= 3).
{
	try assert(HBpCpalphaeq : rk(Bp :: Cp :: alpha :: nil) = 2) by (apply LBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpCpalphaMtmp : rk(Bp :: Cp :: alpha :: nil) <= 2) by (solve_hyps_max HBpCpalphaeq HBpCpalphaM2).
	try assert(HApBpCpBsalphaOoeq : rk(Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) = 4) by (apply LApBpCpBsalphaOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpCpBsalphaOomtmp : rk(Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HApBpCpBsalphaOoeq HApBpCpBsalphaOom4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Bp :: Cp :: alpha :: nil) (Ap :: Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) (Bp :: Cp :: alpha :: Ap :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Cp :: alpha :: Ap :: Bp :: Bs :: Oo :: nil) ((Bp :: Cp :: alpha :: nil) ++ (Ap :: Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpCpBsalphaOomtmp;try rewrite HT2 in HApBpCpBsalphaOomtmp.
	assert(HT := rule_4 (Bp :: Cp :: alpha :: nil) (Ap :: Bp :: Bs :: Oo :: nil) (Bp :: nil) 4 1 2 HApBpCpBsalphaOomtmp HBpmtmp HBpCpalphaMtmp Hincl); apply HT.
}


assert(HApBpBsOoM : rk(Ap :: Bp :: Bs :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpBsOom : rk(Ap :: Bp :: Bs :: Oo ::  nil) >= 1) by (solve_hyps_min HApBpBsOoeq HApBpBsOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LApOo *)
(* dans la couche 0 *)
Lemma LBpBsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bp :: Bs :: Oo ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBpBsOoM : rk(Bp :: Bs :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpBsOoeq HBpBsOoM3).
assert(HBpBsOom : rk(Bp :: Bs :: Oo ::  nil) >= 1) by (solve_hyps_min HBpBsOoeq HBpBsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Oo ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApOo requis par la preuve de (?)ApOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApOom2 : rk(Ap :: Oo :: nil) >= 2).
{
	try assert(HBpBsOoeq : rk(Bp :: Bs :: Oo :: nil) = 2) by (apply LBpBsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpBsOoMtmp : rk(Bp :: Bs :: Oo :: nil) <= 2) by (solve_hyps_max HBpBsOoeq HBpBsOoM2).
	try assert(HApBpBsOoeq : rk(Ap :: Bp :: Bs :: Oo :: nil) = 3) by (apply LApBpBsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpBsOomtmp : rk(Ap :: Bp :: Bs :: Oo :: nil) >= 3) by (solve_hyps_min HApBpBsOoeq HApBpBsOom3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Ap :: Oo :: nil) (Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Bs :: Oo :: nil) (Ap :: Oo :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: Bp :: Bs :: Oo :: nil) ((Ap :: Oo :: nil) ++ (Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpBsOomtmp;try rewrite HT2 in HApBpBsOomtmp.
	assert(HT := rule_2 (Ap :: Oo :: nil) (Bp :: Bs :: Oo :: nil) (Oo :: nil) 3 1 2 HApBpBsOomtmp HOomtmp HBpBsOoMtmp Hincl);apply HT.
}


assert(HApOoM : rk(Ap :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApOoeq HApOoM2).
assert(HApOom : rk(Ap :: Oo ::  nil) >= 1) by (solve_hyps_min HApOoeq HApOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Oo ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApOo requis par la preuve de (?)AApOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApalphaOo requis par la preuve de (?)AApOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalphaOo requis par la preuve de (?)ABCApalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalphaOom4 : rk(A :: B :: C :: Ap :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApOo requis par la preuve de (?)AApOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: alpha :: Oo ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HAApOom2 : rk(A :: Ap :: Oo :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCApalphaOomtmp : rk(A :: B :: C :: Ap :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApalphaOoeq HABCApalphaOom4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C :: alpha :: nil) (A :: Ap :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: alpha :: Oo :: nil) (B :: C :: alpha :: A :: Ap :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: Ap :: Oo :: nil) ((B :: C :: alpha :: nil) ++ (A :: Ap :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApalphaOomtmp;try rewrite HT2 in HABCApalphaOomtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: Ap :: Oo :: nil) (nil) 4 0 2 HABCApalphaOomtmp Hmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCApalphaOoM1. try clear HABCApalphaOoM2. try clear HABCApalphaOoM3. try clear HABCApalphaOom4. try clear HABCApalphaOom3. try clear HABCApalphaOom2. try clear HABCApalphaOom1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApOom3 : rk(A :: Ap :: Oo :: nil) >= 3).
{
	try assert(HApAsOoeq : rk(Ap :: As :: Oo :: nil) = 2) by (apply LApAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApAsOoMtmp : rk(Ap :: As :: Oo :: nil) <= 2) by (solve_hyps_max HApAsOoeq HApAsOoM2).
	try assert(HAApAsOoeq : rk(A :: Ap :: As :: Oo :: nil) = 3) by (apply LAApAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsOomtmp : rk(A :: Ap :: As :: Oo :: nil) >= 3) by (solve_hyps_min HAApAsOoeq HAApAsOom3).
	try assert(HApOoeq : rk(Ap :: Oo :: nil) = 2) by (apply LApOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApOomtmp : rk(Ap :: Oo :: nil) >= 2) by (solve_hyps_min HApOoeq HApOom2).
	assert(Hincl : incl (Ap :: Oo :: nil) (list_inter (A :: Ap :: Oo :: nil) (Ap :: As :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: As :: Oo :: nil) (A :: Ap :: Oo :: Ap :: As :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: Ap :: As :: Oo :: nil) ((A :: Ap :: Oo :: nil) ++ (Ap :: As :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApAsOomtmp;try rewrite HT2 in HAApAsOomtmp.
	assert(HT := rule_2 (A :: Ap :: Oo :: nil) (Ap :: As :: Oo :: nil) (Ap :: Oo :: nil) 3 2 2 HAApAsOomtmp HApOomtmp HApAsOoMtmp Hincl);apply HT.
}
try clear HApOoM1. try clear HApOoM2. try clear HApOoM3. try clear HApOom4. try clear HApOom3. try clear HApOom2. try clear HApOom1. 

assert(HAApOoM : rk(A :: Ap :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAApOoeq HAApOoM3).
assert(HAApOom : rk(A :: Ap :: Oo ::  nil) >= 1) by (solve_hyps_min HAApOoeq HAApOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApOo requis par la preuve de (?)ABCApOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApOom4 : rk(A :: B :: C :: Ap :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApOoM : rk(A :: B :: C :: Ap :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApOom : rk(A :: B :: C :: Ap :: Oo ::  nil) >= 1) by (solve_hyps_min HABCApOoeq HABCApOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpOo *)
(* dans constructLemma(), requis par LApBpAsOo *)
(* dans la couche 0 *)
Lemma LApBpCpAsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: As :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpCpAsalphaOo requis par la preuve de (?)ApBpCpAsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AApBpCpAsalphaOo requis par la preuve de (?)ApBpCpAsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpAsalphaOo requis par la preuve de (?)AApBpCpAsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpAsalphaOo requis par la preuve de (?)AApBpCpAsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAsalphaOo requis par la preuve de (?)ABCApBpCpAsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpAsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpAsalphaOo requis par la preuve de (?)AApBpCpAsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpAsalphaOom2 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpAsalphaOomtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpCpAsalphaOoeq HABCApBpCpAsalphaOom4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpAsalphaOomtmp;try rewrite HT2 in HABCApBpCpAsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpAsalphaOomtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpAsalphaOoM1. try clear HABCApBpCpAsalphaOoM2. try clear HABCApBpCpAsalphaOoM3. try clear HABCApBpCpAsalphaOom4. try clear HABCApBpCpAsalphaOom3. try clear HABCApBpCpAsalphaOom2. try clear HABCApBpCpAsalphaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpAsalphaOom4 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpAs requis par la preuve de (?)ApBpCpAsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpAs requis par la preuve de (?)ApBpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HApBpAsm2 : rk(Ap :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HBCApBpAsalphaeq : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) = 4) by (apply LBCApBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCApBpAsalphamtmp : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HBCApBpAsalphaeq HBCApBpAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Bp :: As :: alpha :: nil) (Ap :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: As :: B :: C :: alpha :: nil) ((Ap :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApBpAsalphamtmp;try rewrite HT2 in HBCApBpAsalphamtmp.
	assert(HT := rule_2 (Ap :: Bp :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HBCApBpAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpAs requis par la preuve de (?)ApBpCpAsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpAs requis par la preuve de (?)AApBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpAs requis par la preuve de (?)AApBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpAs requis par la preuve de (?)AApBpAs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpAsm2 : rk(A :: Ap :: Bp :: As :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpAseq : rk(A :: B :: C :: Ap :: Bp :: As :: nil) = 4) by (apply LABCApBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsmtmp : rk(A :: B :: C :: Ap :: Bp :: As :: nil) >= 4) by (solve_hyps_min HABCApBpAseq HABCApBpAsm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: As :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: As :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: As :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: As :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsmtmp;try rewrite HT2 in HABCApBpAsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: As :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpAsmtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsM1. try clear HABCApBpAsM2. try clear HABCApBpAsM3. try clear HABCApBpAsm4. try clear HABCApBpAsm3. try clear HABCApBpAsm2. try clear HABCApBpAsm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HAApBpAsm3 : rk(A :: Ap :: Bp :: As :: nil) >= 3).
{
	assert(HCpAsMtmp : rk(Cp :: As :: nil) <= 2) by (solve_hyps_max HCpAseq HCpAsM2).
	try assert(HAApBpCpAseq : rk(A :: Ap :: Bp :: Cp :: As :: nil) = 4) by (apply LAApBpCpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpAsmtmp : rk(A :: Ap :: Bp :: Cp :: As :: nil) >= 4) by (solve_hyps_min HAApBpCpAseq HAApBpCpAsm4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: Ap :: Bp :: As :: nil) (Cp :: As :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: As :: nil) (A :: Ap :: Bp :: As :: Cp :: As :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: As :: Cp :: As :: nil) ((A :: Ap :: Bp :: As :: nil) ++ (Cp :: As :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpAsmtmp;try rewrite HT2 in HAApBpCpAsmtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: As :: nil) (Cp :: As :: nil) (As :: nil) 4 1 2 HAApBpCpAsmtmp HAsmtmp HCpAsMtmp Hincl);apply HT.
}
try clear HCpAsM1. try clear HCpAsM2. try clear HCpAsM3. try clear HCpAsm4. try clear HCpAsm3. try clear HCpAsm2. try clear HCpAsm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpCpAsalphaOo requis par la preuve de (?)ApBpCpAsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 5*)
(* ensembles concernés AUB : A :: Ap :: Bp :: Cp :: As :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: As ::  de rang :  2 et 3 	 A : A :: Ap :: Bp :: As ::   de rang : 3 et 4 *)
assert(HApBpCpAsalphaOom2 : rk(Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 2).
{
	assert(HAApBpAsMtmp : rk(A :: Ap :: Bp :: As :: nil) <= 4) by (solve_hyps_max HAApBpAseq HAApBpAsM4).
	assert(HAApBpCpAsalphaOomtmp : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HAApBpCpAsalphaOoeq HAApBpCpAsalphaOom4).
	assert(HApBpAsmtmp : rk(Ap :: Bp :: As :: nil) >= 2) by (solve_hyps_min HApBpAseq HApBpAsm2).
	assert(Hincl : incl (Ap :: Bp :: As :: nil) (list_inter (A :: Ap :: Bp :: As :: nil) (Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) (A :: Ap :: Bp :: As :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: As :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) ((A :: Ap :: Bp :: As :: nil) ++ (Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpCpAsalphaOomtmp;try rewrite HT2 in HAApBpCpAsalphaOomtmp.
	assert(HT := rule_4 (A :: Ap :: Bp :: As :: nil) (Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) (Ap :: Bp :: As :: nil) 4 2 4 HAApBpCpAsalphaOomtmp HApBpAsmtmp HAApBpAsMtmp Hincl); apply HT.
}
try clear HAApBpCpAsalphaOoM1. try clear HAApBpCpAsalphaOoM2. try clear HAApBpCpAsalphaOoM3. try clear HAApBpCpAsalphaOom4. try clear HAApBpCpAsalphaOom3. try clear HAApBpCpAsalphaOom2. try clear HAApBpCpAsalphaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpAsalphaOom4 : rk(Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 4).
{
	try assert(HApBpCpAseq : rk(Ap :: Bp :: Cp :: As :: nil) = 4) by (apply LApBpCpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpCpAsmtmp : rk(Ap :: Bp :: Cp :: As :: nil) >= 4) by (solve_hyps_min HApBpCpAseq HApBpCpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Cp :: As :: nil) (Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Cp :: As :: nil) (Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) 4 4 HApBpCpAsmtmp Hcomp Hincl);apply HT.
}
try clear HApBpCpAsM1. try clear HApBpCpAsM2. try clear HApBpCpAsM3. try clear HApBpCpAsm4. try clear HApBpCpAsm3. try clear HApBpCpAsm2. try clear HApBpCpAsm1. 

assert(HApBpCpAsalphaOoM : rk(Ap :: Bp :: Cp :: As :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpAsalphaOom : rk(Ap :: Bp :: Cp :: As :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HApBpCpAsalphaOoeq HApBpCpAsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpAsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Ap :: Bp :: As :: Oo ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpAsOo requis par la preuve de (?)ApBpAsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpAs requis par la preuve de (?)ApBpAsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpAs requis par la preuve de (?)ApBpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HApBpAsm2 : rk(Ap :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HBCApBpAsalphaeq : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) = 4) by (apply LBCApBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCApBpAsalphamtmp : rk(B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HBCApBpAsalphaeq HBCApBpAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Bp :: As :: alpha :: nil) (Ap :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: As :: B :: C :: alpha :: nil) ((Ap :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApBpAsalphamtmp;try rewrite HT2 in HBCApBpAsalphamtmp.
	assert(HT := rule_2 (Ap :: Bp :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HBCApBpAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpAsOo requis par la preuve de (?)ApBpAsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpAsOo requis par la preuve de (?)ApBpAsOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApBpAsOoM3 : rk(Ap :: Bp :: As :: Oo :: nil) <= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HApAsOoeq : rk(Ap :: As :: Oo :: nil) = 2) by (apply LApAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApAsOoMtmp : rk(Ap :: As :: Oo :: nil) <= 2) by (solve_hyps_max HApAsOoeq HApAsOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (Ap :: As :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: As :: Oo :: nil) (Bp :: Ap :: As :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Ap :: As :: Oo :: nil) ((Bp :: nil) ++ (Ap :: As :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (Ap :: As :: Oo :: nil) (nil) 1 2 0 HBpMtmp HApAsOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HApBpAsOom2 : rk(Ap :: Bp :: As :: Oo :: nil) >= 2).
{
	assert(HApBpAsmtmp : rk(Ap :: Bp :: As :: nil) >= 2) by (solve_hyps_min HApBpAseq HApBpAsm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: As :: nil) (Ap :: Bp :: As :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: As :: nil) (Ap :: Bp :: As :: Oo :: nil) 2 2 HApBpAsmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Cp :: As :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Bp :: Cp :: alpha ::   de rang : 2 et 2 *)
assert(HApBpAsOom3 : rk(Ap :: Bp :: As :: Oo :: nil) >= 3).
{
	try assert(HBpCpalphaeq : rk(Bp :: Cp :: alpha :: nil) = 2) by (apply LBpCpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpCpalphaMtmp : rk(Bp :: Cp :: alpha :: nil) <= 2) by (solve_hyps_max HBpCpalphaeq HBpCpalphaM2).
	try assert(HApBpCpAsalphaOoeq : rk(Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) = 4) by (apply LApBpCpAsalphaOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpCpAsalphaOomtmp : rk(Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HApBpCpAsalphaOoeq HApBpCpAsalphaOom4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Bp :: Cp :: alpha :: nil) (Ap :: Bp :: As :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) (Bp :: Cp :: alpha :: Ap :: Bp :: As :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Cp :: alpha :: Ap :: Bp :: As :: Oo :: nil) ((Bp :: Cp :: alpha :: nil) ++ (Ap :: Bp :: As :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpCpAsalphaOomtmp;try rewrite HT2 in HApBpCpAsalphaOomtmp.
	assert(HT := rule_4 (Bp :: Cp :: alpha :: nil) (Ap :: Bp :: As :: Oo :: nil) (Bp :: nil) 4 1 2 HApBpCpAsalphaOomtmp HBpmtmp HBpCpalphaMtmp Hincl); apply HT.
}


assert(HApBpAsOoM : rk(Ap :: Bp :: As :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpAsOom : rk(Ap :: Bp :: As :: Oo ::  nil) >= 1) by (solve_hyps_min HApBpAsOoeq HApBpAsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bp :: Oo ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpOo requis par la preuve de (?)BpOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpOom2 : rk(Bp :: Oo :: nil) >= 2).
{
	try assert(HApAsOoeq : rk(Ap :: As :: Oo :: nil) = 2) by (apply LApAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApAsOoMtmp : rk(Ap :: As :: Oo :: nil) <= 2) by (solve_hyps_max HApAsOoeq HApAsOoM2).
	try assert(HApBpAsOoeq : rk(Ap :: Bp :: As :: Oo :: nil) = 3) by (apply LApBpAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApBpAsOomtmp : rk(Ap :: Bp :: As :: Oo :: nil) >= 3) by (solve_hyps_min HApBpAsOoeq HApBpAsOom3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Bp :: Oo :: nil) (Ap :: As :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: As :: Oo :: nil) (Bp :: Oo :: Ap :: As :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Oo :: Ap :: As :: Oo :: nil) ((Bp :: Oo :: nil) ++ (Ap :: As :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpAsOomtmp;try rewrite HT2 in HApBpAsOomtmp.
	assert(HT := rule_2 (Bp :: Oo :: nil) (Ap :: As :: Oo :: nil) (Oo :: nil) 3 1 2 HApBpAsOomtmp HOomtmp HApAsOoMtmp Hincl);apply HT.
}


assert(HBpOoM : rk(Bp :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpOoeq HBpOoM2).
assert(HBpOom : rk(Bp :: Oo ::  nil) >= 1) by (solve_hyps_min HBpOoeq HBpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBpOo *)
(* dans constructLemma(), requis par LBBpBsOo *)
(* dans la couche 0 *)
Lemma LBBpBsCsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: Bs :: Cs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpBsCsalphaOo requis par la preuve de (?)BBpBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BBpAsBsCsalphaOo requis par la preuve de (?)BBpBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpAsBsCsalphaOo requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)ABCBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOom4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)ABCApBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsBsCsalphaOom2 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsCsalphaOoeq HABCApBpAsBsCsalphaOom4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCApBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsBsCsalphaOomtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsBsCsalphaOom3 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoeq HABCBpAsBsCsalphaOom4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (As :: nil) 4 1 2 HABCBpAsBsCsalphaOomtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsBsCsalphaOom4 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBs requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpAsBsCsalphaOo requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpAs requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsalpham2 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpAsalphaeq : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) = 4) by (apply LABCApBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpAsalphaeq HABCApBpAsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsalphamtmp;try rewrite HT2 in HABCApBpAsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsalphamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsalpham3 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	try assert(HABCBpAsalphaeq : rk(A :: B :: C :: Bp :: As :: alpha :: nil) = 4) by (apply LABCBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsalphamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: nil) (A :: As :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: alpha :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphamtmp;try rewrite HT2 in HABCBpAsalphamtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil) (As :: nil) 4 1 2 HABCBpAsalphamtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpAs requis par la preuve de (?)BBpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HBBpAsm2 : rk(B :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpAsalphamtmp : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3) by (solve_hyps_min HBCBpAsalphaeq HBCBpAsalpham3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: alpha :: nil) (B :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: As :: B :: C :: alpha :: nil) ((B :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsalphamtmp;try rewrite HT2 in HBCBpAsalphamtmp.
	assert(HT := rule_2 (B :: Bp :: As :: nil) (B :: C :: alpha :: nil) (B :: nil) 3 1 2 HBCBpAsalphamtmp HBmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpAsBsCsalphaOo requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : B :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HBBpAsBsCsalphaOom2 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoeq HABCBpAsBsCsalphaOom4).
	assert(HBBpAsmtmp : rk(B :: Bp :: As :: nil) >= 2) by (solve_hyps_min HBBpAseq HBBpAsm2).
	assert(Hincl : incl (B :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: C :: Bp :: As :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (B :: Bp :: As :: nil) 4 2 4 HABCBpAsBsCsalphaOomtmp HBBpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : C :: Bs ::   de rang : 1 et 2 *)
assert(HBBpAsBsCsalphaOom3 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 3).
{
	assert(HCBsMtmp : rk(C :: Bs :: nil) <= 2) by (solve_hyps_max HCBseq HCBsM2).
	assert(HBCBpAsBsCsalphaOomtmp : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HBCBpAsBsCsalphaOoeq HBCBpAsBsCsalphaOom4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (C :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (C :: Bs :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bs :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((C :: Bs :: nil) ++ (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsBsCsalphaOomtmp;try rewrite HT2 in HBCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (C :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (Bs :: nil) 4 1 2 HBCBpAsBsCsalphaOomtmp HBsmtmp HCBsMtmp Hincl); apply HT.
}
try clear HBCBpAsBsCsalphaOoM1. try clear HBCBpAsBsCsalphaOoM2. try clear HBCBpAsBsCsalphaOoM3. try clear HBCBpAsBsCsalphaOom4. try clear HBCBpAsBsCsalphaOom3. try clear HBCBpAsBsCsalphaOom2. try clear HBCBpAsBsCsalphaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpAsBsCsalphaOom4 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HBBpAsBseq : rk(B :: Bp :: As :: Bs :: nil) = 4) by (apply LBBpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpAsBsmtmp : rk(B :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HBBpAsBseq HBBpAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: As :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: As :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HBBpAsBsmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AsCs requis par la preuve de (?)BBpBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpBsCsalphaOo requis par la preuve de (?)BBpBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpBsCsalphaOo requis par la preuve de (?)BBpBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBsCsalphaOo requis par la preuve de (?)ABCBpBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsCsalphaOom4 : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpBs requis par la preuve de (?)BBpBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpBsalpha requis par la preuve de (?)BBpBs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABs requis par la preuve de (?)BCBpBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpBsalpha requis par la preuve de (?)BCBpBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpBsalpha requis par la preuve de (?)BCBpBsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Bs :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpBsalpham2 : rk(B :: C :: Bp :: Bs :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpBsalphaeq : rk(A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) = 4) by (apply LABCApBpBsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpBsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpBsalphaeq HABCApBpBsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: Bs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: Bs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: Bs :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: Bs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpBsalphamtmp;try rewrite HT2 in HABCApBpBsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: Bs :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpBsalphamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpBsalphaM1. try clear HABCApBpBsalphaM2. try clear HABCApBpBsalphaM3. try clear HABCApBpBsalpham4. try clear HABCApBpBsalpham3. try clear HABCApBpBsalpham2. try clear HABCApBpBsalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: Bs :: alpha ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : A :: Bs ::   de rang : 1 et 2 *)
assert(HBCBpBsalpham3 : rk(B :: C :: Bp :: Bs :: alpha :: nil) >= 3).
{
	assert(HABsMtmp : rk(A :: Bs :: nil) <= 2) by (solve_hyps_max HABseq HABsM2).
	try assert(HABCBpBsalphaeq : rk(A :: B :: C :: Bp :: Bs :: alpha :: nil) = 4) by (apply LABCBpBsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpBsalphamtmp : rk(A :: B :: C :: Bp :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpBsalphaeq HABCBpBsalpham4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (A :: Bs :: nil) (B :: C :: Bp :: Bs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: Bs :: alpha :: nil) (A :: Bs :: B :: C :: Bp :: Bs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bs :: B :: C :: Bp :: Bs :: alpha :: nil) ((A :: Bs :: nil) ++ (B :: C :: Bp :: Bs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpBsalphamtmp;try rewrite HT2 in HABCBpBsalphamtmp.
	assert(HT := rule_4 (A :: Bs :: nil) (B :: C :: Bp :: Bs :: alpha :: nil) (Bs :: nil) 4 1 2 HABCBpBsalphamtmp HBsmtmp HABsMtmp Hincl); apply HT.
}
try clear HABCBpBsalphaM1. try clear HABCBpBsalphaM2. try clear HABCBpBsalphaM3. try clear HABCBpBsalpham4. try clear HABCBpBsalpham3. try clear HABCBpBsalpham2. try clear HABCBpBsalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpBs requis par la preuve de (?)BBpBs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HBBpBsm2 : rk(B :: Bp :: Bs :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpBsalphamtmp : rk(B :: C :: Bp :: Bs :: alpha :: nil) >= 3) by (solve_hyps_min HBCBpBsalphaeq HBCBpBsalpham3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: Bs :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: Bs :: alpha :: nil) (B :: Bp :: Bs :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Bs :: B :: C :: alpha :: nil) ((B :: Bp :: Bs :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpBsalphamtmp;try rewrite HT2 in HBCBpBsalphamtmp.
	assert(HT := rule_2 (B :: Bp :: Bs :: nil) (B :: C :: alpha :: nil) (B :: nil) 3 1 2 HBCBpBsalphamtmp HBmtmp HBCalphaMtmp Hincl);apply HT.
}
try clear HBCBpBsalphaM1. try clear HBCBpBsalphaM2. try clear HBCBpBsalphaM3. try clear HBCBpBsalpham4. try clear HBCBpBsalpham3. try clear HBCBpBsalpham2. try clear HBCBpBsalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpBsCsalphaOo requis par la preuve de (?)BBpBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : B :: Bp :: Bs ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: Bs ::   de rang : 4 et 4 *)
assert(HBBpBsCsalphaOom2 : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCBpBseq : rk(A :: B :: C :: Bp :: Bs :: nil) = 4) by (apply LABCBpBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpBsMtmp : rk(A :: B :: C :: Bp :: Bs :: nil) <= 4) by (solve_hyps_max HABCBpBseq HABCBpBsM4).
	assert(HABCBpBsCsalphaOomtmp : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpBsCsalphaOoeq HABCBpBsCsalphaOom4).
	assert(HBBpBsmtmp : rk(B :: Bp :: Bs :: nil) >= 2) by (solve_hyps_min HBBpBseq HBBpBsm2).
	assert(Hincl : incl (B :: Bp :: Bs :: nil) (list_inter (A :: B :: C :: Bp :: Bs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: C :: Bp :: Bs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: Bs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: C :: Bp :: Bs :: nil) ++ (B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpBsCsalphaOomtmp;try rewrite HT2 in HABCBpBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: Bs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) (B :: Bp :: Bs :: nil) 4 2 4 HABCBpBsCsalphaOomtmp HBBpBsmtmp HABCBpBsMtmp Hincl); apply HT.
}
try clear HABCBpBsCsalphaOoM1. try clear HABCBpBsCsalphaOoM2. try clear HABCBpBsCsalphaOoM3. try clear HABCBpBsCsalphaOom4. try clear HABCBpBsCsalphaOom3. try clear HABCBpBsCsalphaOom2. try clear HABCBpBsCsalphaOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : B :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Cs ::  de rang :  1 et 1 	 A : As :: Cs ::   de rang : 1 et 2 *)
assert(HBBpBsCsalphaOom3 : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) >= 3).
{
	assert(HAsCsMtmp : rk(As :: Cs :: nil) <= 2) by (solve_hyps_max HAsCseq HAsCsM2).
	assert(HBBpAsBsCsalphaOomtmp : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HBBpAsBsCsalphaOoeq HBBpAsBsCsalphaOom4).
	try assert(HCseq : rk(Cs :: nil) = 1) by (apply LCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCsmtmp : rk(Cs :: nil) >= 1) by (solve_hyps_min HCseq HCsm1).
	assert(Hincl : incl (Cs :: nil) (list_inter (As :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (As :: Cs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: Cs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) ((As :: Cs :: nil) ++ (B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpAsBsCsalphaOomtmp;try rewrite HT2 in HBBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (As :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) (Cs :: nil) 4 1 2 HBBpAsBsCsalphaOomtmp HCsmtmp HAsCsMtmp Hincl); apply HT.
}
try clear HBBpAsBsCsalphaOoM1. try clear HBBpAsBsCsalphaOoM2. try clear HBBpAsBsCsalphaOoM3. try clear HBBpAsBsCsalphaOom4. try clear HBBpAsBsCsalphaOom3. try clear HBBpAsBsCsalphaOom2. try clear HBBpAsBsCsalphaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpBsCsalphaOom4 : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HBBpBsCseq : rk(B :: Bp :: Bs :: Cs :: nil) = 4) by (apply LBBpBsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpBsCsmtmp : rk(B :: Bp :: Bs :: Cs :: nil) >= 4) by (solve_hyps_min HBBpBsCseq HBBpBsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Bs :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Bs :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HBBpBsCsmtmp Hcomp Hincl);apply HT.
}


assert(HBBpBsCsalphaOoM : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpBsCsalphaOom : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HBBpBsCsalphaOoeq HBBpBsCsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpBsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: Bs :: Oo ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpBsOo requis par la preuve de (?)BBpBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpBsOo requis par la preuve de (?)BBpBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpBsOo requis par la preuve de (?)BCBpBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBsOo requis par la preuve de (?)ABCBpBsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsOom4 : rk(A :: B :: C :: Bp :: Bs :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABs requis par la preuve de (?)BCBpBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpBsOo requis par la preuve de (?)BCBpBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpBsOo requis par la preuve de (?)BCBpBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpBsOo requis par la preuve de (?)ABCApBpBsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpBsOom4 : rk(A :: B :: C :: Ap :: Bp :: Bs :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Bs :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpBsOo requis par la preuve de (?)BCBpBsOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Bs :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpBsOom2 : rk(B :: C :: Bp :: Bs :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpBsOomtmp : rk(A :: B :: C :: Ap :: Bp :: Bs :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpBsOoeq HABCApBpBsOom4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Bs :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: Bs :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpBsOomtmp;try rewrite HT2 in HABCApBpBsOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: Bs :: Oo :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpBsOomtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpBsOoM1. try clear HABCApBpBsOoM2. try clear HABCApBpBsOoM3. try clear HABCApBpBsOom4. try clear HABCApBpBsOom3. try clear HABCApBpBsOom2. try clear HABCApBpBsOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: Bs :: Oo ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : A :: Bs ::   de rang : 1 et 2 *)
assert(HBCBpBsOom3 : rk(B :: C :: Bp :: Bs :: Oo :: nil) >= 3).
{
	assert(HABsMtmp : rk(A :: Bs :: nil) <= 2) by (solve_hyps_max HABseq HABsM2).
	assert(HABCBpBsOomtmp : rk(A :: B :: C :: Bp :: Bs :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpBsOoeq HABCBpBsOom4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (A :: Bs :: nil) (B :: C :: Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: Bs :: Oo :: nil) (A :: Bs :: B :: C :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bs :: B :: C :: Bp :: Bs :: Oo :: nil) ((A :: Bs :: nil) ++ (B :: C :: Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpBsOomtmp;try rewrite HT2 in HABCBpBsOomtmp.
	assert(HT := rule_4 (A :: Bs :: nil) (B :: C :: Bp :: Bs :: Oo :: nil) (Bs :: nil) 4 1 2 HABCBpBsOomtmp HBsmtmp HABsMtmp Hincl); apply HT.
}
try clear HABCBpBsOoM1. try clear HABCBpBsOoM2. try clear HABCBpBsOoM3. try clear HABCBpBsOom4. try clear HABCBpBsOom3. try clear HABCBpBsOom2. try clear HABCBpBsOom1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBs requis par la preuve de (?)BBpBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpBsOo requis par la preuve de (?)BBpBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpBsOo requis par la preuve de (?)BBpBsOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBBpBsOoM3 : rk(B :: Bp :: Bs :: Oo :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HBpBsOoeq : rk(Bp :: Bs :: Oo :: nil) = 2) by (apply LBpBsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpBsOoMtmp : rk(Bp :: Bs :: Oo :: nil) <= 2) by (solve_hyps_max HBpBsOoeq HBpBsOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Bs :: Oo :: nil) (B :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Bs :: Oo :: nil) ((B :: nil) ++ (Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Bp :: Bs :: Oo :: nil) (nil) 1 2 0 HBMtmp HBpBsOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : B :: C :: Bp :: Bs :: Oo ::  de rang :  3 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : C :: Bs ::   de rang : 1 et 2 *)
assert(HBBpBsOom2 : rk(B :: Bp :: Bs :: Oo :: nil) >= 2).
{
	assert(HCBsMtmp : rk(C :: Bs :: nil) <= 2) by (solve_hyps_max HCBseq HCBsM2).
	assert(HBCBpBsOomtmp : rk(B :: C :: Bp :: Bs :: Oo :: nil) >= 3) by (solve_hyps_min HBCBpBsOoeq HBCBpBsOom3).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (C :: Bs :: nil) (B :: Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: Bs :: Oo :: nil) (C :: Bs :: B :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bs :: B :: Bp :: Bs :: Oo :: nil) ((C :: Bs :: nil) ++ (B :: Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpBsOomtmp;try rewrite HT2 in HBCBpBsOomtmp.
	assert(HT := rule_4 (C :: Bs :: nil) (B :: Bp :: Bs :: Oo :: nil) (Bs :: nil) 3 1 2 HBCBpBsOomtmp HBsmtmp HCBsMtmp Hincl); apply HT.
}
try clear HBCBpBsOoM1. try clear HBCBpBsOoM2. try clear HBCBpBsOoM3. try clear HBCBpBsOom4. try clear HBCBpBsOom3. try clear HBCBpBsOom2. try clear HBCBpBsOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: Bp :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : Bs :: Cs :: alpha ::   de rang : 2 et 2 *)
assert(HBBpBsOom3 : rk(B :: Bp :: Bs :: Oo :: nil) >= 3).
{
	try assert(HBsCsalphaeq : rk(Bs :: Cs :: alpha :: nil) = 2) by (apply LBsCsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsCsalphaMtmp : rk(Bs :: Cs :: alpha :: nil) <= 2) by (solve_hyps_max HBsCsalphaeq HBsCsalphaM2).
	try assert(HBBpBsCsalphaOoeq : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) = 4) by (apply LBBpBsCsalphaOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpBsCsalphaOomtmp : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HBBpBsCsalphaOoeq HBBpBsCsalphaOom4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (Bs :: Cs :: alpha :: nil) (B :: Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) (Bs :: Cs :: alpha :: B :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bs :: Cs :: alpha :: B :: Bp :: Bs :: Oo :: nil) ((Bs :: Cs :: alpha :: nil) ++ (B :: Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpBsCsalphaOomtmp;try rewrite HT2 in HBBpBsCsalphaOomtmp.
	assert(HT := rule_4 (Bs :: Cs :: alpha :: nil) (B :: Bp :: Bs :: Oo :: nil) (Bs :: nil) 4 1 2 HBBpBsCsalphaOomtmp HBsmtmp HBsCsalphaMtmp Hincl); apply HT.
}


assert(HBBpBsOoM : rk(B :: Bp :: Bs :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpBsOom : rk(B :: Bp :: Bs :: Oo ::  nil) >= 1) by (solve_hyps_min HBBpBsOoeq HBBpBsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: Oo ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpOo requis par la preuve de (?)BBpOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpalphaOo requis par la preuve de (?)BBpOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpalphaOo requis par la preuve de (?)BCBpalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOo requis par la preuve de (?)ABCBpalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOom4 : rk(A :: B :: C :: Bp :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpalphaOo requis par la preuve de (?)BCBpalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalphaOo requis par la preuve de (?)BCBpalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalphaOo requis par la preuve de (?)ABCApBpalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpalphaOo requis par la preuve de (?)BCBpalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpalphaOom2 : rk(B :: C :: Bp :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpalphaOomtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpalphaOoeq HABCApBpalphaOom4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: alpha :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphaOomtmp;try rewrite HT2 in HABCApBpalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: alpha :: Oo :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpalphaOomtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpalphaOoM1. try clear HABCApBpalphaOoM2. try clear HABCApBpalphaOoM3. try clear HABCApBpalphaOom4. try clear HABCApBpalphaOom3. try clear HABCApBpalphaOom2. try clear HABCApBpalphaOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : A :: alpha ::   de rang : 2 et 2 *)
assert(HBCBpalphaOom3 : rk(B :: C :: Bp :: alpha :: Oo :: nil) >= 3).
{
	try assert(HAalphaeq : rk(A :: alpha :: nil) = 2) by (apply LAalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAalphaMtmp : rk(A :: alpha :: nil) <= 2) by (solve_hyps_max HAalphaeq HAalphaM2).
	assert(HABCBpalphaOomtmp : rk(A :: B :: C :: Bp :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpalphaOoeq HABCBpalphaOom4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (A :: alpha :: nil) (B :: C :: Bp :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: alpha :: Oo :: nil) (A :: alpha :: B :: C :: Bp :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: alpha :: B :: C :: Bp :: alpha :: Oo :: nil) ((A :: alpha :: nil) ++ (B :: C :: Bp :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpalphaOomtmp;try rewrite HT2 in HABCBpalphaOomtmp.
	assert(HT := rule_4 (A :: alpha :: nil) (B :: C :: Bp :: alpha :: Oo :: nil) (alpha :: nil) 4 1 2 HABCBpalphaOomtmp Halphamtmp HAalphaMtmp Hincl); apply HT.
}
try clear HABCBpalphaOoM1. try clear HABCBpalphaOoM2. try clear HABCBpalphaOoM3. try clear HABCBpalphaOom4. try clear HABCBpalphaOom3. try clear HABCBpalphaOom2. try clear HABCBpalphaOom1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpOo requis par la preuve de (?)BBpOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: alpha :: Oo ::  de rang :  3 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HBBpOom2 : rk(B :: Bp :: Oo :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpalphaOomtmp : rk(B :: C :: Bp :: alpha :: Oo :: nil) >= 3) by (solve_hyps_min HBCBpalphaOoeq HBCBpalphaOom3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (B :: Bp :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: alpha :: Oo :: nil) (B :: C :: alpha :: B :: Bp :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: B :: Bp :: Oo :: nil) ((B :: C :: alpha :: nil) ++ (B :: Bp :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpalphaOomtmp;try rewrite HT2 in HBCBpalphaOomtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (B :: Bp :: Oo :: nil) (B :: nil) 3 1 2 HBCBpalphaOomtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HBCBpalphaOoM1. try clear HBCBpalphaOoM2. try clear HBCBpalphaOoM3. try clear HBCBpalphaOom4. try clear HBCBpalphaOom3. try clear HBCBpalphaOom2. try clear HBCBpalphaOom1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBBpOom3 : rk(B :: Bp :: Oo :: nil) >= 3).
{
	try assert(HBpBsOoeq : rk(Bp :: Bs :: Oo :: nil) = 2) by (apply LBpBsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpBsOoMtmp : rk(Bp :: Bs :: Oo :: nil) <= 2) by (solve_hyps_max HBpBsOoeq HBpBsOoM2).
	try assert(HBBpBsOoeq : rk(B :: Bp :: Bs :: Oo :: nil) = 3) by (apply LBBpBsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpBsOomtmp : rk(B :: Bp :: Bs :: Oo :: nil) >= 3) by (solve_hyps_min HBBpBsOoeq HBBpBsOom3).
	try assert(HBpOoeq : rk(Bp :: Oo :: nil) = 2) by (apply LBpOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpOomtmp : rk(Bp :: Oo :: nil) >= 2) by (solve_hyps_min HBpOoeq HBpOom2).
	assert(Hincl : incl (Bp :: Oo :: nil) (list_inter (B :: Bp :: Oo :: nil) (Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Bs :: Oo :: nil) (B :: Bp :: Oo :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Oo :: Bp :: Bs :: Oo :: nil) ((B :: Bp :: Oo :: nil) ++ (Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpBsOomtmp;try rewrite HT2 in HBBpBsOomtmp.
	assert(HT := rule_2 (B :: Bp :: Oo :: nil) (Bp :: Bs :: Oo :: nil) (Bp :: Oo :: nil) 3 2 2 HBBpBsOomtmp HBpOomtmp HBpBsOoMtmp Hincl);apply HT.
}
try clear HBpOoM1. try clear HBpOoM2. try clear HBpOoM3. try clear HBpOom4. try clear HBpOom3. try clear HBpOom2. try clear HBpOom1. 

assert(HBBpOoM : rk(B :: Bp :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBBpOoeq HBBpOoM3).
assert(HBBpOom : rk(B :: Bp :: Oo ::  nil) >= 1) by (solve_hyps_min HBBpOoeq HBBpOom1).
intuition.
Qed.

(* dans constructLemma(), requis par LAsOo *)
(* dans constructLemma(), requis par LBpAsBsOo *)
(* dans la couche 0 *)
Lemma LBpAsBsCsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BpAsBsCsalphaOo requis par la preuve de (?)BpAsBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABpAsBsCsalphaOo requis par la preuve de (?)BpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpAsBsCsalphaOo requis par la preuve de (?)ABpAsBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)ABpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)ABCBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOom4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpAs requis par la preuve de (?)ABpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpAs requis par la preuve de (?)ABpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HABpAsm2 : rk(A :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCBpAsalphaeq : rk(A :: B :: C :: Bp :: As :: alpha :: nil) = 4) by (apply LABCBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsalphamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: nil) (A :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: As :: B :: C :: alpha :: nil) ((A :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphamtmp;try rewrite HT2 in HABCBpAsalphamtmp.
	assert(HT := rule_2 (A :: Bp :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCBpAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpAsBsCsalphaOo requis par la preuve de (?)ABpAsBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : A :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HABpAsBsCsalphaOom2 : rk(A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoeq HABCBpAsBsCsalphaOom4).
	assert(HABpAsmtmp : rk(A :: Bp :: As :: nil) >= 2) by (solve_hyps_min HABpAseq HABpAsm2).
	assert(Hincl : incl (A :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: C :: Bp :: As :: A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: Bp :: As :: nil) 4 2 4 HABCBpAsBsCsalphaOomtmp HABpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpAsBsCsalphaOom4 : rk(A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABpAsBseq : rk(A :: Bp :: As :: Bs :: nil) = 4) by (apply LABpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABpAsBsmtmp : rk(A :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HABpAsBseq HABpAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: As :: Bs :: nil) (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: As :: Bs :: nil) (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABpAsBsmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ACs requis par la preuve de (?)BpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpAsBsCsalphaOo requis par la preuve de (?)BpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABBpAsBsCsalphaOo requis par la preuve de (?)BpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpAsBsCsalphaOo requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAs requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpAsBsCsalphaOo requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)ABCApBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABBpm2 : rk(A :: B :: Bp :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: B :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApBpalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpAsBsCsalphaOo requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HABBpAsBsCsalphaOom2 : rk(A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsCsalphaOoeq HABCApBpAsBsCsalphaOom4).
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 2) by (solve_hyps_min HABBpeq HABBpm2).
	assert(Hincl : incl (A :: B :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCApBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: Bp :: nil) 4 2 4 HABCApBpAsBsCsalphaOomtmp HABBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : C :: As ::   de rang : 1 et 2 *)
assert(HABBpAsBsCsalphaOom3 : rk(A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 3).
{
	assert(HCAsMtmp : rk(C :: As :: nil) <= 2) by (solve_hyps_max HCAseq HCAsM2).
	assert(HABCBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoeq HABCBpAsBsCsalphaOom4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (C :: As :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (C :: As :: A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: As :: A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((C :: As :: nil) ++ (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (C :: As :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (As :: nil) 4 1 2 HABCBpAsBsCsalphaOomtmp HAsmtmp HCAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABBpAsBsCsalphaOom4 : rk(A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABpAsBseq : rk(A :: Bp :: As :: Bs :: nil) = 4) by (apply LABpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABpAsBsmtmp : rk(A :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HABpAsBseq HABpAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: As :: Bs :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: As :: Bs :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABpAsBsmtmp Hcomp Hincl);apply HT.
}
try clear HABpAsBsM1. try clear HABpAsBsM2. try clear HABpAsBsM3. try clear HABpAsBsm4. try clear HABpAsBsm3. try clear HABpAsBsm2. try clear HABpAsBsm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpAsBs requis par la preuve de (?)BpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpAsBs requis par la preuve de (?)BpAsBs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HBpAsBsm2 : rk(Bp :: As :: Bs :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HBCBpAsBsalphaeq : rk(B :: C :: Bp :: As :: Bs :: alpha :: nil) = 4) by (apply LBCBpAsBsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsBsalphamtmp : rk(B :: C :: Bp :: As :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HBCBpAsBsalphaeq HBCBpAsBsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: As :: Bs :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: Bs :: alpha :: nil) (Bp :: As :: Bs :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: As :: Bs :: B :: C :: alpha :: nil) ((Bp :: As :: Bs :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsBsalphamtmp;try rewrite HT2 in HBCBpAsBsalphamtmp.
	assert(HT := rule_2 (Bp :: As :: Bs :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HBCBpAsBsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpAsBsCsalphaOo requis par la preuve de (?)BpAsBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Bp :: As :: Bs ::  de rang :  2 et 3 	 A : A :: B :: Bp :: As :: Bs ::   de rang : 4 et 4 *)
assert(HBpAsBsCsalphaOom2 : rk(Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABBpAsBseq : rk(A :: B :: Bp :: As :: Bs :: nil) = 4) by (apply LABBpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABBpAsBsMtmp : rk(A :: B :: Bp :: As :: Bs :: nil) <= 4) by (solve_hyps_max HABBpAsBseq HABBpAsBsM4).
	assert(HABBpAsBsCsalphaOomtmp : rk(A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABBpAsBsCsalphaOoeq HABBpAsBsCsalphaOom4).
	assert(HBpAsBsmtmp : rk(Bp :: As :: Bs :: nil) >= 2) by (solve_hyps_min HBpAsBseq HBpAsBsm2).
	assert(Hincl : incl (Bp :: As :: Bs :: nil) (list_inter (A :: B :: Bp :: As :: Bs :: nil) (Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: Bp :: As :: Bs :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bp :: As :: Bs :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: Bp :: As :: Bs :: nil) ++ (Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpAsBsCsalphaOomtmp;try rewrite HT2 in HABBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: Bp :: As :: Bs :: nil) (Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (Bp :: As :: Bs :: nil) 4 2 4 HABBpAsBsCsalphaOomtmp HBpAsBsmtmp HABBpAsBsMtmp Hincl); apply HT.
}
try clear HBpAsBsM1. try clear HBpAsBsM2. try clear HBpAsBsM3. try clear HBpAsBsm4. try clear HBpAsBsm3. try clear HBpAsBsm2. try clear HBpAsBsm1. try clear HABBpAsBsCsalphaOoM1. try clear HABBpAsBsCsalphaOoM2. try clear HABBpAsBsCsalphaOoM3. try clear HABBpAsBsCsalphaOom4. try clear HABBpAsBsCsalphaOom3. try clear HABBpAsBsCsalphaOom2. try clear HABBpAsBsCsalphaOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Cs ::  de rang :  1 et 1 	 A : A :: Cs ::   de rang : 1 et 2 *)
assert(HBpAsBsCsalphaOom3 : rk(Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 3).
{
	assert(HACsMtmp : rk(A :: Cs :: nil) <= 2) by (solve_hyps_max HACseq HACsM2).
	assert(HABpAsBsCsalphaOomtmp : rk(A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABpAsBsCsalphaOoeq HABpAsBsCsalphaOom4).
	try assert(HCseq : rk(Cs :: nil) = 1) by (apply LCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCsmtmp : rk(Cs :: nil) >= 1) by (solve_hyps_min HCseq HCsm1).
	assert(Hincl : incl (Cs :: nil) (list_inter (A :: Cs :: nil) (Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: Cs :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cs :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: Cs :: nil) ++ (Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpAsBsCsalphaOomtmp;try rewrite HT2 in HABpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: Cs :: nil) (Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (Cs :: nil) 4 1 2 HABpAsBsCsalphaOomtmp HCsmtmp HACsMtmp Hincl); apply HT.
}
try clear HACsM1. try clear HACsM2. try clear HACsM3. try clear HACsm4. try clear HACsm3. try clear HACsm2. try clear HACsm1. try clear HABpAsBsCsalphaOoM1. try clear HABpAsBsCsalphaOoM2. try clear HABpAsBsCsalphaOoM3. try clear HABpAsBsCsalphaOom4. try clear HABpAsBsCsalphaOom3. try clear HABpAsBsCsalphaOom2. try clear HABpAsBsCsalphaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpAsBsCsalphaOom4 : rk(Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HBpAsBsCseq : rk(Bp :: As :: Bs :: Cs :: nil) = 4) by (apply LBpAsBsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpAsBsCsmtmp : rk(Bp :: As :: Bs :: Cs :: nil) >= 4) by (solve_hyps_min HBpAsBsCseq HBpAsBsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Bp :: As :: Bs :: Cs :: nil) (Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: As :: Bs :: Cs :: nil) (Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HBpAsBsCsmtmp Hcomp Hincl);apply HT.
}
try clear HBpAsBsCsM1. try clear HBpAsBsCsM2. try clear HBpAsBsCsM3. try clear HBpAsBsCsm4. try clear HBpAsBsCsm3. try clear HBpAsBsCsm2. try clear HBpAsBsCsm1. 

assert(HBpAsBsCsalphaOoM : rk(Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpAsBsCsalphaOom : rk(Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HBpAsBsCsalphaOoeq HBpAsBsCsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpAsBsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Bp :: As :: Bs :: Oo ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpAsBsOo requis par la preuve de (?)BpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpAsBsOo requis par la preuve de (?)BpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCBpAsBsOo requis par la preuve de (?)CBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsBsOo requis par la preuve de (?)BCBpAsBsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsOo requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsOo requis par la preuve de (?)ABCBpAsBsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsOom4 : rk(A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsBsOo requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsOo requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsOo requis par la preuve de (?)ABCApBpAsBsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsOom4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsBsOo requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsBsOom2 : rk(B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsOomtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsOoeq HABCApBpAsBsOom4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsOomtmp;try rewrite HT2 in HABCApBpAsBsOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsBsOomtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsBsOoM1. try clear HABCApBpAsBsOoM2. try clear HABCApBpAsBsOoM3. try clear HABCApBpAsBsOom4. try clear HABCApBpAsBsOom3. try clear HABCApBpAsBsOom2. try clear HABCApBpAsBsOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Oo ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsBsOom3 : rk(B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsBsOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsOoeq HABCBpAsBsOom4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) (A :: As :: B :: C :: Bp :: As :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: Bs :: Oo :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsOomtmp;try rewrite HT2 in HABCBpAsBsOomtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil) (As :: nil) 4 1 2 HABCBpAsBsOomtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsBsOom4 : rk(B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBs requis par la preuve de (?)CBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpAsBsOo requis par la preuve de (?)CBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpAs requis par la preuve de (?)CBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)CBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsalpham2 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpAsalphaeq : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) = 4) by (apply LABCApBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpAsalphaeq HABCApBpAsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsalphamtmp;try rewrite HT2 in HABCApBpAsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsalphamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsalpham3 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	try assert(HABCBpAsalphaeq : rk(A :: B :: C :: Bp :: As :: alpha :: nil) = 4) by (apply LABCBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsalphamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: nil) (A :: As :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: alpha :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphamtmp;try rewrite HT2 in HABCBpAsalphamtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil) (As :: nil) 4 1 2 HABCBpAsalphamtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CBpAs requis par la preuve de (?)CBpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HCBpAsm2 : rk(C :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpAsalphamtmp : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3) by (solve_hyps_min HBCBpAsalphaeq HBCBpAsalpham3).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (C :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: alpha :: nil) (C :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: As :: B :: C :: alpha :: nil) ((C :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsalphamtmp;try rewrite HT2 in HBCBpAsalphamtmp.
	assert(HT := rule_2 (C :: Bp :: As :: nil) (B :: C :: alpha :: nil) (C :: nil) 3 1 2 HBCBpAsalphamtmp HCmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpAsBsOo requis par la preuve de (?)CBpAsBsOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Oo ::  de rang :  4 et 4 	 AiB : C :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HCBpAsBsOom2 : rk(C :: Bp :: As :: Bs :: Oo :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsBsOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsOoeq HABCBpAsBsOom4).
	assert(HCBpAsmtmp : rk(C :: Bp :: As :: nil) >= 2) by (solve_hyps_min HCBpAseq HCBpAsm2).
	assert(Hincl : incl (C :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (C :: Bp :: As :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) (A :: B :: C :: Bp :: As :: C :: Bp :: As :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: C :: Bp :: As :: Bs :: Oo :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (C :: Bp :: As :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsOomtmp;try rewrite HT2 in HABCBpAsBsOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (C :: Bp :: As :: Bs :: Oo :: nil) (C :: Bp :: As :: nil) 4 2 4 HABCBpAsBsOomtmp HCBpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}
try clear HCBpAsM1. try clear HCBpAsM2. try clear HCBpAsM3. try clear HCBpAsm4. try clear HCBpAsm3. try clear HCBpAsm2. try clear HCBpAsm1. try clear HABCBpAsBsOoM1. try clear HABCBpAsBsOoM2. try clear HABCBpAsBsOoM3. try clear HABCBpAsBsOom4. try clear HABCBpAsBsOom3. try clear HABCBpAsBsOom2. try clear HABCBpAsBsOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : B :: C :: Bp :: As :: Bs :: Oo ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : B :: Bs ::   de rang : 1 et 2 *)
assert(HCBpAsBsOom3 : rk(C :: Bp :: As :: Bs :: Oo :: nil) >= 3).
{
	assert(HBBsMtmp : rk(B :: Bs :: nil) <= 2) by (solve_hyps_max HBBseq HBBsM2).
	assert(HBCBpAsBsOomtmp : rk(B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 4) by (solve_hyps_min HBCBpAsBsOoeq HBCBpAsBsOom4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (B :: Bs :: nil) (C :: Bp :: As :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: Bs :: Oo :: nil) (B :: Bs :: C :: Bp :: As :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bs :: C :: Bp :: As :: Bs :: Oo :: nil) ((B :: Bs :: nil) ++ (C :: Bp :: As :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsBsOomtmp;try rewrite HT2 in HBCBpAsBsOomtmp.
	assert(HT := rule_4 (B :: Bs :: nil) (C :: Bp :: As :: Bs :: Oo :: nil) (Bs :: nil) 4 1 2 HBCBpAsBsOomtmp HBsmtmp HBBsMtmp Hincl); apply HT.
}
try clear HBBsM1. try clear HBBsM2. try clear HBBsM3. try clear HBBsm4. try clear HBBsm3. try clear HBBsm2. try clear HBBsm1. try clear HBCBpAsBsOoM1. try clear HBCBpAsBsOoM2. try clear HBCBpAsBsOoM3. try clear HBCBpAsBsOom4. try clear HBCBpAsBsOom3. try clear HBCBpAsBsOom2. try clear HBCBpAsBsOom1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBs requis par la preuve de (?)BpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpAsBsOo requis par la preuve de (?)BpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpAsBsOo requis par la preuve de (?)BpAsBsOo pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBpAsBsOoM3 : rk(Bp :: As :: Bs :: Oo :: nil) <= 3).
{
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsMtmp : rk(As :: nil) <= 1) by (solve_hyps_max HAseq HAsM1).
	try assert(HBpBsOoeq : rk(Bp :: Bs :: Oo :: nil) = 2) by (apply LBpBsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpBsOoMtmp : rk(Bp :: Bs :: Oo :: nil) <= 2) by (solve_hyps_max HBpBsOoeq HBpBsOoM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (As :: nil) (Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: As :: Bs :: Oo :: nil) (As :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: Bp :: Bs :: Oo :: nil) ((As :: nil) ++ (Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (As :: nil) (Bp :: Bs :: Oo :: nil) (nil) 1 2 0 HAsMtmp HBpBsOoMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : C :: Bp :: As :: Bs :: Oo ::  de rang :  3 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : C :: Bs ::   de rang : 1 et 2 *)
assert(HBpAsBsOom2 : rk(Bp :: As :: Bs :: Oo :: nil) >= 2).
{
	assert(HCBsMtmp : rk(C :: Bs :: nil) <= 2) by (solve_hyps_max HCBseq HCBsM2).
	assert(HCBpAsBsOomtmp : rk(C :: Bp :: As :: Bs :: Oo :: nil) >= 3) by (solve_hyps_min HCBpAsBsOoeq HCBpAsBsOom3).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (C :: Bs :: nil) (Bp :: As :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: As :: Bs :: Oo :: nil) (C :: Bs :: Bp :: As :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bs :: Bp :: As :: Bs :: Oo :: nil) ((C :: Bs :: nil) ++ (Bp :: As :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpAsBsOomtmp;try rewrite HT2 in HCBpAsBsOomtmp.
	assert(HT := rule_4 (C :: Bs :: nil) (Bp :: As :: Bs :: Oo :: nil) (Bs :: nil) 3 1 2 HCBpAsBsOomtmp HBsmtmp HCBsMtmp Hincl); apply HT.
}
try clear HCBpAsBsOoM1. try clear HCBpAsBsOoM2. try clear HCBpAsBsOoM3. try clear HCBpAsBsOom4. try clear HCBpAsBsOom3. try clear HCBpAsBsOom2. try clear HCBpAsBsOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : Bs :: Cs :: alpha ::   de rang : 2 et 2 *)
assert(HBpAsBsOom3 : rk(Bp :: As :: Bs :: Oo :: nil) >= 3).
{
	try assert(HBsCsalphaeq : rk(Bs :: Cs :: alpha :: nil) = 2) by (apply LBsCsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsCsalphaMtmp : rk(Bs :: Cs :: alpha :: nil) <= 2) by (solve_hyps_max HBsCsalphaeq HBsCsalphaM2).
	try assert(HBpAsBsCsalphaOoeq : rk(Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) = 4) by (apply LBpAsBsCsalphaOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpAsBsCsalphaOomtmp : rk(Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HBpAsBsCsalphaOoeq HBpAsBsCsalphaOom4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (Bs :: Cs :: alpha :: nil) (Bp :: As :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (Bs :: Cs :: alpha :: Bp :: As :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bs :: Cs :: alpha :: Bp :: As :: Bs :: Oo :: nil) ((Bs :: Cs :: alpha :: nil) ++ (Bp :: As :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpAsBsCsalphaOomtmp;try rewrite HT2 in HBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (Bs :: Cs :: alpha :: nil) (Bp :: As :: Bs :: Oo :: nil) (Bs :: nil) 4 1 2 HBpAsBsCsalphaOomtmp HBsmtmp HBsCsalphaMtmp Hincl); apply HT.
}


assert(HBpAsBsOoM : rk(Bp :: As :: Bs :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpAsBsOom : rk(Bp :: As :: Bs :: Oo ::  nil) >= 1) by (solve_hyps_min HBpAsBsOoeq HBpAsBsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(As :: Oo ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AsOo requis par la preuve de (?)AsOo pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAsOom2 : rk(As :: Oo :: nil) >= 2).
{
	try assert(HBpBsOoeq : rk(Bp :: Bs :: Oo :: nil) = 2) by (apply LBpBsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpBsOoMtmp : rk(Bp :: Bs :: Oo :: nil) <= 2) by (solve_hyps_max HBpBsOoeq HBpBsOoM2).
	try assert(HBpAsBsOoeq : rk(Bp :: As :: Bs :: Oo :: nil) = 3) by (apply LBpAsBsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpAsBsOomtmp : rk(Bp :: As :: Bs :: Oo :: nil) >= 3) by (solve_hyps_min HBpAsBsOoeq HBpAsBsOom3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (As :: Oo :: nil) (Bp :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: As :: Bs :: Oo :: nil) (As :: Oo :: Bp :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: Oo :: Bp :: Bs :: Oo :: nil) ((As :: Oo :: nil) ++ (Bp :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpAsBsOomtmp;try rewrite HT2 in HBpAsBsOomtmp.
	assert(HT := rule_2 (As :: Oo :: nil) (Bp :: Bs :: Oo :: nil) (Oo :: nil) 3 1 2 HBpAsBsOomtmp HOomtmp HBpBsOoMtmp Hincl);apply HT.
}


assert(HAsOoM : rk(As :: Oo ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAsOoeq HAsOoM2).
assert(HAsOom : rk(As :: Oo ::  nil) >= 1) by (solve_hyps_min HAsOoeq HAsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAAsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: As :: Oo ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AAsOo requis par la preuve de (?)AAsOo pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCAsalphaOo requis par la preuve de (?)AAsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAsalphaOo requis par la preuve de (?)ABCAsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCAsalphaOom4 : rk(A :: B :: C :: As :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCAseq : rk(A :: B :: C :: As :: nil) = 4) by (apply LABCAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsmtmp : rk(A :: B :: C :: As :: nil) >= 4) by (solve_hyps_min HABCAseq HABCAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: Oo :: nil) 4 4 HABCAsmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AAsOo requis par la preuve de (?)AAsOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: As :: alpha :: Oo ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HAAsOom2 : rk(A :: As :: Oo :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCAsalphaOomtmp : rk(A :: B :: C :: As :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCAsalphaOoeq HABCAsalphaOom4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C :: alpha :: nil) (A :: As :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: As :: alpha :: Oo :: nil) (B :: C :: alpha :: A :: As :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: As :: Oo :: nil) ((B :: C :: alpha :: nil) ++ (A :: As :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCAsalphaOomtmp;try rewrite HT2 in HABCAsalphaOomtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: As :: Oo :: nil) (nil) 4 0 2 HABCAsalphaOomtmp Hmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCAsalphaOoM1. try clear HABCAsalphaOoM2. try clear HABCAsalphaOoM3. try clear HABCAsalphaOom4. try clear HABCAsalphaOom3. try clear HABCAsalphaOom2. try clear HABCAsalphaOom1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAAsOom3 : rk(A :: As :: Oo :: nil) >= 3).
{
	try assert(HApAsOoeq : rk(Ap :: As :: Oo :: nil) = 2) by (apply LApAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApAsOoMtmp : rk(Ap :: As :: Oo :: nil) <= 2) by (solve_hyps_max HApAsOoeq HApAsOoM2).
	try assert(HAApAsOoeq : rk(A :: Ap :: As :: Oo :: nil) = 3) by (apply LAApAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsOomtmp : rk(A :: Ap :: As :: Oo :: nil) >= 3) by (solve_hyps_min HAApAsOoeq HAApAsOom3).
	try assert(HAsOoeq : rk(As :: Oo :: nil) = 2) by (apply LAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsOomtmp : rk(As :: Oo :: nil) >= 2) by (solve_hyps_min HAsOoeq HAsOom2).
	assert(Hincl : incl (As :: Oo :: nil) (list_inter (A :: As :: Oo :: nil) (Ap :: As :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: As :: Oo :: nil) (A :: As :: Oo :: Ap :: As :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: Oo :: Ap :: As :: Oo :: nil) ((A :: As :: Oo :: nil) ++ (Ap :: As :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApAsOomtmp;try rewrite HT2 in HAApAsOomtmp.
	assert(HT := rule_2 (A :: As :: Oo :: nil) (Ap :: As :: Oo :: nil) (As :: Oo :: nil) 3 2 2 HAApAsOomtmp HAsOomtmp HApAsOoMtmp Hincl);apply HT.
}
try clear HAsOoM1. try clear HAsOoM2. try clear HAsOoM3. try clear HAsOom4. try clear HAsOom3. try clear HAsOom2. try clear HAsOom1. 

assert(HAAsOoM : rk(A :: As :: Oo ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAAsOoeq HAAsOoM3).
assert(HAAsOom : rk(A :: As :: Oo ::  nil) >= 1) by (solve_hyps_min HAAsOoeq HAAsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApAsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsOo requis par la preuve de (?)ABCApAsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsOom4 : rk(A :: B :: C :: Ap :: As :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsOoM : rk(A :: B :: C :: Ap :: As :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsOom : rk(A :: B :: C :: Ap :: As :: Oo ::  nil) >= 1) by (solve_hyps_min HABCApAsOoeq HABCApAsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpBsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: Bs :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBsOo requis par la preuve de (?)ABCBpBsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsOom4 : rk(A :: B :: C :: Bp :: Bs :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpBsOoM : rk(A :: B :: C :: Bp :: Bs :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpBsOom : rk(A :: B :: C :: Bp :: Bs :: Oo ::  nil) >= 1) by (solve_hyps_min HABCBpBsOoeq HABCBpBsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpBsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Bs :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpBsOo requis par la preuve de (?)ABCApBpBsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpBsOom4 : rk(A :: B :: C :: Ap :: Bp :: Bs :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Bs :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpBsOoM : rk(A :: B :: C :: Ap :: Bp :: Bs :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpBsOom : rk(A :: B :: C :: Ap :: Bp :: Bs :: Oo ::  nil) >= 1) by (solve_hyps_min HABCApBpBsOoeq HABCApBpBsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpAsBsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: C :: Bp :: As :: Bs :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsBsOo requis par la preuve de (?)BCBpAsBsOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsOo requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsOo requis par la preuve de (?)ABCBpAsBsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsOom4 : rk(A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsBsOo requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsOo requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsOo requis par la preuve de (?)ABCApBpAsBsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsOom4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsBsOo requis par la preuve de (?)BCBpAsBsOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsBsOom2 : rk(B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsOomtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsOoeq HABCApBpAsBsOom4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsOomtmp;try rewrite HT2 in HABCApBpAsBsOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsBsOomtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsBsOoM1. try clear HABCApBpAsBsOoM2. try clear HABCApBpAsBsOoM3. try clear HABCApBpAsBsOom4. try clear HABCApBpAsBsOom3. try clear HABCApBpAsBsOom2. try clear HABCApBpAsBsOom1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Oo ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsBsOom3 : rk(B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsBsOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsOoeq HABCBpAsBsOom4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) (A :: As :: B :: C :: Bp :: As :: Bs :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: Bs :: Oo :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: Bs :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsOomtmp;try rewrite HT2 in HABCBpAsBsOomtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil) (As :: nil) 4 1 2 HABCBpAsBsOomtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsBsOom4 : rk(B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Oo :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}


assert(HBCBpAsBsOoM : rk(B :: C :: Bp :: As :: Bs :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpAsBsOom : rk(B :: C :: Bp :: As :: Bs :: Oo ::  nil) >= 1) by (solve_hyps_min HBCBpAsBsOoeq HBCBpAsBsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAsBsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As :: Bs :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsOo requis par la preuve de (?)ABCBpAsBsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsOom4 : rk(A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsBsOoM : rk(A :: B :: C :: Bp :: As :: Bs :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsBsOom : rk(A :: B :: C :: Bp :: As :: Bs :: Oo ::  nil) >= 1) by (solve_hyps_min HABCBpAsBsOoeq HABCBpAsBsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpAsBsOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsOo requis par la preuve de (?)ABCApBpAsBsOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsOom4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpAsBsOoM : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpAsBsOom : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Oo ::  nil) >= 1) by (solve_hyps_min HABCApBpAsBsOoeq HABCApBpAsBsOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalphaOo requis par la preuve de (?)ABCApalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalphaOom4 : rk(A :: B :: C :: Ap :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApalphaOoM : rk(A :: B :: C :: Ap :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApalphaOom : rk(A :: B :: C :: Ap :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABCApalphaOoeq HABCApalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOo requis par la preuve de (?)ABCBpalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOom4 : rk(A :: B :: C :: Bp :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpalphaOoM : rk(A :: B :: C :: Bp :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpalphaOom : rk(A :: B :: C :: Bp :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABCBpalphaOoeq HABCBpalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalphaOo requis par la preuve de (?)ABCApBpalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpalphaOoM : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpalphaOom : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABCApBpalphaOoeq HABCApBpalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCAsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: As :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAsalphaOo requis par la preuve de (?)ABCAsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCAsalphaOom4 : rk(A :: B :: C :: As :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCAseq : rk(A :: B :: C :: As :: nil) = 4) by (apply LABCAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsmtmp : rk(A :: B :: C :: As :: nil) >= 4) by (solve_hyps_min HABCAseq HABCAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: Oo :: nil) 4 4 HABCAsmtmp Hcomp Hincl);apply HT.
}


assert(HABCAsalphaOoM : rk(A :: B :: C :: As :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCAsalphaOom : rk(A :: B :: C :: As :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABCAsalphaOoeq HABCAsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpCpAsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: Cp :: As :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpAsalphaOo requis par la preuve de (?)AApBpCpAsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpAsalphaOo requis par la preuve de (?)AApBpCpAsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAsalphaOo requis par la preuve de (?)ABCApBpCpAsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpAsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpAsalphaOo requis par la preuve de (?)AApBpCpAsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpAsalphaOom2 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpAsalphaOomtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpCpAsalphaOoeq HABCApBpCpAsalphaOom4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpAsalphaOomtmp;try rewrite HT2 in HABCApBpCpAsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpAsalphaOomtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpAsalphaOoM1. try clear HABCApBpCpAsalphaOoM2. try clear HABCApBpCpAsalphaOoM3. try clear HABCApBpCpAsalphaOom4. try clear HABCApBpCpAsalphaOom3. try clear HABCApBpCpAsalphaOom2. try clear HABCApBpCpAsalphaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpAsalphaOom4 : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}


assert(HAApBpCpAsalphaOoM : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpAsalphaOom : rk(A :: Ap :: Bp :: Cp :: As :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HAApBpCpAsalphaOoeq HAApBpCpAsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpAsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpAsalphaOo requis par la preuve de (?)ABCApBpCpAsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpAsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpCpAsalphaOoM : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpAsalphaOom : rk(A :: B :: C :: Ap :: Bp :: Cp :: As :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABCApBpCpAsalphaOoeq HABCApBpCpAsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpCpBsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpCpBsalphaOo requis par la preuve de (?)AApBpCpBsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpBsalphaOo requis par la preuve de (?)AApBpCpBsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpBsalphaOo requis par la preuve de (?)ABCApBpCpBsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpBsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBpCpBsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBp requis par la preuve de (?)AApBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApBpm2 : rk(A :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Ap :: Bp :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: B :: C :: alpha :: nil) ((A :: Ap :: Bp :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpCpBsalphaOo requis par la preuve de (?)AApBpCpBsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HAApBpCpBsalphaOom2 : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpCpBsalphaOomtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpCpBsalphaOoeq HABCApBpCpBsalphaOom4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 2) by (solve_hyps_min HAApBpeq HAApBpm2).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpBsalphaOomtmp;try rewrite HT2 in HABCApBpCpBsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) (A :: Ap :: Bp :: nil) 4 2 4 HABCApBpCpBsalphaOomtmp HAApBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpCpBsalphaOoM1. try clear HABCApBpCpBsalphaOoM2. try clear HABCApBpCpBsalphaOoM3. try clear HABCApBpCpBsalphaOom4. try clear HABCApBpCpBsalphaOom3. try clear HABCApBpCpBsalphaOom2. try clear HABCApBpCpBsalphaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpCpBsalphaOom4 : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HAApBpCpeq : rk(A :: Ap :: Bp :: Cp :: nil) = 4) by (apply LAApBpCp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApBpCpmtmp : rk(A :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HAApBpCpeq HAApBpCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) 4 4 HAApBpCpmtmp Hcomp Hincl);apply HT.
}
try clear HAApBpCpM1. try clear HAApBpCpM2. try clear HAApBpCpM3. try clear HAApBpCpm4. try clear HAApBpCpm3. try clear HAApBpCpm2. try clear HAApBpCpm1. 

assert(HAApBpCpBsalphaOoM : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpCpBsalphaOom : rk(A :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HAApBpCpBsalphaOoeq HAApBpCpBsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpBsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpBsalphaOo requis par la preuve de (?)ABCApBpCpBsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpCpBsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpCpBsalphaOoM : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpBsalphaOom : rk(A :: B :: C :: Ap :: Bp :: Cp :: Bs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABCApBpCpBsalphaOoeq HABCApBpCpBsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpBsCsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBsCsalphaOo requis par la preuve de (?)ABCBpBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsCsalphaOom4 : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpBsCsalphaOoM : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpBsCsalphaOom : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABCBpBsCsalphaOoeq HABCBpBsCsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpAsBsCsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpAsBsCsalphaOo requis par la preuve de (?)ABpAsBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)ABpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)ABCBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOom4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpAs requis par la preuve de (?)ABpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpAs requis par la preuve de (?)ABpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HABpAsm2 : rk(A :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCBpAsalphaeq : rk(A :: B :: C :: Bp :: As :: alpha :: nil) = 4) by (apply LABCBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsalphamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: nil) (A :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: As :: B :: C :: alpha :: nil) ((A :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphamtmp;try rewrite HT2 in HABCBpAsalphamtmp.
	assert(HT := rule_2 (A :: Bp :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCBpAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpAsBsCsalphaOo requis par la preuve de (?)ABpAsBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : A :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HABpAsBsCsalphaOom2 : rk(A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoeq HABCBpAsBsCsalphaOom4).
	assert(HABpAsmtmp : rk(A :: Bp :: As :: nil) >= 2) by (solve_hyps_min HABpAseq HABpAsm2).
	assert(Hincl : incl (A :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: C :: Bp :: As :: A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: Bp :: As :: nil) 4 2 4 HABCBpAsBsCsalphaOomtmp HABpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpAsBsCsalphaOom4 : rk(A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABpAsBseq : rk(A :: Bp :: As :: Bs :: nil) = 4) by (apply LABpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABpAsBsmtmp : rk(A :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HABpAsBseq HABpAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: As :: Bs :: nil) (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: As :: Bs :: nil) (A :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABpAsBsmtmp Hcomp Hincl);apply HT.
}


assert(HABpAsBsCsalphaOoM : rk(A :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpAsBsCsalphaOom : rk(A :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABpAsBsCsalphaOoeq HABpAsBsCsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpAsBsCsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpAsBsCsalphaOo requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)ABCBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOom4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)ABCApBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsBsCsalphaOom2 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsCsalphaOoeq HABCApBpAsBsCsalphaOom4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCApBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsBsCsalphaOomtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsBsCsalphaOom3 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoeq HABCBpAsBsCsalphaOom4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (As :: nil) 4 1 2 HABCBpAsBsCsalphaOomtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsBsCsalphaOom4 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBs requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpAsBsCsalphaOo requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpAs requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsalpham2 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpAsalphaeq : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) = 4) by (apply LABCApBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpAsalphaeq HABCApBpAsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsalphamtmp;try rewrite HT2 in HABCApBpAsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsalphamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsalpham3 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	try assert(HABCBpAsalphaeq : rk(A :: B :: C :: Bp :: As :: alpha :: nil) = 4) by (apply LABCBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsalphamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: nil) (A :: As :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: alpha :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphamtmp;try rewrite HT2 in HABCBpAsalphamtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil) (As :: nil) 4 1 2 HABCBpAsalphamtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpAs requis par la preuve de (?)BBpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HBBpAsm2 : rk(B :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpAsalphamtmp : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3) by (solve_hyps_min HBCBpAsalphaeq HBCBpAsalpham3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: alpha :: nil) (B :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: As :: B :: C :: alpha :: nil) ((B :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsalphamtmp;try rewrite HT2 in HBCBpAsalphamtmp.
	assert(HT := rule_2 (B :: Bp :: As :: nil) (B :: C :: alpha :: nil) (B :: nil) 3 1 2 HBCBpAsalphamtmp HBmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpAsBsCsalphaOo requis par la preuve de (?)BBpAsBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : B :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HBBpAsBsCsalphaOom2 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoeq HABCBpAsBsCsalphaOom4).
	assert(HBBpAsmtmp : rk(B :: Bp :: As :: nil) >= 2) by (solve_hyps_min HBBpAseq HBBpAsm2).
	assert(Hincl : incl (B :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: C :: Bp :: As :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (B :: Bp :: As :: nil) 4 2 4 HABCBpAsBsCsalphaOomtmp HBBpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : C :: Bs ::   de rang : 1 et 2 *)
assert(HBBpAsBsCsalphaOom3 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 3).
{
	assert(HCBsMtmp : rk(C :: Bs :: nil) <= 2) by (solve_hyps_max HCBseq HCBsM2).
	assert(HBCBpAsBsCsalphaOomtmp : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HBCBpAsBsCsalphaOoeq HBCBpAsBsCsalphaOom4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (C :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (C :: Bs :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bs :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((C :: Bs :: nil) ++ (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsBsCsalphaOomtmp;try rewrite HT2 in HBCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (C :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (Bs :: nil) 4 1 2 HBCBpAsBsCsalphaOomtmp HBsmtmp HCBsMtmp Hincl); apply HT.
}
try clear HBCBpAsBsCsalphaOoM1. try clear HBCBpAsBsCsalphaOoM2. try clear HBCBpAsBsCsalphaOoM3. try clear HBCBpAsBsCsalphaOom4. try clear HBCBpAsBsCsalphaOom3. try clear HBCBpAsBsCsalphaOom2. try clear HBCBpAsBsCsalphaOom1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpAsBsCsalphaOom4 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HBBpAsBseq : rk(B :: Bp :: As :: Bs :: nil) = 4) by (apply LBBpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpAsBsmtmp : rk(B :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HBBpAsBseq HBBpAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: As :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: As :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HBBpAsBsmtmp Hcomp Hincl);apply HT.
}


assert(HBBpAsBsCsalphaOoM : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpAsBsCsalphaOom : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HBBpAsBsCsalphaOoeq HBBpAsBsCsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBpAsBsCsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpAsBsCsalphaOo requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)ABCBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOom4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAs requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpAsBsCsalphaOo requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)ABCApBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABBpm2 : rk(A :: B :: Bp :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: B :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApBpalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpAsBsCsalphaOo requis par la preuve de (?)ABBpAsBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : A :: B :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HABBpAsBsCsalphaOom2 : rk(A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsCsalphaOoeq HABCApBpAsBsCsalphaOom4).
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 2) by (solve_hyps_min HABBpeq HABBpm2).
	assert(Hincl : incl (A :: B :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCApBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: Bp :: nil) 4 2 4 HABCApBpAsBsCsalphaOomtmp HABBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : C :: As ::   de rang : 1 et 2 *)
assert(HABBpAsBsCsalphaOom3 : rk(A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 3).
{
	assert(HCAsMtmp : rk(C :: As :: nil) <= 2) by (solve_hyps_max HCAseq HCAsM2).
	assert(HABCBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoeq HABCBpAsBsCsalphaOom4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (C :: As :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (C :: As :: A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: As :: A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((C :: As :: nil) ++ (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (C :: As :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (As :: nil) 4 1 2 HABCBpAsBsCsalphaOomtmp HAsmtmp HCAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABBpAsBsCsalphaOom4 : rk(A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABpAsBseq : rk(A :: Bp :: As :: Bs :: nil) = 4) by (apply LABpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABpAsBsmtmp : rk(A :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HABpAsBseq HABpAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: As :: Bs :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: As :: Bs :: nil) (A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABpAsBsmtmp Hcomp Hincl);apply HT.
}
try clear HABpAsBsM1. try clear HABpAsBsM2. try clear HABpAsBsM3. try clear HABpAsBsm4. try clear HABpAsBsm3. try clear HABpAsBsm2. try clear HABpAsBsm1. 

assert(HABBpAsBsCsalphaOoM : rk(A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBpAsBsCsalphaOom : rk(A :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABBpAsBsCsalphaOoeq HABBpAsBsCsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpAsBsCsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)ABCBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOom4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)ABCApBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsBsCsalphaOo requis par la preuve de (?)BCBpAsBsCsalphaOo pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsBsCsalphaOom2 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsCsalphaOoeq HABCApBpAsBsCsalphaOom4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCApBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsBsCsalphaOomtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsBsCsalphaOom3 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsBsCsalphaOomtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoeq HABCBpAsBsCsalphaOom4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOomtmp;try rewrite HT2 in HABCBpAsBsCsalphaOomtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) (As :: nil) 4 1 2 HABCBpAsBsCsalphaOomtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsBsCsalphaOom4 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}


assert(HBCBpAsBsCsalphaOoM : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpAsBsCsalphaOom : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HBCBpAsBsCsalphaOoeq HBCBpAsBsCsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAsBsCsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOo requis par la preuve de (?)ABCBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOom4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsBsCsalphaOoM : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsBsCsalphaOom : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABCBpAsBsCsalphaOoeq HABCBpAsBsCsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpAsBsCsalphaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOo requis par la preuve de (?)ABCApBpAsBsCsalphaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOom4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpAsBsCsalphaOoM : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpAsBsCsalphaOom : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo ::  nil) >= 1) by (solve_hyps_min HABCApBpAsBsCsalphaOoeq HABCApBpAsBsCsalphaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApAsCsbetaOo : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsCsbetaOo requis par la preuve de (?)ABCApAsCsbetaOo pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsCsbetaOom4 : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsCsbetaOoM : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsCsbetaOom : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo ::  nil) >= 1) by (solve_hyps_min HABCApAsCsbetaOoeq HABCApAsCsbetaOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Op ::  nil) = 1.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HOpM : rk(Op ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HOpeq HOpM1).
assert(HOpm : rk(Op ::  nil) >= 1) by (solve_hyps_min HOpeq HOpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAOp *)
(* dans constructLemma(), requis par LABBsOp *)
(* dans la couche 0 *)
Lemma LABCBsalphaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bs :: alpha :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBsalphaOp requis par la preuve de (?)ABCBsalphaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBsalphaOpm4 : rk(A :: B :: C :: Bs :: alpha :: Op :: nil) >= 4).
{
	try assert(HABCBseq : rk(A :: B :: C :: Bs :: nil) = 4) by (apply LABCBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBsmtmp : rk(A :: B :: C :: Bs :: nil) >= 4) by (solve_hyps_min HABCBseq HABCBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bs :: nil) (A :: B :: C :: Bs :: alpha :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bs :: nil) (A :: B :: C :: Bs :: alpha :: Op :: nil) 4 4 HABCBsmtmp Hcomp Hincl);apply HT.
}
try clear HABCBsM1. try clear HABCBsM2. try clear HABCBsM3. try clear HABCBsm4. try clear HABCBsm3. try clear HABCBsm2. try clear HABCBsm1. 

assert(HABCBsalphaOpM : rk(A :: B :: C :: Bs :: alpha :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBsalphaOpm : rk(A :: B :: C :: Bs :: alpha :: Op ::  nil) >= 1) by (solve_hyps_min HABCBsalphaOpeq HABCBsalphaOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBsOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: Bs :: Op ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBsOp requis par la preuve de (?)ABBsOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBs requis par la preuve de (?)ABBsOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABBs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBs requis par la preuve de (?)ABBs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABBsm2 : rk(A :: B :: Bs :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApBsalphaeq : rk(A :: B :: C :: Ap :: Bs :: alpha :: nil) = 4) by (apply LABCApBsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBsalphamtmp : rk(A :: B :: C :: Ap :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBsalphaeq HABCApBsalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: Bs :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bs :: alpha :: nil) (A :: B :: Bs :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bs :: B :: C :: Ap :: alpha :: nil) ((A :: B :: Bs :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBsalphamtmp;try rewrite HT2 in HABCApBsalphamtmp.
	assert(HT := rule_2 (A :: B :: Bs :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApBsalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}
try clear HABCApBsalphaM1. try clear HABCApBsalphaM2. try clear HABCApBsalphaM3. try clear HABCApBsalpham4. try clear HABCApBsalpham3. try clear HABCApBsalpham2. try clear HABCApBsalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBsOp requis par la preuve de (?)ABBsOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BBsOp requis par la preuve de (?)ABBsOp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBsOp requis par la preuve de (?)ABBsOp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HABBsOpM3 : rk(A :: B :: Bs :: Op :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBBsOpMtmp : rk(B :: Bs :: Op :: nil) <= 2) by (solve_hyps_max HBBsOpeq HBBsOpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: Bs :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bs :: Op :: nil) (A :: B :: Bs :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bs :: Op :: nil) ((A :: nil) ++ (B :: Bs :: Op :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: Bs :: Op :: nil) (nil) 1 2 0 HAMtmp HBBsOpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABBsOpm2 : rk(A :: B :: Bs :: Op :: nil) >= 2).
{
	assert(HABBsmtmp : rk(A :: B :: Bs :: nil) >= 2) by (solve_hyps_min HABBseq HABBsm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bs :: nil) (A :: B :: Bs :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bs :: nil) (A :: B :: Bs :: Op :: nil) 2 2 HABBsmtmp Hcomp Hincl);apply HT.
}
try clear HABBsM1. try clear HABBsM2. try clear HABBsM3. try clear HABBsm4. try clear HABBsm3. try clear HABBsm2. try clear HABBsm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bs :: alpha :: Op ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HABBsOpm3 : rk(A :: B :: Bs :: Op :: nil) >= 3).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCBsalphaOpeq : rk(A :: B :: C :: Bs :: alpha :: Op :: nil) = 4) by (apply LABCBsalphaOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBsalphaOpmtmp : rk(A :: B :: C :: Bs :: alpha :: Op :: nil) >= 4) by (solve_hyps_min HABCBsalphaOpeq HABCBsalphaOpm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (A :: B :: Bs :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bs :: alpha :: Op :: nil) (B :: C :: alpha :: A :: B :: Bs :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: B :: Bs :: Op :: nil) ((B :: C :: alpha :: nil) ++ (A :: B :: Bs :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBsalphaOpmtmp;try rewrite HT2 in HABCBsalphaOpmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: B :: Bs :: Op :: nil) (B :: nil) 4 1 2 HABCBsalphaOpmtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCBsalphaOpM1. try clear HABCBsalphaOpM2. try clear HABCBsalphaOpM3. try clear HABCBsalphaOpm4. try clear HABCBsalphaOpm3. try clear HABCBsalphaOpm2. try clear HABCBsalphaOpm1. 

assert(HABBsOpM : rk(A :: B :: Bs :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBsOpm : rk(A :: B :: Bs :: Op ::  nil) >= 1) by (solve_hyps_min HABBsOpeq HABBsOpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAOp *)
(* dans la couche 0 *)
Lemma LBBsOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBBsOpM : rk(B :: Bs :: Op ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBBsOpeq HBBsOpM3).
assert(HBBsOpm : rk(B :: Bs :: Op ::  nil) >= 1) by (solve_hyps_min HBBsOpeq HBBsOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Op ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AOp requis par la preuve de (?)AOp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAOpm2 : rk(A :: Op :: nil) >= 2).
{
	try assert(HBBsOpeq : rk(B :: Bs :: Op :: nil) = 2) by (apply LBBsOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBsOpMtmp : rk(B :: Bs :: Op :: nil) <= 2) by (solve_hyps_max HBBsOpeq HBBsOpM2).
	try assert(HABBsOpeq : rk(A :: B :: Bs :: Op :: nil) = 3) by (apply LABBsOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABBsOpmtmp : rk(A :: B :: Bs :: Op :: nil) >= 3) by (solve_hyps_min HABBsOpeq HABBsOpm3).
	try assert(HOpeq : rk(Op :: nil) = 1) by (apply LOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HOpmtmp : rk(Op :: nil) >= 1) by (solve_hyps_min HOpeq HOpm1).
	assert(Hincl : incl (Op :: nil) (list_inter (A :: Op :: nil) (B :: Bs :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bs :: Op :: nil) (A :: Op :: B :: Bs :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Op :: B :: Bs :: Op :: nil) ((A :: Op :: nil) ++ (B :: Bs :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBsOpmtmp;try rewrite HT2 in HABBsOpmtmp.
	assert(HT := rule_2 (A :: Op :: nil) (B :: Bs :: Op :: nil) (Op :: nil) 3 1 2 HABBsOpmtmp HOpmtmp HBBsOpMtmp Hincl);apply HT.
}


assert(HAOpM : rk(A :: Op ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAOpeq HAOpM2).
assert(HAOpm : rk(A :: Op ::  nil) >= 1) by (solve_hyps_min HAOpeq HAOpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABOp *)
(* dans constructLemma(), requis par LABAsOp *)
(* dans la couche 0 *)
Lemma LABCAsalphaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: As :: alpha :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAsalphaOp requis par la preuve de (?)ABCAsalphaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCAsalphaOpm4 : rk(A :: B :: C :: As :: alpha :: Op :: nil) >= 4).
{
	try assert(HABCAseq : rk(A :: B :: C :: As :: nil) = 4) by (apply LABCAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsmtmp : rk(A :: B :: C :: As :: nil) >= 4) by (solve_hyps_min HABCAseq HABCAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: Op :: nil) 4 4 HABCAsmtmp Hcomp Hincl);apply HT.
}


assert(HABCAsalphaOpM : rk(A :: B :: C :: As :: alpha :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCAsalphaOpm : rk(A :: B :: C :: As :: alpha :: Op ::  nil) >= 1) by (solve_hyps_min HABCAsalphaOpeq HABCAsalphaOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABAsOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: As :: Op ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAsOp requis par la preuve de (?)ABAsOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAs requis par la preuve de (?)ABAsOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAs requis par la preuve de (?)ABAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABAsm2 : rk(A :: B :: As :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: As :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: B :: As :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: As :: B :: C :: Ap :: alpha :: nil) ((A :: B :: As :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: B :: As :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApAsalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAsOp requis par la preuve de (?)ABAsOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour AAsOp requis par la preuve de (?)ABAsOp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABAsOp requis par la preuve de (?)ABAsOp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HABAsOpM3 : rk(A :: B :: As :: Op :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HAAsOpMtmp : rk(A :: As :: Op :: nil) <= 2) by (solve_hyps_max HAAsOpeq HAAsOpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: As :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: As :: Op :: nil) (B :: A :: As :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: As :: Op :: nil) ((B :: nil) ++ (A :: As :: Op :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: As :: Op :: nil) (nil) 1 2 0 HBMtmp HAAsOpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HABAsOpm2 : rk(A :: B :: As :: Op :: nil) >= 2).
{
	assert(HABAsmtmp : rk(A :: B :: As :: nil) >= 2) by (solve_hyps_min HABAseq HABAsm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: As :: nil) (A :: B :: As :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: As :: nil) (A :: B :: As :: Op :: nil) 2 2 HABAsmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: As :: alpha :: Op ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HABAsOpm3 : rk(A :: B :: As :: Op :: nil) >= 3).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCAsalphaOpeq : rk(A :: B :: C :: As :: alpha :: Op :: nil) = 4) by (apply LABCAsalphaOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsalphaOpmtmp : rk(A :: B :: C :: As :: alpha :: Op :: nil) >= 4) by (solve_hyps_min HABCAsalphaOpeq HABCAsalphaOpm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (A :: B :: As :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: As :: alpha :: Op :: nil) (B :: C :: alpha :: A :: B :: As :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: B :: As :: Op :: nil) ((B :: C :: alpha :: nil) ++ (A :: B :: As :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCAsalphaOpmtmp;try rewrite HT2 in HABCAsalphaOpmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: B :: As :: Op :: nil) (B :: nil) 4 1 2 HABCAsalphaOpmtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCAsalphaOpM1. try clear HABCAsalphaOpM2. try clear HABCAsalphaOpM3. try clear HABCAsalphaOpm4. try clear HABCAsalphaOpm3. try clear HABCAsalphaOpm2. try clear HABCAsalphaOpm1. 

assert(HABAsOpM : rk(A :: B :: As :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABAsOpm : rk(A :: B :: As :: Op ::  nil) >= 1) by (solve_hyps_min HABAsOpeq HABAsOpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABOp *)
(* dans la couche 0 *)
Lemma LAAsOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HAAsOpM : rk(A :: As :: Op ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAAsOpeq HAAsOpM3).
assert(HAAsOpm : rk(A :: As :: Op ::  nil) >= 1) by (solve_hyps_min HAAsOpeq HAAsOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: Op ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABOp requis par la preuve de (?)ABOp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApalphaOp requis par la preuve de (?)ABOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApalphaOp requis par la preuve de (?)ABApalphaOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalphaOp requis par la preuve de (?)ABCApalphaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalphaOpm4 : rk(A :: B :: C :: Ap :: alpha :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApalphaOp requis par la preuve de (?)ABApalphaOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: alpha :: Op ::  de rang :  4 et 4 	 AiB : B :: alpha ::  de rang :  2 et 2 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HABApalphaOpm4 : rk(A :: B :: Ap :: alpha :: Op :: nil) >= 4).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCApalphaOpmtmp : rk(A :: B :: C :: Ap :: alpha :: Op :: nil) >= 4) by (solve_hyps_min HABCApalphaOpeq HABCApalphaOpm4).
	try assert(HBalphaeq : rk(B :: alpha :: nil) = 2) by (apply LBalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBalphamtmp : rk(B :: alpha :: nil) >= 2) by (solve_hyps_min HBalphaeq HBalpham2).
	assert(Hincl : incl (B :: alpha :: nil) (list_inter (B :: C :: alpha :: nil) (A :: B :: Ap :: alpha :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: alpha :: Op :: nil) (B :: C :: alpha :: A :: B :: Ap :: alpha :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: B :: Ap :: alpha :: Op :: nil) ((B :: C :: alpha :: nil) ++ (A :: B :: Ap :: alpha :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApalphaOpmtmp;try rewrite HT2 in HABCApalphaOpmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: B :: Ap :: alpha :: Op :: nil) (B :: alpha :: nil) 4 2 2 HABCApalphaOpmtmp HBalphamtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HBalphaM1. try clear HBalphaM2. try clear HBalphaM3. try clear HBalpham4. try clear HBalpham3. try clear HBalpham2. try clear HBalpham1. try clear HABCApalphaOpM1. try clear HABCApalphaOpM2. try clear HABCApalphaOpM3. try clear HABCApalphaOpm4. try clear HABCApalphaOpm3. try clear HABCApalphaOpm2. try clear HABCApalphaOpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABOp requis par la preuve de (?)ABOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: alpha :: Op ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: alpha ::   de rang : 2 et 2 *)
assert(HABOpm2 : rk(A :: B :: Op :: nil) >= 2).
{
	try assert(HApalphaeq : rk(Ap :: alpha :: nil) = 2) by (apply LApalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApalphaMtmp : rk(Ap :: alpha :: nil) <= 2) by (solve_hyps_max HApalphaeq HApalphaM2).
	assert(HABApalphaOpmtmp : rk(A :: B :: Ap :: alpha :: Op :: nil) >= 4) by (solve_hyps_min HABApalphaOpeq HABApalphaOpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: alpha :: nil) (A :: B :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: alpha :: Op :: nil) (Ap :: alpha :: A :: B :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: alpha :: A :: B :: Op :: nil) ((Ap :: alpha :: nil) ++ (A :: B :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApalphaOpmtmp;try rewrite HT2 in HABApalphaOpmtmp.
	assert(HT := rule_4 (Ap :: alpha :: nil) (A :: B :: Op :: nil) (nil) 4 0 2 HABApalphaOpmtmp Hmtmp HApalphaMtmp Hincl); apply HT.
}
try clear HApalphaM1. try clear HApalphaM2. try clear HApalphaM3. try clear HApalpham4. try clear HApalpham3. try clear HApalpham2. try clear HApalpham1. try clear HABApalphaOpM1. try clear HABApalphaOpM2. try clear HABApalphaOpM3. try clear HABApalphaOpm4. try clear HABApalphaOpm3. try clear HABApalphaOpm2. try clear HABApalphaOpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABOpm3 : rk(A :: B :: Op :: nil) >= 3).
{
	try assert(HAAsOpeq : rk(A :: As :: Op :: nil) = 2) by (apply LAAsOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAAsOpMtmp : rk(A :: As :: Op :: nil) <= 2) by (solve_hyps_max HAAsOpeq HAAsOpM2).
	try assert(HABAsOpeq : rk(A :: B :: As :: Op :: nil) = 3) by (apply LABAsOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABAsOpmtmp : rk(A :: B :: As :: Op :: nil) >= 3) by (solve_hyps_min HABAsOpeq HABAsOpm3).
	try assert(HAOpeq : rk(A :: Op :: nil) = 2) by (apply LAOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAOpmtmp : rk(A :: Op :: nil) >= 2) by (solve_hyps_min HAOpeq HAOpm2).
	assert(Hincl : incl (A :: Op :: nil) (list_inter (A :: B :: Op :: nil) (A :: As :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: As :: Op :: nil) (A :: B :: Op :: A :: As :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Op :: A :: As :: Op :: nil) ((A :: B :: Op :: nil) ++ (A :: As :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABAsOpmtmp;try rewrite HT2 in HABAsOpmtmp.
	assert(HT := rule_2 (A :: B :: Op :: nil) (A :: As :: Op :: nil) (A :: Op :: nil) 3 2 2 HABAsOpmtmp HAOpmtmp HAAsOpMtmp Hincl);apply HT.
}


assert(HABOpM : rk(A :: B :: Op ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABOpeq HABOpM3).
assert(HABOpm : rk(A :: B :: Op ::  nil) >= 1) by (solve_hyps_min HABOpeq HABOpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABBpOp *)
(* dans la couche 0 *)
Lemma LABBpAsgammaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: Bp :: As :: gamma :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpAsgammaOp requis par la preuve de (?)ABBpAsgammaOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsgammaOp requis par la preuve de (?)ABBpAsgammaOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsgammaOp requis par la preuve de (?)ABCBpAsgammaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsgammaOpm4 : rk(A :: B :: C :: Bp :: As :: gamma :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: gamma :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: gamma :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAs requis par la preuve de (?)ABBpAsgammaOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpAsgammaOp requis par la preuve de (?)ABBpAsgammaOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsgammaOp requis par la preuve de (?)ABBpAsgammaOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsgammaOp requis par la preuve de (?)ABCApBpAsgammaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsgammaOpm4 : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: gamma :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: gamma :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBpAsgammaOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABBpm2 : rk(A :: B :: Bp :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: B :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApBpalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpAsgammaOp requis par la preuve de (?)ABBpAsgammaOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: gamma :: Op ::  de rang :  4 et 4 	 AiB : A :: B :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HABBpAsgammaOpm2 : rk(A :: B :: Bp :: As :: gamma :: Op :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsgammaOpmtmp : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: Op :: nil) >= 4) by (solve_hyps_min HABCApBpAsgammaOpeq HABCApBpAsgammaOpm4).
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 2) by (solve_hyps_min HABBpeq HABBpm2).
	assert(Hincl : incl (A :: B :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: As :: gamma :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: gamma :: Op :: nil) (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: As :: gamma :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: As :: gamma :: Op :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: B :: Bp :: As :: gamma :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsgammaOpmtmp;try rewrite HT2 in HABCApBpAsgammaOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: As :: gamma :: Op :: nil) (A :: B :: Bp :: nil) 4 2 4 HABCApBpAsgammaOpmtmp HABBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsgammaOpM1. try clear HABCApBpAsgammaOpM2. try clear HABCApBpAsgammaOpM3. try clear HABCApBpAsgammaOpm4. try clear HABCApBpAsgammaOpm3. try clear HABCApBpAsgammaOpm2. try clear HABCApBpAsgammaOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: gamma :: Op ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : C :: As ::   de rang : 1 et 2 *)
assert(HABBpAsgammaOpm3 : rk(A :: B :: Bp :: As :: gamma :: Op :: nil) >= 3).
{
	assert(HCAsMtmp : rk(C :: As :: nil) <= 2) by (solve_hyps_max HCAseq HCAsM2).
	assert(HABCBpAsgammaOpmtmp : rk(A :: B :: C :: Bp :: As :: gamma :: Op :: nil) >= 4) by (solve_hyps_min HABCBpAsgammaOpeq HABCBpAsgammaOpm4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (C :: As :: nil) (A :: B :: Bp :: As :: gamma :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: gamma :: Op :: nil) (C :: As :: A :: B :: Bp :: As :: gamma :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: As :: A :: B :: Bp :: As :: gamma :: Op :: nil) ((C :: As :: nil) ++ (A :: B :: Bp :: As :: gamma :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsgammaOpmtmp;try rewrite HT2 in HABCBpAsgammaOpmtmp.
	assert(HT := rule_4 (C :: As :: nil) (A :: B :: Bp :: As :: gamma :: Op :: nil) (As :: nil) 4 1 2 HABCBpAsgammaOpmtmp HAsmtmp HCAsMtmp Hincl); apply HT.
}
try clear HABCBpAsgammaOpM1. try clear HABCBpAsgammaOpM2. try clear HABCBpAsgammaOpM3. try clear HABCBpAsgammaOpm4. try clear HABCBpAsgammaOpm3. try clear HABCBpAsgammaOpm2. try clear HABCBpAsgammaOpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABBpAsgammaOpm4 : rk(A :: B :: Bp :: As :: gamma :: Op :: nil) >= 4).
{
	try assert(HABpAsgammaeq : rk(A :: Bp :: As :: gamma :: nil) = 4) by (apply LABpAsgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABpAsgammamtmp : rk(A :: Bp :: As :: gamma :: nil) >= 4) by (solve_hyps_min HABpAsgammaeq HABpAsgammam4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: As :: gamma :: nil) (A :: B :: Bp :: As :: gamma :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: As :: gamma :: nil) (A :: B :: Bp :: As :: gamma :: Op :: nil) 4 4 HABpAsgammamtmp Hcomp Hincl);apply HT.
}


assert(HABBpAsgammaOpM : rk(A :: B :: Bp :: As :: gamma :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBpAsgammaOpm : rk(A :: B :: Bp :: As :: gamma :: Op ::  nil) >= 1) by (solve_hyps_min HABBpAsgammaOpeq HABBpAsgammaOpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABBpOp *)
(* dans la couche 0 *)
Lemma LABAsgammaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: As :: gamma :: Op ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABAsgammaOp requis par la preuve de (?)ABAsgammaOp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCAsalphagammaOp requis par la preuve de (?)ABAsgammaOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAsalphagammaOp requis par la preuve de (?)ABCAsalphagammaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCAsalphagammaOpm4 : rk(A :: B :: C :: As :: alpha :: gamma :: Op :: nil) >= 4).
{
	try assert(HABCAseq : rk(A :: B :: C :: As :: nil) = 4) by (apply LABCAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsmtmp : rk(A :: B :: C :: As :: nil) >= 4) by (solve_hyps_min HABCAseq HABCAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: gamma :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: gamma :: Op :: nil) 4 4 HABCAsmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABAsgammaOp requis par la preuve de (?)ABAsgammaOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApAsgammaOp requis par la preuve de (?)ABAsgammaOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsgammaOp requis par la preuve de (?)ABCApAsgammaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsgammaOpm4 : rk(A :: B :: C :: Ap :: As :: gamma :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: gamma :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: gamma :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAs requis par la preuve de (?)ABAsgammaOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAs requis par la preuve de (?)ABAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABAsm2 : rk(A :: B :: As :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: As :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: B :: As :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: As :: B :: C :: Ap :: alpha :: nil) ((A :: B :: As :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: B :: As :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApAsalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABAsgammaOp requis par la preuve de (?)ABAsgammaOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: gamma :: Op ::  de rang :  4 et 4 	 AiB : A :: B :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: As ::   de rang : 4 et 4 *)
assert(HABAsgammaOpm2 : rk(A :: B :: As :: gamma :: Op :: nil) >= 2).
{
	try assert(HABCApAseq : rk(A :: B :: C :: Ap :: As :: nil) = 4) by (apply LABCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsMtmp : rk(A :: B :: C :: Ap :: As :: nil) <= 4) by (solve_hyps_max HABCApAseq HABCApAsM4).
	assert(HABCApAsgammaOpmtmp : rk(A :: B :: C :: Ap :: As :: gamma :: Op :: nil) >= 4) by (solve_hyps_min HABCApAsgammaOpeq HABCApAsgammaOpm4).
	assert(HABAsmtmp : rk(A :: B :: As :: nil) >= 2) by (solve_hyps_min HABAseq HABAsm2).
	assert(Hincl : incl (A :: B :: As :: nil) (list_inter (A :: B :: C :: Ap :: As :: nil) (A :: B :: As :: gamma :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: gamma :: Op :: nil) (A :: B :: C :: Ap :: As :: A :: B :: As :: gamma :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: As :: A :: B :: As :: gamma :: Op :: nil) ((A :: B :: C :: Ap :: As :: nil) ++ (A :: B :: As :: gamma :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsgammaOpmtmp;try rewrite HT2 in HABCApAsgammaOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: As :: nil) (A :: B :: As :: gamma :: Op :: nil) (A :: B :: As :: nil) 4 2 4 HABCApAsgammaOpmtmp HABAsmtmp HABCApAsMtmp Hincl); apply HT.
}
try clear HABCApAsgammaOpM1. try clear HABCApAsgammaOpM2. try clear HABCApAsgammaOpM3. try clear HABCApAsgammaOpm4. try clear HABCApAsgammaOpm3. try clear HABCApAsgammaOpm2. try clear HABCApAsgammaOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: As :: alpha :: gamma :: Op ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HABAsgammaOpm3 : rk(A :: B :: As :: gamma :: Op :: nil) >= 3).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCAsalphagammaOpmtmp : rk(A :: B :: C :: As :: alpha :: gamma :: Op :: nil) >= 4) by (solve_hyps_min HABCAsalphagammaOpeq HABCAsalphagammaOpm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (A :: B :: As :: gamma :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: As :: alpha :: gamma :: Op :: nil) (B :: C :: alpha :: A :: B :: As :: gamma :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: B :: As :: gamma :: Op :: nil) ((B :: C :: alpha :: nil) ++ (A :: B :: As :: gamma :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCAsalphagammaOpmtmp;try rewrite HT2 in HABCAsalphagammaOpmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: B :: As :: gamma :: Op :: nil) (B :: nil) 4 1 2 HABCAsalphagammaOpmtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCAsalphagammaOpM1. try clear HABCAsalphagammaOpM2. try clear HABCAsalphagammaOpM3. try clear HABCAsalphagammaOpm4. try clear HABCAsalphagammaOpm3. try clear HABCAsalphagammaOpm2. try clear HABCAsalphagammaOpm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABAsgammaOpM3 : rk(A :: B :: As :: gamma :: Op :: nil) <= 3).
{
	try assert(HABgammaeq : rk(A :: B :: gamma :: nil) = 2) by (apply LABgamma with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABgammaMtmp : rk(A :: B :: gamma :: nil) <= 2) by (solve_hyps_max HABgammaeq HABgammaM2).
	try assert(HAAsOpeq : rk(A :: As :: Op :: nil) = 2) by (apply LAAsOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAAsOpMtmp : rk(A :: As :: Op :: nil) <= 2) by (solve_hyps_max HAAsOpeq HAAsOpM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: gamma :: nil) (A :: As :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: As :: gamma :: Op :: nil) (A :: B :: gamma :: A :: As :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: gamma :: A :: As :: Op :: nil) ((A :: B :: gamma :: nil) ++ (A :: As :: Op :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: gamma :: nil) (A :: As :: Op :: nil) (A :: nil) 2 2 1 HABgammaMtmp HAAsOpMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HABAsgammaOpM : rk(A :: B :: As :: gamma :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABAsgammaOpm : rk(A :: B :: As :: gamma :: Op ::  nil) >= 1) by (solve_hyps_min HABAsgammaOpeq HABAsgammaOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBpOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: Bp :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpOp requis par la preuve de (?)ABBpOp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpalphaOp requis par la preuve de (?)ABBpOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOp requis par la preuve de (?)ABCBpalphaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOpm4 : rk(A :: B :: C :: Bp :: alpha :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpOp requis par la preuve de (?)ABBpOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpOp requis par la preuve de (?)ABBpOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpOp requis par la preuve de (?)ABCApBpOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpOpm4 : rk(A :: B :: C :: Ap :: Bp :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBpOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABBpm2 : rk(A :: B :: Bp :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: B :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApBpalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpOp requis par la preuve de (?)ABBpOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Op ::  de rang :  4 et 4 	 AiB : A :: B :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HABBpOpm2 : rk(A :: B :: Bp :: Op :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpOpmtmp : rk(A :: B :: C :: Ap :: Bp :: Op :: nil) >= 4) by (solve_hyps_min HABCApBpOpeq HABCApBpOpm4).
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 2) by (solve_hyps_min HABBpeq HABBpm2).
	assert(Hincl : incl (A :: B :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Op :: nil) (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: Op :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: B :: Bp :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpOpmtmp;try rewrite HT2 in HABCApBpOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: Op :: nil) (A :: B :: Bp :: nil) 4 2 4 HABCApBpOpmtmp HABBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpOpM1. try clear HABCApBpOpM2. try clear HABCApBpOpM3. try clear HABCApBpOpm4. try clear HABCApBpOpm3. try clear HABCApBpOpm2. try clear HABCApBpOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: alpha :: Op ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HABBpOpm3 : rk(A :: B :: Bp :: Op :: nil) >= 3).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCBpalphaOpmtmp : rk(A :: B :: C :: Bp :: alpha :: Op :: nil) >= 4) by (solve_hyps_min HABCBpalphaOpeq HABCBpalphaOpm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (A :: B :: Bp :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: alpha :: Op :: nil) (B :: C :: alpha :: A :: B :: Bp :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: B :: Bp :: Op :: nil) ((B :: C :: alpha :: nil) ++ (A :: B :: Bp :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpalphaOpmtmp;try rewrite HT2 in HABCBpalphaOpmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: B :: Bp :: Op :: nil) (B :: nil) 4 1 2 HABCBpalphaOpmtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCBpalphaOpM1. try clear HABCBpalphaOpM2. try clear HABCBpalphaOpM3. try clear HABCBpalphaOpm4. try clear HABCBpalphaOpm3. try clear HABCBpalphaOpm2. try clear HABCBpalphaOpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABBpOpm4 : rk(A :: B :: Bp :: Op :: nil) >= 4).
{
	try assert(HABAsgammaOpeq : rk(A :: B :: As :: gamma :: Op :: nil) = 3) by (apply LABAsgammaOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABAsgammaOpMtmp : rk(A :: B :: As :: gamma :: Op :: nil) <= 3) by (solve_hyps_max HABAsgammaOpeq HABAsgammaOpM3).
	try assert(HABBpAsgammaOpeq : rk(A :: B :: Bp :: As :: gamma :: Op :: nil) = 4) by (apply LABBpAsgammaOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABBpAsgammaOpmtmp : rk(A :: B :: Bp :: As :: gamma :: Op :: nil) >= 4) by (solve_hyps_min HABBpAsgammaOpeq HABBpAsgammaOpm4).
	try assert(HABOpeq : rk(A :: B :: Op :: nil) = 3) by (apply LABOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABOpmtmp : rk(A :: B :: Op :: nil) >= 3) by (solve_hyps_min HABOpeq HABOpm3).
	assert(Hincl : incl (A :: B :: Op :: nil) (list_inter (A :: B :: Bp :: Op :: nil) (A :: B :: As :: gamma :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: As :: gamma :: Op :: nil) (A :: B :: Bp :: Op :: A :: B :: As :: gamma :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bp :: Op :: A :: B :: As :: gamma :: Op :: nil) ((A :: B :: Bp :: Op :: nil) ++ (A :: B :: As :: gamma :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpAsgammaOpmtmp;try rewrite HT2 in HABBpAsgammaOpmtmp.
	assert(HT := rule_2 (A :: B :: Bp :: Op :: nil) (A :: B :: As :: gamma :: Op :: nil) (A :: B :: Op :: nil) 4 3 3 HABBpAsgammaOpmtmp HABOpmtmp HABAsgammaOpMtmp Hincl);apply HT.
}


assert(HABBpOpM : rk(A :: B :: Bp :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBpOpm : rk(A :: B :: Bp :: Op ::  nil) >= 1) by (solve_hyps_min HABBpOpeq HABBpOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpOp requis par la preuve de (?)ABCApBpOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpOpm4 : rk(A :: B :: C :: Ap :: Bp :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpOpM : rk(A :: B :: C :: Ap :: Bp :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpOpm : rk(A :: B :: C :: Ap :: Bp :: Op ::  nil) >= 1) by (solve_hyps_min HABCApBpOpeq HABCApBpOpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApalphaOp *)
(* dans la couche 0 *)
Lemma LABCApalphaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: alpha :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalphaOp requis par la preuve de (?)ABCApalphaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalphaOpm4 : rk(A :: B :: C :: Ap :: alpha :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApalphaOpM : rk(A :: B :: C :: Ap :: alpha :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApalphaOpm : rk(A :: B :: C :: Ap :: alpha :: Op ::  nil) >= 1) by (solve_hyps_min HABCApalphaOpeq HABCApalphaOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApalphaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: Ap :: alpha :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApalphaOp requis par la preuve de (?)ABApalphaOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: alpha :: Op ::  de rang :  4 et 4 	 AiB : B :: alpha ::  de rang :  2 et 2 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HABApalphaOpm4 : rk(A :: B :: Ap :: alpha :: Op :: nil) >= 4).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApalphaOpeq : rk(A :: B :: C :: Ap :: alpha :: Op :: nil) = 4) by (apply LABCApalphaOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApalphaOpmtmp : rk(A :: B :: C :: Ap :: alpha :: Op :: nil) >= 4) by (solve_hyps_min HABCApalphaOpeq HABCApalphaOpm4).
	try assert(HBalphaeq : rk(B :: alpha :: nil) = 2) by (apply LBalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBalphamtmp : rk(B :: alpha :: nil) >= 2) by (solve_hyps_min HBalphaeq HBalpham2).
	assert(Hincl : incl (B :: alpha :: nil) (list_inter (B :: C :: alpha :: nil) (A :: B :: Ap :: alpha :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: alpha :: Op :: nil) (B :: C :: alpha :: A :: B :: Ap :: alpha :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: B :: Ap :: alpha :: Op :: nil) ((B :: C :: alpha :: nil) ++ (A :: B :: Ap :: alpha :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApalphaOpmtmp;try rewrite HT2 in HABCApalphaOpmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: B :: Ap :: alpha :: Op :: nil) (B :: alpha :: nil) 4 2 2 HABCApalphaOpmtmp HBalphamtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HBalphaM1. try clear HBalphaM2. try clear HBalphaM3. try clear HBalpham4. try clear HBalpham3. try clear HBalpham2. try clear HBalpham1. try clear HABCApalphaOpM1. try clear HABCApalphaOpM2. try clear HABCApalphaOpM3. try clear HABCApalphaOpm4. try clear HABCApalphaOpm3. try clear HABCApalphaOpm2. try clear HABCApalphaOpm1. 

assert(HABApalphaOpM : rk(A :: B :: Ap :: alpha :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApalphaOpm : rk(A :: B :: Ap :: alpha :: Op ::  nil) >= 1) by (solve_hyps_min HABApalphaOpeq HABApalphaOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpalphaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: alpha :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOp requis par la preuve de (?)ABCBpalphaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOpm4 : rk(A :: B :: C :: Bp :: alpha :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpalphaOpM : rk(A :: B :: C :: Bp :: alpha :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpalphaOpm : rk(A :: B :: C :: Bp :: alpha :: Op ::  nil) >= 1) by (solve_hyps_min HABCBpalphaOpeq HABCBpalphaOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApAsgammaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As :: gamma :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsgammaOp requis par la preuve de (?)ABCApAsgammaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsgammaOpm4 : rk(A :: B :: C :: Ap :: As :: gamma :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: gamma :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: gamma :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsgammaOpM : rk(A :: B :: C :: Ap :: As :: gamma :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsgammaOpm : rk(A :: B :: C :: Ap :: As :: gamma :: Op ::  nil) >= 1) by (solve_hyps_min HABCApAsgammaOpeq HABCApAsgammaOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAsgammaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As :: gamma :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsgammaOp requis par la preuve de (?)ABCBpAsgammaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsgammaOpm4 : rk(A :: B :: C :: Bp :: As :: gamma :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: gamma :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: gamma :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsgammaOpM : rk(A :: B :: C :: Bp :: As :: gamma :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsgammaOpm : rk(A :: B :: C :: Bp :: As :: gamma :: Op ::  nil) >= 1) by (solve_hyps_min HABCBpAsgammaOpeq HABCBpAsgammaOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpAsgammaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsgammaOp requis par la preuve de (?)ABCApBpAsgammaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsgammaOpm4 : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: gamma :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: gamma :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpAsgammaOpM : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpAsgammaOpm : rk(A :: B :: C :: Ap :: Bp :: As :: gamma :: Op ::  nil) >= 1) by (solve_hyps_min HABCApBpAsgammaOpeq HABCApBpAsgammaOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCAsalphagammaOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: As :: alpha :: gamma :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAsalphagammaOp requis par la preuve de (?)ABCAsalphagammaOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCAsalphagammaOpm4 : rk(A :: B :: C :: As :: alpha :: gamma :: Op :: nil) >= 4).
{
	try assert(HABCAseq : rk(A :: B :: C :: As :: nil) = 4) by (apply LABCAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsmtmp : rk(A :: B :: C :: As :: nil) >= 4) by (solve_hyps_min HABCAseq HABCAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: gamma :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: gamma :: Op :: nil) 4 4 HABCAsmtmp Hcomp Hincl);apply HT.
}


assert(HABCAsalphagammaOpM : rk(A :: B :: C :: As :: alpha :: gamma :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCAsalphagammaOpm : rk(A :: B :: C :: As :: alpha :: gamma :: Op ::  nil) >= 1) by (solve_hyps_min HABCAsalphagammaOpeq HABCAsalphagammaOpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApOoOp *)
(* dans la couche 0 *)
Lemma LAApAsOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: As :: Oo :: Op ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApAsOoOp requis par la preuve de (?)AApAsOoOp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour AApAsCsbetaOoOp requis par la preuve de (?)AApAsOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApAsCsbetaOoOp requis par la preuve de (?)AApAsCsbetaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApAsCsbetaOoOp requis par la preuve de (?)AApAsCsbetaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsCsbetaOoOp requis par la preuve de (?)ABCApAsCsbetaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsCsbetaOoOpm4 : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAsCsbetaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApAsm2 : rk(A :: Ap :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: Ap :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: As :: B :: C :: alpha :: nil) ((A :: Ap :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: Ap :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApAsCsbetaOoOp requis par la preuve de (?)AApAsCsbetaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op ::  de rang :  4 et 4 	 AiB : A :: Ap :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: As ::   de rang : 4 et 4 *)
assert(HAApAsCsbetaOoOpm2 : rk(A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCApAseq : rk(A :: B :: C :: Ap :: As :: nil) = 4) by (apply LABCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsMtmp : rk(A :: B :: C :: Ap :: As :: nil) <= 4) by (solve_hyps_max HABCApAseq HABCApAsM4).
	assert(HABCApAsCsbetaOoOpmtmp : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCApAsCsbetaOoOpeq HABCApAsCsbetaOoOpm4).
	assert(HAApAsmtmp : rk(A :: Ap :: As :: nil) >= 2) by (solve_hyps_min HAApAseq HAApAsm2).
	assert(Hincl : incl (A :: Ap :: As :: nil) (list_inter (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) ((A :: B :: C :: Ap :: As :: nil) ++ (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsCsbetaOoOpmtmp;try rewrite HT2 in HABCApAsCsbetaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) (A :: Ap :: As :: nil) 4 2 4 HABCApAsCsbetaOoOpmtmp HAApAsmtmp HABCApAsMtmp Hincl); apply HT.
}
try clear HABCApAsCsbetaOoOpM1. try clear HABCApAsCsbetaOoOpM2. try clear HABCApAsCsbetaOoOpM3. try clear HABCApAsCsbetaOoOpm4. try clear HABCApAsCsbetaOoOpm3. try clear HABCApAsCsbetaOoOpm2. try clear HABCApAsCsbetaOoOpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApAsCsbetaOoOpm4 : rk(A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) >= 4).
{
	try assert(HAApAsCseq : rk(A :: Ap :: As :: Cs :: nil) = 4) by (apply LAApAsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsCsmtmp : rk(A :: Ap :: As :: Cs :: nil) >= 4) by (solve_hyps_min HAApAsCseq HAApAsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: As :: Cs :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: As :: Cs :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) 4 4 HAApAsCsmtmp Hcomp Hincl);apply HT.
}
try clear HAApAsCsM1. try clear HAApAsCsM2. try clear HAApAsCsM3. try clear HAApAsCsm4. try clear HAApAsCsm3. try clear HAApAsCsm2. try clear HAApAsCsm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApAsOoOp requis par la preuve de (?)AApAsOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApAsOoOp requis par la preuve de (?)AApAsOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsOoOp requis par la preuve de (?)ABCApAsOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsOoOpm4 : rk(A :: B :: C :: Ap :: As :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApAsOoOp requis par la preuve de (?)AApAsOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: Oo :: Op ::  de rang :  4 et 4 	 AiB : A :: Ap :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: As ::   de rang : 4 et 4 *)
assert(HAApAsOoOpm2 : rk(A :: Ap :: As :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCApAseq : rk(A :: B :: C :: Ap :: As :: nil) = 4) by (apply LABCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsMtmp : rk(A :: B :: C :: Ap :: As :: nil) <= 4) by (solve_hyps_max HABCApAseq HABCApAsM4).
	assert(HABCApAsOoOpmtmp : rk(A :: B :: C :: Ap :: As :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCApAsOoOpeq HABCApAsOoOpm4).
	assert(HAApAsmtmp : rk(A :: Ap :: As :: nil) >= 2) by (solve_hyps_min HAApAseq HAApAsm2).
	assert(Hincl : incl (A :: Ap :: As :: nil) (list_inter (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: Oo :: Op :: nil) (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Oo :: Op :: nil) ((A :: B :: C :: Ap :: As :: nil) ++ (A :: Ap :: As :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsOoOpmtmp;try rewrite HT2 in HABCApAsOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Oo :: Op :: nil) (A :: Ap :: As :: nil) 4 2 4 HABCApAsOoOpmtmp HAApAsmtmp HABCApAsMtmp Hincl); apply HT.
}
try clear HABCApAsOoOpM1. try clear HABCApAsOoOpM2. try clear HABCApAsOoOpM3. try clear HABCApAsOoOpm4. try clear HABCApAsOoOpm3. try clear HABCApAsOoOpm2. try clear HABCApAsOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: As :: Cs :: beta :: Oo :: Op ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : As :: Cs :: beta ::   de rang : 2 et 2 *)
assert(HAApAsOoOpm3 : rk(A :: Ap :: As :: Oo :: Op :: nil) >= 3).
{
	try assert(HAsCsbetaeq : rk(As :: Cs :: beta :: nil) = 2) by (apply LAsCsbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsCsbetaMtmp : rk(As :: Cs :: beta :: nil) <= 2) by (solve_hyps_max HAsCsbetaeq HAsCsbetaM2).
	assert(HAApAsCsbetaOoOpmtmp : rk(A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HAApAsCsbetaOoOpeq HAApAsCsbetaOoOpm4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (As :: Cs :: beta :: nil) (A :: Ap :: As :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) (As :: Cs :: beta :: A :: Ap :: As :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: Cs :: beta :: A :: Ap :: As :: Oo :: Op :: nil) ((As :: Cs :: beta :: nil) ++ (A :: Ap :: As :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApAsCsbetaOoOpmtmp;try rewrite HT2 in HAApAsCsbetaOoOpmtmp.
	assert(HT := rule_4 (As :: Cs :: beta :: nil) (A :: Ap :: As :: Oo :: Op :: nil) (As :: nil) 4 1 2 HAApAsCsbetaOoOpmtmp HAsmtmp HAsCsbetaMtmp Hincl); apply HT.
}
try clear HAApAsCsbetaOoOpM1. try clear HAApAsCsbetaOoOpM2. try clear HAApAsCsbetaOoOpM3. try clear HAApAsCsbetaOoOpm4. try clear HAApAsCsbetaOoOpm3. try clear HAApAsCsbetaOoOpm2. try clear HAApAsCsbetaOoOpm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAApAsOoOpM3 : rk(A :: Ap :: As :: Oo :: Op :: nil) <= 3).
{
	try assert(HApAsOoeq : rk(Ap :: As :: Oo :: nil) = 2) by (apply LApAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApAsOoMtmp : rk(Ap :: As :: Oo :: nil) <= 2) by (solve_hyps_max HApAsOoeq HApAsOoM2).
	try assert(HAAsOpeq : rk(A :: As :: Op :: nil) = 2) by (apply LAAsOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAAsOpMtmp : rk(A :: As :: Op :: nil) <= 2) by (solve_hyps_max HAAsOpeq HAAsOpM2).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (Ap :: As :: Oo :: nil) (A :: As :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: As :: Oo :: Op :: nil) (Ap :: As :: Oo :: A :: As :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: As :: Oo :: A :: As :: Op :: nil) ((Ap :: As :: Oo :: nil) ++ (A :: As :: Op :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: As :: Oo :: nil) (A :: As :: Op :: nil) (As :: nil) 2 2 1 HApAsOoMtmp HAAsOpMtmp HAsmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HAApAsOoOpM : rk(A :: Ap :: As :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApAsOoOpm : rk(A :: Ap :: As :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HAApAsOoOpeq HAApAsOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Oo :: Op ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApOoOp requis par la preuve de (?)AApOoOp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApOoOp requis par la preuve de (?)AApOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApalphaOoOp requis par la preuve de (?)AApOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalphaOoOp requis par la preuve de (?)ABCApalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalphaOoOpm4 : rk(A :: B :: C :: Ap :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApOoOp requis par la preuve de (?)AApOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HAApOoOpm2 : rk(A :: Ap :: Oo :: Op :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCApalphaOoOpmtmp : rk(A :: B :: C :: Ap :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCApalphaOoOpeq HABCApalphaOoOpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C :: alpha :: nil) (A :: Ap :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: alpha :: Oo :: Op :: nil) (B :: C :: alpha :: A :: Ap :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: Ap :: Oo :: Op :: nil) ((B :: C :: alpha :: nil) ++ (A :: Ap :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApalphaOoOpmtmp;try rewrite HT2 in HABCApalphaOoOpmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: Ap :: Oo :: Op :: nil) (nil) 4 0 2 HABCApalphaOoOpmtmp Hmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCApalphaOoOpM1. try clear HABCApalphaOoOpM2. try clear HABCApalphaOoOpM3. try clear HABCApalphaOoOpm4. try clear HABCApalphaOoOpm3. try clear HABCApalphaOoOpm2. try clear HABCApalphaOoOpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApOoOpm3 : rk(A :: Ap :: Oo :: Op :: nil) >= 3).
{
	try assert(HAApOoeq : rk(A :: Ap :: Oo :: nil) = 3) by (apply LAApOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApOomtmp : rk(A :: Ap :: Oo :: nil) >= 3) by (solve_hyps_min HAApOoeq HAApOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Oo :: nil) (A :: Ap :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Oo :: nil) (A :: Ap :: Oo :: Op :: nil) 3 3 HAApOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApOoOpM3 : rk(A :: Ap :: Oo :: Op :: nil) <= 3).
{
	try assert(HAApAsOoOpeq : rk(A :: Ap :: As :: Oo :: Op :: nil) = 3) by (apply LAApAsOoOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsOoOpMtmp : rk(A :: Ap :: As :: Oo :: Op :: nil) <= 3) by (solve_hyps_max HAApAsOoOpeq HAApAsOoOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Oo :: Op :: nil) (A :: Ap :: As :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Ap :: Oo :: Op :: nil) (A :: Ap :: As :: Oo :: Op :: nil) 3 3 HAApAsOoOpMtmp Hcomp Hincl);apply HT.
}


assert(HAApOoOpM : rk(A :: Ap :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApOoOpm : rk(A :: Ap :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HAApOoOpeq HAApOoOpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBpOoOp *)
(* dans la couche 0 *)
Lemma LBBpBsOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: Bs :: Oo :: Op ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpBsOoOp requis par la preuve de (?)BBpBsOoOp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BBpBsCsalphaOoOp requis par la preuve de (?)BBpBsOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpBsCsalphaOoOp requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOoOp requis par la preuve de (?)ABCBpAsBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOoOpm4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOoOp requis par la preuve de (?)ABCApBpAsBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOoOpm4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsBsCsalphaOoOpm2 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsCsalphaOoOpeq HABCApBpAsBsCsalphaOoOpm4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCApBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsBsCsalphaOoOpmtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsBsCsalphaOoOpM1. try clear HABCApBpAsBsCsalphaOoOpM2. try clear HABCApBpAsBsCsalphaOoOpM3. try clear HABCApBpAsBsCsalphaOoOpm4. try clear HABCApBpAsBsCsalphaOoOpm3. try clear HABCApBpAsBsCsalphaOoOpm2. try clear HABCApBpAsBsCsalphaOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsBsCsalphaOoOpm3 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoOpeq HABCBpAsBsCsalphaOoOpm4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (As :: nil) 4 1 2 HABCBpAsBsCsalphaOoOpmtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsBsCsalphaOoOpm4 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}
try clear HBCBpAsM1. try clear HBCBpAsM2. try clear HBCBpAsM3. try clear HBCBpAsm4. try clear HBCBpAsm3. try clear HBCBpAsm2. try clear HBCBpAsm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBs requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpAs requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsalpham2 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpAsalphaeq : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) = 4) by (apply LABCApBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpAsalphaeq HABCApBpAsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsalphamtmp;try rewrite HT2 in HABCApBpAsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsalphamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsalpham3 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	try assert(HABCBpAsalphaeq : rk(A :: B :: C :: Bp :: As :: alpha :: nil) = 4) by (apply LABCBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsalphamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: nil) (A :: As :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: alpha :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphamtmp;try rewrite HT2 in HABCBpAsalphamtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil) (As :: nil) 4 1 2 HABCBpAsalphamtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpAs requis par la preuve de (?)BBpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HBBpAsm2 : rk(B :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpAsalphamtmp : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3) by (solve_hyps_min HBCBpAsalphaeq HBCBpAsalpham3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: alpha :: nil) (B :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: As :: B :: C :: alpha :: nil) ((B :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsalphamtmp;try rewrite HT2 in HBCBpAsalphamtmp.
	assert(HT := rule_2 (B :: Bp :: As :: nil) (B :: C :: alpha :: nil) (B :: nil) 3 1 2 HBCBpAsalphamtmp HBmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HBBpAsBsCsalphaOoOpm2 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoOpeq HABCBpAsBsCsalphaOoOpm4).
	assert(HBBpAsmtmp : rk(B :: Bp :: As :: nil) >= 2) by (solve_hyps_min HBBpAseq HBBpAsm2).
	assert(Hincl : incl (B :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: B :: C :: Bp :: As :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (B :: Bp :: As :: nil) 4 2 4 HABCBpAsBsCsalphaOoOpmtmp HBBpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}
try clear HABCBpAsBsCsalphaOoOpM1. try clear HABCBpAsBsCsalphaOoOpM2. try clear HABCBpAsBsCsalphaOoOpM3. try clear HABCBpAsBsCsalphaOoOpm4. try clear HABCBpAsBsCsalphaOoOpm3. try clear HABCBpAsBsCsalphaOoOpm2. try clear HABCBpAsBsCsalphaOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : C :: Bs ::   de rang : 1 et 2 *)
assert(HBBpAsBsCsalphaOoOpm3 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 3).
{
	assert(HCBsMtmp : rk(C :: Bs :: nil) <= 2) by (solve_hyps_max HCBseq HCBsM2).
	assert(HBCBpAsBsCsalphaOoOpmtmp : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HBCBpAsBsCsalphaOoOpeq HBCBpAsBsCsalphaOoOpm4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (C :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (C :: Bs :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bs :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((C :: Bs :: nil) ++ (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HBCBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (C :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (Bs :: nil) 4 1 2 HBCBpAsBsCsalphaOoOpmtmp HBsmtmp HCBsMtmp Hincl); apply HT.
}
try clear HBCBpAsBsCsalphaOoOpM1. try clear HBCBpAsBsCsalphaOoOpM2. try clear HBCBpAsBsCsalphaOoOpM3. try clear HBCBpAsBsCsalphaOoOpm4. try clear HBCBpAsBsCsalphaOoOpm3. try clear HBCBpAsBsCsalphaOoOpm2. try clear HBCBpAsBsCsalphaOoOpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpAsBsCsalphaOoOpm4 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HBBpAsBseq : rk(B :: Bp :: As :: Bs :: nil) = 4) by (apply LBBpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpAsBsmtmp : rk(B :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HBBpAsBseq HBBpAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: As :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: As :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HBBpAsBsmtmp Hcomp Hincl);apply HT.
}
try clear HBBpAsBsM1. try clear HBBpAsBsM2. try clear HBBpAsBsM3. try clear HBBpAsBsm4. try clear HBBpAsBsm3. try clear HBBpAsBsm2. try clear HBBpAsBsm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AsCs requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpBsCsalphaOoOp requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpBsCsalphaOoOp requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBsCsalphaOoOp requis par la preuve de (?)ABCBpBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsCsalphaOoOpm4 : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpBs requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpBsalpha requis par la preuve de (?)BBpBs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABs requis par la preuve de (?)BCBpBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpBsalpha requis par la preuve de (?)BCBpBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpBsalpha requis par la preuve de (?)BCBpBsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Bs :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpBsalpham2 : rk(B :: C :: Bp :: Bs :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpBsalphaeq : rk(A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) = 4) by (apply LABCApBpBsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpBsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpBsalphaeq HABCApBpBsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: Bs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: Bs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: Bs :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: Bs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpBsalphamtmp;try rewrite HT2 in HABCApBpBsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: Bs :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpBsalphamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpBsalphaM1. try clear HABCApBpBsalphaM2. try clear HABCApBpBsalphaM3. try clear HABCApBpBsalpham4. try clear HABCApBpBsalpham3. try clear HABCApBpBsalpham2. try clear HABCApBpBsalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: Bs :: alpha ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : A :: Bs ::   de rang : 1 et 2 *)
assert(HBCBpBsalpham3 : rk(B :: C :: Bp :: Bs :: alpha :: nil) >= 3).
{
	assert(HABsMtmp : rk(A :: Bs :: nil) <= 2) by (solve_hyps_max HABseq HABsM2).
	try assert(HABCBpBsalphaeq : rk(A :: B :: C :: Bp :: Bs :: alpha :: nil) = 4) by (apply LABCBpBsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpBsalphamtmp : rk(A :: B :: C :: Bp :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpBsalphaeq HABCBpBsalpham4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (A :: Bs :: nil) (B :: C :: Bp :: Bs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: Bs :: alpha :: nil) (A :: Bs :: B :: C :: Bp :: Bs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bs :: B :: C :: Bp :: Bs :: alpha :: nil) ((A :: Bs :: nil) ++ (B :: C :: Bp :: Bs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpBsalphamtmp;try rewrite HT2 in HABCBpBsalphamtmp.
	assert(HT := rule_4 (A :: Bs :: nil) (B :: C :: Bp :: Bs :: alpha :: nil) (Bs :: nil) 4 1 2 HABCBpBsalphamtmp HBsmtmp HABsMtmp Hincl); apply HT.
}
try clear HABCBpBsalphaM1. try clear HABCBpBsalphaM2. try clear HABCBpBsalphaM3. try clear HABCBpBsalpham4. try clear HABCBpBsalpham3. try clear HABCBpBsalpham2. try clear HABCBpBsalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpBs requis par la preuve de (?)BBpBs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HBBpBsm2 : rk(B :: Bp :: Bs :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpBsalphamtmp : rk(B :: C :: Bp :: Bs :: alpha :: nil) >= 3) by (solve_hyps_min HBCBpBsalphaeq HBCBpBsalpham3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: Bs :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: Bs :: alpha :: nil) (B :: Bp :: Bs :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Bs :: B :: C :: alpha :: nil) ((B :: Bp :: Bs :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpBsalphamtmp;try rewrite HT2 in HBCBpBsalphamtmp.
	assert(HT := rule_2 (B :: Bp :: Bs :: nil) (B :: C :: alpha :: nil) (B :: nil) 3 1 2 HBCBpBsalphamtmp HBmtmp HBCalphaMtmp Hincl);apply HT.
}
try clear HBCBpBsalphaM1. try clear HBCBpBsalphaM2. try clear HBCBpBsalphaM3. try clear HBCBpBsalpham4. try clear HBCBpBsalpham3. try clear HBCBpBsalpham2. try clear HBCBpBsalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpBsCsalphaOoOp requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: Bp :: Bs ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: Bs ::   de rang : 4 et 4 *)
assert(HBBpBsCsalphaOoOpm2 : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCBpBseq : rk(A :: B :: C :: Bp :: Bs :: nil) = 4) by (apply LABCBpBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpBsMtmp : rk(A :: B :: C :: Bp :: Bs :: nil) <= 4) by (solve_hyps_max HABCBpBseq HABCBpBsM4).
	assert(HABCBpBsCsalphaOoOpmtmp : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpBsCsalphaOoOpeq HABCBpBsCsalphaOoOpm4).
	assert(HBBpBsmtmp : rk(B :: Bp :: Bs :: nil) >= 2) by (solve_hyps_min HBBpBseq HBBpBsm2).
	assert(Hincl : incl (B :: Bp :: Bs :: nil) (list_inter (A :: B :: C :: Bp :: Bs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: B :: C :: Bp :: Bs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: Bs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: B :: C :: Bp :: Bs :: nil) ++ (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpBsCsalphaOoOpmtmp;try rewrite HT2 in HABCBpBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: Bs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (B :: Bp :: Bs :: nil) 4 2 4 HABCBpBsCsalphaOoOpmtmp HBBpBsmtmp HABCBpBsMtmp Hincl); apply HT.
}
try clear HABCBpBsCsalphaOoOpM1. try clear HABCBpBsCsalphaOoOpM2. try clear HABCBpBsCsalphaOoOpM3. try clear HABCBpBsCsalphaOoOpm4. try clear HABCBpBsCsalphaOoOpm3. try clear HABCBpBsCsalphaOoOpm2. try clear HABCBpBsCsalphaOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : Cs ::  de rang :  1 et 1 	 A : As :: Cs ::   de rang : 1 et 2 *)
assert(HBBpBsCsalphaOoOpm3 : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 3).
{
	assert(HAsCsMtmp : rk(As :: Cs :: nil) <= 2) by (solve_hyps_max HAsCseq HAsCsM2).
	assert(HBBpAsBsCsalphaOoOpmtmp : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HBBpAsBsCsalphaOoOpeq HBBpAsBsCsalphaOoOpm4).
	try assert(HCseq : rk(Cs :: nil) = 1) by (apply LCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCsmtmp : rk(Cs :: nil) >= 1) by (solve_hyps_min HCseq HCsm1).
	assert(Hincl : incl (Cs :: nil) (list_inter (As :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (As :: Cs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: Cs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((As :: Cs :: nil) ++ (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HBBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (As :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (Cs :: nil) 4 1 2 HBBpAsBsCsalphaOoOpmtmp HCsmtmp HAsCsMtmp Hincl); apply HT.
}
try clear HBBpAsBsCsalphaOoOpM1. try clear HBBpAsBsCsalphaOoOpM2. try clear HBBpAsBsCsalphaOoOpM3. try clear HBBpAsBsCsalphaOoOpm4. try clear HBBpAsBsCsalphaOoOpm3. try clear HBBpAsBsCsalphaOoOpm2. try clear HBBpAsBsCsalphaOoOpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpBsCsalphaOoOpm4 : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HBBpBsCseq : rk(B :: Bp :: Bs :: Cs :: nil) = 4) by (apply LBBpBsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpBsCsmtmp : rk(B :: Bp :: Bs :: Cs :: nil) >= 4) by (solve_hyps_min HBBpBsCseq HBBpBsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Bs :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Bs :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HBBpBsCsmtmp Hcomp Hincl);apply HT.
}
try clear HBBpBsCsM1. try clear HBBpBsCsM2. try clear HBBpBsCsM3. try clear HBBpBsCsm4. try clear HBBpBsCsm3. try clear HBBpBsCsm2. try clear HBBpBsCsm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpBsOoOp requis par la preuve de (?)BBpBsOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpBsOoOp requis par la preuve de (?)BBpBsOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBsOoOp requis par la preuve de (?)ABCBpBsOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsOoOpm4 : rk(A :: B :: C :: Bp :: Bs :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpBsOoOp requis par la preuve de (?)BBpBsOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: Bs :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: Bp :: Bs ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: Bs ::   de rang : 4 et 4 *)
assert(HBBpBsOoOpm2 : rk(B :: Bp :: Bs :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCBpBseq : rk(A :: B :: C :: Bp :: Bs :: nil) = 4) by (apply LABCBpBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpBsMtmp : rk(A :: B :: C :: Bp :: Bs :: nil) <= 4) by (solve_hyps_max HABCBpBseq HABCBpBsM4).
	assert(HABCBpBsOoOpmtmp : rk(A :: B :: C :: Bp :: Bs :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpBsOoOpeq HABCBpBsOoOpm4).
	assert(HBBpBsmtmp : rk(B :: Bp :: Bs :: nil) >= 2) by (solve_hyps_min HBBpBseq HBBpBsm2).
	assert(Hincl : incl (B :: Bp :: Bs :: nil) (list_inter (A :: B :: C :: Bp :: Bs :: nil) (B :: Bp :: Bs :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: Bs :: Oo :: Op :: nil) (A :: B :: C :: Bp :: Bs :: B :: Bp :: Bs :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: Bs :: B :: Bp :: Bs :: Oo :: Op :: nil) ((A :: B :: C :: Bp :: Bs :: nil) ++ (B :: Bp :: Bs :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpBsOoOpmtmp;try rewrite HT2 in HABCBpBsOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: Bs :: nil) (B :: Bp :: Bs :: Oo :: Op :: nil) (B :: Bp :: Bs :: nil) 4 2 4 HABCBpBsOoOpmtmp HBBpBsmtmp HABCBpBsMtmp Hincl); apply HT.
}
try clear HABCBpBsOoOpM1. try clear HABCBpBsOoOpM2. try clear HABCBpBsOoOpM3. try clear HABCBpBsOoOpm4. try clear HABCBpBsOoOpm3. try clear HABCBpBsOoOpm2. try clear HABCBpBsOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : Bs :: Cs :: alpha ::   de rang : 2 et 2 *)
assert(HBBpBsOoOpm3 : rk(B :: Bp :: Bs :: Oo :: Op :: nil) >= 3).
{
	try assert(HBsCsalphaeq : rk(Bs :: Cs :: alpha :: nil) = 2) by (apply LBsCsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsCsalphaMtmp : rk(Bs :: Cs :: alpha :: nil) <= 2) by (solve_hyps_max HBsCsalphaeq HBsCsalphaM2).
	assert(HBBpBsCsalphaOoOpmtmp : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HBBpBsCsalphaOoOpeq HBBpBsCsalphaOoOpm4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (Bs :: Cs :: alpha :: nil) (B :: Bp :: Bs :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (Bs :: Cs :: alpha :: B :: Bp :: Bs :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bs :: Cs :: alpha :: B :: Bp :: Bs :: Oo :: Op :: nil) ((Bs :: Cs :: alpha :: nil) ++ (B :: Bp :: Bs :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpBsCsalphaOoOpmtmp;try rewrite HT2 in HBBpBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (Bs :: Cs :: alpha :: nil) (B :: Bp :: Bs :: Oo :: Op :: nil) (Bs :: nil) 4 1 2 HBBpBsCsalphaOoOpmtmp HBsmtmp HBsCsalphaMtmp Hincl); apply HT.
}
try clear HBsCsalphaM1. try clear HBsCsalphaM2. try clear HBsCsalphaM3. try clear HBsCsalpham4. try clear HBsCsalpham3. try clear HBsCsalpham2. try clear HBsCsalpham1. try clear HBBpBsCsalphaOoOpM1. try clear HBBpBsCsalphaOoOpM2. try clear HBBpBsCsalphaOoOpM3. try clear HBBpBsCsalphaOoOpm4. try clear HBBpBsCsalphaOoOpm3. try clear HBBpBsCsalphaOoOpm2. try clear HBBpBsCsalphaOoOpm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBBpBsOoOpM3 : rk(B :: Bp :: Bs :: Oo :: Op :: nil) <= 3).
{
	try assert(HBpBsOoeq : rk(Bp :: Bs :: Oo :: nil) = 2) by (apply LBpBsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBpBsOoMtmp : rk(Bp :: Bs :: Oo :: nil) <= 2) by (solve_hyps_max HBpBsOoeq HBpBsOoM2).
	try assert(HBBsOpeq : rk(B :: Bs :: Op :: nil) = 2) by (apply LBBsOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBsOpMtmp : rk(B :: Bs :: Op :: nil) <= 2) by (solve_hyps_max HBBsOpeq HBBsOpM2).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (Bp :: Bs :: Oo :: nil) (B :: Bs :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Bs :: Oo :: Op :: nil) (Bp :: Bs :: Oo :: B :: Bs :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Bs :: Oo :: B :: Bs :: Op :: nil) ((Bp :: Bs :: Oo :: nil) ++ (B :: Bs :: Op :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: Bs :: Oo :: nil) (B :: Bs :: Op :: nil) (Bs :: nil) 2 2 1 HBpBsOoMtmp HBBsOpMtmp HBsmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HBBpBsOoOpM : rk(B :: Bp :: Bs :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpBsOoOpm : rk(B :: Bp :: Bs :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HBBpBsOoOpeq HBBpBsOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: Oo :: Op ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpOoOp requis par la preuve de (?)BBpOoOp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpOoOp requis par la preuve de (?)BBpOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpalphaOoOp requis par la preuve de (?)BBpOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpalphaOoOp requis par la preuve de (?)BCBpalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOoOp requis par la preuve de (?)ABCBpalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOoOpm4 : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpalphaOoOp requis par la preuve de (?)BCBpalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalphaOoOp requis par la preuve de (?)BCBpalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalphaOoOp requis par la preuve de (?)ABCApBpalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalphaOoOpm4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpalphaOoOp requis par la preuve de (?)BCBpalphaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpalphaOoOpm2 : rk(B :: C :: Bp :: alpha :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpalphaOoOpmtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCApBpalphaOoOpeq HABCApBpalphaOoOpm4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: alpha :: Oo :: Op :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphaOoOpmtmp;try rewrite HT2 in HABCApBpalphaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: alpha :: Oo :: Op :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpalphaOoOpmtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpalphaOoOpM1. try clear HABCApBpalphaOoOpM2. try clear HABCApBpalphaOoOpM3. try clear HABCApBpalphaOoOpm4. try clear HABCApBpalphaOoOpm3. try clear HABCApBpalphaOoOpm2. try clear HABCApBpalphaOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : A :: alpha ::   de rang : 2 et 2 *)
assert(HBCBpalphaOoOpm3 : rk(B :: C :: Bp :: alpha :: Oo :: Op :: nil) >= 3).
{
	try assert(HAalphaeq : rk(A :: alpha :: nil) = 2) by (apply LAalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAalphaMtmp : rk(A :: alpha :: nil) <= 2) by (solve_hyps_max HAalphaeq HAalphaM2).
	assert(HABCBpalphaOoOpmtmp : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpalphaOoOpeq HABCBpalphaOoOpm4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (A :: alpha :: nil) (B :: C :: Bp :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: alpha :: Oo :: Op :: nil) (A :: alpha :: B :: C :: Bp :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: alpha :: B :: C :: Bp :: alpha :: Oo :: Op :: nil) ((A :: alpha :: nil) ++ (B :: C :: Bp :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpalphaOoOpmtmp;try rewrite HT2 in HABCBpalphaOoOpmtmp.
	assert(HT := rule_4 (A :: alpha :: nil) (B :: C :: Bp :: alpha :: Oo :: Op :: nil) (alpha :: nil) 4 1 2 HABCBpalphaOoOpmtmp Halphamtmp HAalphaMtmp Hincl); apply HT.
}
try clear HABCBpalphaOoOpM1. try clear HABCBpalphaOoOpM2. try clear HABCBpalphaOoOpM3. try clear HABCBpalphaOoOpm4. try clear HABCBpalphaOoOpm3. try clear HABCBpalphaOoOpm2. try clear HABCBpalphaOoOpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpOoOp requis par la preuve de (?)BBpOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: alpha :: Oo :: Op ::  de rang :  3 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HBBpOoOpm2 : rk(B :: Bp :: Oo :: Op :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpalphaOoOpmtmp : rk(B :: C :: Bp :: alpha :: Oo :: Op :: nil) >= 3) by (solve_hyps_min HBCBpalphaOoOpeq HBCBpalphaOoOpm3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (B :: Bp :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: alpha :: Oo :: Op :: nil) (B :: C :: alpha :: B :: Bp :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: B :: Bp :: Oo :: Op :: nil) ((B :: C :: alpha :: nil) ++ (B :: Bp :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpalphaOoOpmtmp;try rewrite HT2 in HBCBpalphaOoOpmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (B :: Bp :: Oo :: Op :: nil) (B :: nil) 3 1 2 HBCBpalphaOoOpmtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HBCBpalphaOoOpM1. try clear HBCBpalphaOoOpM2. try clear HBCBpalphaOoOpM3. try clear HBCBpalphaOoOpm4. try clear HBCBpalphaOoOpm3. try clear HBCBpalphaOoOpm2. try clear HBCBpalphaOoOpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpOoOpm3 : rk(B :: Bp :: Oo :: Op :: nil) >= 3).
{
	try assert(HBBpOoeq : rk(B :: Bp :: Oo :: nil) = 3) by (apply LBBpOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpOomtmp : rk(B :: Bp :: Oo :: nil) >= 3) by (solve_hyps_min HBBpOoeq HBBpOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Oo :: nil) (B :: Bp :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Oo :: nil) (B :: Bp :: Oo :: Op :: nil) 3 3 HBBpOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpOoOpM3 : rk(B :: Bp :: Oo :: Op :: nil) <= 3).
{
	try assert(HBBpBsOoOpeq : rk(B :: Bp :: Bs :: Oo :: Op :: nil) = 3) by (apply LBBpBsOoOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpBsOoOpMtmp : rk(B :: Bp :: Bs :: Oo :: Op :: nil) <= 3) by (solve_hyps_max HBBpBsOoOpeq HBBpBsOoOpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Oo :: Op :: nil) (B :: Bp :: Bs :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: Bp :: Oo :: Op :: nil) (B :: Bp :: Bs :: Oo :: Op :: nil) 3 3 HBBpBsOoOpMtmp Hcomp Hincl);apply HT.
}


assert(HBBpOoOpM : rk(B :: Bp :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpOoOpm : rk(B :: Bp :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HBBpOoOpeq HBBpOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApAsOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsOoOp requis par la preuve de (?)ABCApAsOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsOoOpm4 : rk(A :: B :: C :: Ap :: As :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsOoOpM : rk(A :: B :: C :: Ap :: As :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsOoOpm : rk(A :: B :: C :: Ap :: As :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HABCApAsOoOpeq HABCApAsOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpBsOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: Bs :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBsOoOp requis par la preuve de (?)ABCBpBsOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsOoOpm4 : rk(A :: B :: C :: Bp :: Bs :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpBsOoOpM : rk(A :: B :: C :: Bp :: Bs :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpBsOoOpm : rk(A :: B :: C :: Bp :: Bs :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HABCBpBsOoOpeq HABCBpBsOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApalphaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: alpha :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalphaOoOp requis par la preuve de (?)ABCApalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalphaOoOpm4 : rk(A :: B :: C :: Ap :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApalphaOoOpM : rk(A :: B :: C :: Ap :: alpha :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApalphaOoOpm : rk(A :: B :: C :: Ap :: alpha :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HABCApalphaOoOpeq HABCApalphaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpalphaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: alpha :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOoOp requis par la preuve de (?)ABCBpalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOoOpm4 : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpalphaOoOpM : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpalphaOoOpm : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HABCBpalphaOoOpeq HABCBpalphaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpalphaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalphaOoOp requis par la preuve de (?)ABCApBpalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalphaOoOpm4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpalphaOoOpM : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpalphaOoOpm : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HABCApBpalphaOoOpeq HABCApBpalphaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpBsCsalphaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpBsCsalphaOoOp requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOoOp requis par la preuve de (?)ABCBpAsBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOoOpm4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOoOp requis par la preuve de (?)ABCApBpAsBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOoOpm4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsBsCsalphaOoOpm2 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsCsalphaOoOpeq HABCApBpAsBsCsalphaOoOpm4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCApBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsBsCsalphaOoOpmtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsBsCsalphaOoOpM1. try clear HABCApBpAsBsCsalphaOoOpM2. try clear HABCApBpAsBsCsalphaOoOpM3. try clear HABCApBpAsBsCsalphaOoOpm4. try clear HABCApBpAsBsCsalphaOoOpm3. try clear HABCApBpAsBsCsalphaOoOpm2. try clear HABCApBpAsBsCsalphaOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsBsCsalphaOoOpm3 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoOpeq HABCBpAsBsCsalphaOoOpm4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (As :: nil) 4 1 2 HABCBpAsBsCsalphaOoOpmtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsBsCsalphaOoOpm4 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}
try clear HBCBpAsM1. try clear HBCBpAsM2. try clear HBCBpAsM3. try clear HBCBpAsm4. try clear HBCBpAsm3. try clear HBCBpAsm2. try clear HBCBpAsm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBs requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpAs requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsalpham2 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpAsalphaeq : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) = 4) by (apply LABCApBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpAsalphaeq HABCApBpAsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsalphamtmp;try rewrite HT2 in HABCApBpAsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsalphamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsalpham3 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	try assert(HABCBpAsalphaeq : rk(A :: B :: C :: Bp :: As :: alpha :: nil) = 4) by (apply LABCBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsalphamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: nil) (A :: As :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: alpha :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphamtmp;try rewrite HT2 in HABCBpAsalphamtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil) (As :: nil) 4 1 2 HABCBpAsalphamtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpAs requis par la preuve de (?)BBpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HBBpAsm2 : rk(B :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpAsalphamtmp : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3) by (solve_hyps_min HBCBpAsalphaeq HBCBpAsalpham3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: alpha :: nil) (B :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: As :: B :: C :: alpha :: nil) ((B :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsalphamtmp;try rewrite HT2 in HBCBpAsalphamtmp.
	assert(HT := rule_2 (B :: Bp :: As :: nil) (B :: C :: alpha :: nil) (B :: nil) 3 1 2 HBCBpAsalphamtmp HBmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HBBpAsBsCsalphaOoOpm2 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoOpeq HABCBpAsBsCsalphaOoOpm4).
	assert(HBBpAsmtmp : rk(B :: Bp :: As :: nil) >= 2) by (solve_hyps_min HBBpAseq HBBpAsm2).
	assert(Hincl : incl (B :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: B :: C :: Bp :: As :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (B :: Bp :: As :: nil) 4 2 4 HABCBpAsBsCsalphaOoOpmtmp HBBpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}
try clear HABCBpAsBsCsalphaOoOpM1. try clear HABCBpAsBsCsalphaOoOpM2. try clear HABCBpAsBsCsalphaOoOpM3. try clear HABCBpAsBsCsalphaOoOpm4. try clear HABCBpAsBsCsalphaOoOpm3. try clear HABCBpAsBsCsalphaOoOpm2. try clear HABCBpAsBsCsalphaOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : C :: Bs ::   de rang : 1 et 2 *)
assert(HBBpAsBsCsalphaOoOpm3 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 3).
{
	assert(HCBsMtmp : rk(C :: Bs :: nil) <= 2) by (solve_hyps_max HCBseq HCBsM2).
	assert(HBCBpAsBsCsalphaOoOpmtmp : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HBCBpAsBsCsalphaOoOpeq HBCBpAsBsCsalphaOoOpm4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (C :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (C :: Bs :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bs :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((C :: Bs :: nil) ++ (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HBCBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (C :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (Bs :: nil) 4 1 2 HBCBpAsBsCsalphaOoOpmtmp HBsmtmp HCBsMtmp Hincl); apply HT.
}
try clear HBCBpAsBsCsalphaOoOpM1. try clear HBCBpAsBsCsalphaOoOpM2. try clear HBCBpAsBsCsalphaOoOpM3. try clear HBCBpAsBsCsalphaOoOpm4. try clear HBCBpAsBsCsalphaOoOpm3. try clear HBCBpAsBsCsalphaOoOpm2. try clear HBCBpAsBsCsalphaOoOpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpAsBsCsalphaOoOpm4 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HBBpAsBseq : rk(B :: Bp :: As :: Bs :: nil) = 4) by (apply LBBpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpAsBsmtmp : rk(B :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HBBpAsBseq HBBpAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: As :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: As :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HBBpAsBsmtmp Hcomp Hincl);apply HT.
}
try clear HBBpAsBsM1. try clear HBBpAsBsM2. try clear HBBpAsBsM3. try clear HBBpAsBsm4. try clear HBBpAsBsm3. try clear HBBpAsBsm2. try clear HBBpAsBsm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AsCs requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpBsCsalphaOoOp requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpBsCsalphaOoOp requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBsCsalphaOoOp requis par la preuve de (?)ABCBpBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsCsalphaOoOpm4 : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpBs requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpBsalpha requis par la preuve de (?)BBpBs pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABs requis par la preuve de (?)BCBpBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpBsalpha requis par la preuve de (?)BCBpBsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpBsalpha requis par la preuve de (?)BCBpBsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Bs :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpBsalpham2 : rk(B :: C :: Bp :: Bs :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpBsalphaeq : rk(A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) = 4) by (apply LABCApBpBsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpBsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpBsalphaeq HABCApBpBsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: Bs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Bs :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: Bs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: Bs :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: Bs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpBsalphamtmp;try rewrite HT2 in HABCApBpBsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: Bs :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpBsalphamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpBsalphaM1. try clear HABCApBpBsalphaM2. try clear HABCApBpBsalphaM3. try clear HABCApBpBsalpham4. try clear HABCApBpBsalpham3. try clear HABCApBpBsalpham2. try clear HABCApBpBsalpham1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: Bs :: alpha ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : A :: Bs ::   de rang : 1 et 2 *)
assert(HBCBpBsalpham3 : rk(B :: C :: Bp :: Bs :: alpha :: nil) >= 3).
{
	assert(HABsMtmp : rk(A :: Bs :: nil) <= 2) by (solve_hyps_max HABseq HABsM2).
	try assert(HABCBpBsalphaeq : rk(A :: B :: C :: Bp :: Bs :: alpha :: nil) = 4) by (apply LABCBpBsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpBsalphamtmp : rk(A :: B :: C :: Bp :: Bs :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpBsalphaeq HABCBpBsalpham4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (A :: Bs :: nil) (B :: C :: Bp :: Bs :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: Bs :: alpha :: nil) (A :: Bs :: B :: C :: Bp :: Bs :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bs :: B :: C :: Bp :: Bs :: alpha :: nil) ((A :: Bs :: nil) ++ (B :: C :: Bp :: Bs :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpBsalphamtmp;try rewrite HT2 in HABCBpBsalphamtmp.
	assert(HT := rule_4 (A :: Bs :: nil) (B :: C :: Bp :: Bs :: alpha :: nil) (Bs :: nil) 4 1 2 HABCBpBsalphamtmp HBsmtmp HABsMtmp Hincl); apply HT.
}
try clear HABCBpBsalphaM1. try clear HABCBpBsalphaM2. try clear HABCBpBsalphaM3. try clear HABCBpBsalpham4. try clear HABCBpBsalpham3. try clear HABCBpBsalpham2. try clear HABCBpBsalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpBs requis par la preuve de (?)BBpBs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HBBpBsm2 : rk(B :: Bp :: Bs :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpBsalphamtmp : rk(B :: C :: Bp :: Bs :: alpha :: nil) >= 3) by (solve_hyps_min HBCBpBsalphaeq HBCBpBsalpham3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: Bs :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: Bs :: alpha :: nil) (B :: Bp :: Bs :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Bs :: B :: C :: alpha :: nil) ((B :: Bp :: Bs :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpBsalphamtmp;try rewrite HT2 in HBCBpBsalphamtmp.
	assert(HT := rule_2 (B :: Bp :: Bs :: nil) (B :: C :: alpha :: nil) (B :: nil) 3 1 2 HBCBpBsalphamtmp HBmtmp HBCalphaMtmp Hincl);apply HT.
}
try clear HBCBpBsalphaM1. try clear HBCBpBsalphaM2. try clear HBCBpBsalphaM3. try clear HBCBpBsalpham4. try clear HBCBpBsalpham3. try clear HBCBpBsalpham2. try clear HBCBpBsalpham1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpBsCsalphaOoOp requis par la preuve de (?)BBpBsCsalphaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: Bp :: Bs ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: Bs ::   de rang : 4 et 4 *)
assert(HBBpBsCsalphaOoOpm2 : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCBpBseq : rk(A :: B :: C :: Bp :: Bs :: nil) = 4) by (apply LABCBpBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpBsMtmp : rk(A :: B :: C :: Bp :: Bs :: nil) <= 4) by (solve_hyps_max HABCBpBseq HABCBpBsM4).
	assert(HABCBpBsCsalphaOoOpmtmp : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpBsCsalphaOoOpeq HABCBpBsCsalphaOoOpm4).
	assert(HBBpBsmtmp : rk(B :: Bp :: Bs :: nil) >= 2) by (solve_hyps_min HBBpBseq HBBpBsm2).
	assert(Hincl : incl (B :: Bp :: Bs :: nil) (list_inter (A :: B :: C :: Bp :: Bs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: B :: C :: Bp :: Bs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: Bs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: B :: C :: Bp :: Bs :: nil) ++ (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpBsCsalphaOoOpmtmp;try rewrite HT2 in HABCBpBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: Bs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (B :: Bp :: Bs :: nil) 4 2 4 HABCBpBsCsalphaOoOpmtmp HBBpBsmtmp HABCBpBsMtmp Hincl); apply HT.
}
try clear HABCBpBsCsalphaOoOpM1. try clear HABCBpBsCsalphaOoOpM2. try clear HABCBpBsCsalphaOoOpM3. try clear HABCBpBsCsalphaOoOpm4. try clear HABCBpBsCsalphaOoOpm3. try clear HABCBpBsCsalphaOoOpm2. try clear HABCBpBsCsalphaOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : Cs ::  de rang :  1 et 1 	 A : As :: Cs ::   de rang : 1 et 2 *)
assert(HBBpBsCsalphaOoOpm3 : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 3).
{
	assert(HAsCsMtmp : rk(As :: Cs :: nil) <= 2) by (solve_hyps_max HAsCseq HAsCsM2).
	assert(HBBpAsBsCsalphaOoOpmtmp : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HBBpAsBsCsalphaOoOpeq HBBpAsBsCsalphaOoOpm4).
	try assert(HCseq : rk(Cs :: nil) = 1) by (apply LCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCsmtmp : rk(Cs :: nil) >= 1) by (solve_hyps_min HCseq HCsm1).
	assert(Hincl : incl (Cs :: nil) (list_inter (As :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (As :: Cs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (As :: Cs :: B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((As :: Cs :: nil) ++ (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HBBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (As :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (Cs :: nil) 4 1 2 HBBpAsBsCsalphaOoOpmtmp HCsmtmp HAsCsMtmp Hincl); apply HT.
}
try clear HBBpAsBsCsalphaOoOpM1. try clear HBBpAsBsCsalphaOoOpM2. try clear HBBpAsBsCsalphaOoOpM3. try clear HBBpAsBsCsalphaOoOpm4. try clear HBBpAsBsCsalphaOoOpm3. try clear HBBpAsBsCsalphaOoOpm2. try clear HBBpAsBsCsalphaOoOpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpBsCsalphaOoOpm4 : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HBBpBsCseq : rk(B :: Bp :: Bs :: Cs :: nil) = 4) by (apply LBBpBsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpBsCsmtmp : rk(B :: Bp :: Bs :: Cs :: nil) >= 4) by (solve_hyps_min HBBpBsCseq HBBpBsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Bs :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Bs :: Cs :: nil) (B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HBBpBsCsmtmp Hcomp Hincl);apply HT.
}
try clear HBBpBsCsM1. try clear HBBpBsCsM2. try clear HBBpBsCsM3. try clear HBBpBsCsm4. try clear HBBpBsCsm3. try clear HBBpBsCsm2. try clear HBBpBsCsm1. 

assert(HBBpBsCsalphaOoOpM : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpBsCsalphaOoOpm : rk(B :: Bp :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HBBpBsCsalphaOoOpeq HBBpBsCsalphaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpBsCsalphaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpBsCsalphaOoOp requis par la preuve de (?)ABCBpBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpBsCsalphaOoOpm4 : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpBsCsalphaOoOpM : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpBsCsalphaOoOpm : rk(A :: B :: C :: Bp :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HABCBpBsCsalphaOoOpeq HABCBpBsCsalphaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpAsBsCsalphaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOoOp requis par la preuve de (?)ABCBpAsBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOoOpm4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOoOp requis par la preuve de (?)ABCApBpAsBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOoOpm4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsBsCsalphaOoOpm2 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsCsalphaOoOpeq HABCApBpAsBsCsalphaOoOpm4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCApBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsBsCsalphaOoOpmtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsBsCsalphaOoOpM1. try clear HABCApBpAsBsCsalphaOoOpM2. try clear HABCApBpAsBsCsalphaOoOpM3. try clear HABCApBpAsBsCsalphaOoOpm4. try clear HABCApBpAsBsCsalphaOoOpm3. try clear HABCApBpAsBsCsalphaOoOpm2. try clear HABCApBpAsBsCsalphaOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsBsCsalphaOoOpm3 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoOpeq HABCBpAsBsCsalphaOoOpm4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (As :: nil) 4 1 2 HABCBpAsBsCsalphaOoOpmtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsBsCsalphaOoOpm4 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}
try clear HBCBpAsM1. try clear HBCBpAsM2. try clear HBCBpAsM3. try clear HBCBpAsm4. try clear HBCBpAsm3. try clear HBCBpAsm2. try clear HBCBpAsm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBs requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpAs requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BBpAs pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsalpha requis par la preuve de (?)BCBpAsalpha pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsalpham2 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	try assert(HABCApBpAsalphaeq : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) = 4) by (apply LABCApBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpAsalphamtmp : rk(A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpAsalphaeq HABCApBpAsalpham4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: alpha :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: alpha :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsalphamtmp;try rewrite HT2 in HABCApBpAsalphamtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: alpha :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsalphamtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: alpha ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsalpham3 : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	try assert(HABCBpAsalphaeq : rk(A :: B :: C :: Bp :: As :: alpha :: nil) = 4) by (apply LABCBpAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsalphamtmp : rk(A :: B :: C :: Bp :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCBpAsalphaeq HABCBpAsalpham4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: alpha :: nil) (A :: As :: B :: C :: Bp :: As :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: alpha :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsalphamtmp;try rewrite HT2 in HABCBpAsalphamtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: alpha :: nil) (As :: nil) 4 1 2 HABCBpAsalphamtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpAs requis par la preuve de (?)BBpAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 4*)
assert(HBBpAsm2 : rk(B :: Bp :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpAsalphamtmp : rk(B :: C :: Bp :: As :: alpha :: nil) >= 3) by (solve_hyps_min HBCBpAsalphaeq HBCBpAsalpham3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: alpha :: nil) (B :: Bp :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: As :: B :: C :: alpha :: nil) ((B :: Bp :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsalphamtmp;try rewrite HT2 in HBCBpAsalphamtmp.
	assert(HT := rule_2 (B :: Bp :: As :: nil) (B :: C :: alpha :: nil) (B :: nil) 3 1 2 HBCBpAsalphamtmp HBmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpAsBsCsalphaOoOp requis par la preuve de (?)BBpAsBsCsalphaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: Bp :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Bp :: As ::   de rang : 4 et 4 *)
assert(HBBpAsBsCsalphaOoOpm2 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCBpAseq : rk(A :: B :: C :: Bp :: As :: nil) = 4) by (apply LABCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpAsMtmp : rk(A :: B :: C :: Bp :: As :: nil) <= 4) by (solve_hyps_max HABCBpAseq HABCBpAsM4).
	assert(HABCBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoOpeq HABCBpAsBsCsalphaOoOpm4).
	assert(HBBpAsmtmp : rk(B :: Bp :: As :: nil) >= 2) by (solve_hyps_min HBBpAseq HBBpAsm2).
	assert(Hincl : incl (B :: Bp :: As :: nil) (list_inter (A :: B :: C :: Bp :: As :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: B :: C :: Bp :: As :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Bp :: As :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: B :: C :: Bp :: As :: nil) ++ (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Bp :: As :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (B :: Bp :: As :: nil) 4 2 4 HABCBpAsBsCsalphaOoOpmtmp HBBpAsmtmp HABCBpAsMtmp Hincl); apply HT.
}
try clear HABCBpAsBsCsalphaOoOpM1. try clear HABCBpAsBsCsalphaOoOpM2. try clear HABCBpAsBsCsalphaOoOpM3. try clear HABCBpAsBsCsalphaOoOpm4. try clear HABCBpAsBsCsalphaOoOpm3. try clear HABCBpAsBsCsalphaOoOpm2. try clear HABCBpAsBsCsalphaOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : Bs ::  de rang :  1 et 1 	 A : C :: Bs ::   de rang : 1 et 2 *)
assert(HBBpAsBsCsalphaOoOpm3 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 3).
{
	assert(HCBsMtmp : rk(C :: Bs :: nil) <= 2) by (solve_hyps_max HCBseq HCBsM2).
	assert(HBCBpAsBsCsalphaOoOpmtmp : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HBCBpAsBsCsalphaOoOpeq HBCBpAsBsCsalphaOoOpm4).
	try assert(HBseq : rk(Bs :: nil) = 1) by (apply LBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBsmtmp : rk(Bs :: nil) >= 1) by (solve_hyps_min HBseq HBsm1).
	assert(Hincl : incl (Bs :: nil) (list_inter (C :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (C :: Bs :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bs :: B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((C :: Bs :: nil) ++ (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HBCBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (C :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (Bs :: nil) 4 1 2 HBCBpAsBsCsalphaOoOpmtmp HBsmtmp HCBsMtmp Hincl); apply HT.
}
try clear HBCBpAsBsCsalphaOoOpM1. try clear HBCBpAsBsCsalphaOoOpM2. try clear HBCBpAsBsCsalphaOoOpM3. try clear HBCBpAsBsCsalphaOoOpm4. try clear HBCBpAsBsCsalphaOoOpm3. try clear HBCBpAsBsCsalphaOoOpm2. try clear HBCBpAsBsCsalphaOoOpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpAsBsCsalphaOoOpm4 : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HBBpAsBseq : rk(B :: Bp :: As :: Bs :: nil) = 4) by (apply LBBpAsBs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpAsBsmtmp : rk(B :: Bp :: As :: Bs :: nil) >= 4) by (solve_hyps_min HBBpAsBseq HBBpAsBsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: As :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: As :: Bs :: nil) (B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HBBpAsBsmtmp Hcomp Hincl);apply HT.
}
try clear HBBpAsBsM1. try clear HBBpAsBsM2. try clear HBBpAsBsM3. try clear HBBpAsBsm4. try clear HBBpAsBsm3. try clear HBBpAsBsm2. try clear HBBpAsBsm1. 

assert(HBBpAsBsCsalphaOoOpM : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpAsBsCsalphaOoOpm : rk(B :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HBBpAsBsCsalphaOoOpeq HBBpAsBsCsalphaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpAsBsCsalphaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOoOp requis par la preuve de (?)ABCBpAsBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOoOpm4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAs requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOoOp requis par la preuve de (?)ABCApBpAsBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOoOpm4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpAsBsCsalphaOoOp requis par la preuve de (?)BCBpAsBsCsalphaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpAsBsCsalphaOoOpm2 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCApBpAsBsCsalphaOoOpeq HABCApBpAsBsCsalphaOoOpm4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCApBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpAsBsCsalphaOoOpmtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpAsBsCsalphaOoOpM1. try clear HABCApBpAsBsCsalphaOoOpM2. try clear HABCApBpAsBsCsalphaOoOpM3. try clear HABCApBpAsBsCsalphaOoOpm4. try clear HABCApBpAsBsCsalphaOoOpm3. try clear HABCApBpAsBsCsalphaOoOpm2. try clear HABCApBpAsBsCsalphaOoOpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  de rang :  4 et 4 	 AiB : As ::  de rang :  1 et 1 	 A : A :: As ::   de rang : 1 et 2 *)
assert(HBCBpAsBsCsalphaOoOpm3 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 3).
{
	assert(HAAsMtmp : rk(A :: As :: nil) <= 2) by (solve_hyps_max HAAseq HAAsM2).
	assert(HABCBpAsBsCsalphaOoOpmtmp : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCBpAsBsCsalphaOoOpeq HABCBpAsBsCsalphaOoOpm4).
	try assert(HAseq : rk(As :: nil) = 1) by (apply LAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAsmtmp : rk(As :: nil) >= 1) by (solve_hyps_min HAseq HAsm1).
	assert(Hincl : incl (As :: nil) (list_inter (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) ((A :: As :: nil) ++ (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpAsBsCsalphaOoOpmtmp;try rewrite HT2 in HABCBpAsBsCsalphaOoOpmtmp.
	assert(HT := rule_4 (A :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) (As :: nil) 4 1 2 HABCBpAsBsCsalphaOoOpmtmp HAsmtmp HAAsMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCBpAsBsCsalphaOoOpm4 : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HBCBpAseq : rk(B :: C :: Bp :: As :: nil) = 4) by (apply LBCBpAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCBpAsmtmp : rk(B :: C :: Bp :: As :: nil) >= 4) by (solve_hyps_min HBCBpAseq HBCBpAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: Bp :: As :: nil) (B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HBCBpAsmtmp Hcomp Hincl);apply HT.
}
try clear HBCBpAsM1. try clear HBCBpAsM2. try clear HBCBpAsM3. try clear HBCBpAsm4. try clear HBCBpAsm3. try clear HBCBpAsm2. try clear HBCBpAsm1. 

assert(HBCBpAsBsCsalphaOoOpM : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpAsBsCsalphaOoOpm : rk(B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HBCBpAsBsCsalphaOoOpeq HBCBpAsBsCsalphaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpAsBsCsalphaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpAsBsCsalphaOoOp requis par la preuve de (?)ABCBpAsBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpAsBsCsalphaOoOpm4 : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpAsBsCsalphaOoOpM : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpAsBsCsalphaOoOpm : rk(A :: B :: C :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HABCBpAsBsCsalphaOoOpeq HABCBpAsBsCsalphaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpAsBsCsalphaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpAsBsCsalphaOoOp requis par la preuve de (?)ABCApBpAsBsCsalphaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpAsBsCsalphaOoOpm4 : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpAsBsCsalphaOoOpM : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpAsBsCsalphaOoOpm : rk(A :: B :: C :: Ap :: Bp :: As :: Bs :: Cs :: alpha :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HABCApBpAsBsCsalphaOoOpeq HABCApBpAsBsCsalphaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApAsCsbetaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: As :: Cs :: beta :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApAsCsbetaOoOp requis par la preuve de (?)AApAsCsbetaOoOp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApAsCsbetaOoOp requis par la preuve de (?)AApAsCsbetaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsCsbetaOoOp requis par la preuve de (?)ABCApAsCsbetaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsCsbetaOoOpm4 : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAsCsbetaOoOp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApAs requis par la preuve de (?)AApAs pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -1 et 4*)
assert(HAApAsm2 : rk(A :: Ap :: As :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCApAsalphaeq : rk(A :: B :: C :: Ap :: As :: alpha :: nil) = 4) by (apply LABCApAsalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsalphamtmp : rk(A :: B :: C :: Ap :: As :: alpha :: nil) >= 4) by (solve_hyps_min HABCApAsalphaeq HABCApAsalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: As :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: alpha :: nil) (A :: Ap :: As :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: As :: B :: C :: alpha :: nil) ((A :: Ap :: As :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsalphamtmp;try rewrite HT2 in HABCApAsalphamtmp.
	assert(HT := rule_2 (A :: Ap :: As :: nil) (B :: C :: alpha :: nil) (nil) 4 0 2 HABCApAsalphamtmp Hmtmp HBCalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApAsCsbetaOoOp requis par la preuve de (?)AApAsCsbetaOoOp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op ::  de rang :  4 et 4 	 AiB : A :: Ap :: As ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: As ::   de rang : 4 et 4 *)
assert(HAApAsCsbetaOoOpm2 : rk(A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) >= 2).
{
	try assert(HABCApAseq : rk(A :: B :: C :: Ap :: As :: nil) = 4) by (apply LABCApAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApAsMtmp : rk(A :: B :: C :: Ap :: As :: nil) <= 4) by (solve_hyps_max HABCApAseq HABCApAsM4).
	assert(HABCApAsCsbetaOoOpmtmp : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) >= 4) by (solve_hyps_min HABCApAsCsbetaOoOpeq HABCApAsCsbetaOoOpm4).
	assert(HAApAsmtmp : rk(A :: Ap :: As :: nil) >= 2) by (solve_hyps_min HAApAseq HAApAsm2).
	assert(Hincl : incl (A :: Ap :: As :: nil) (list_inter (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: As :: A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) ((A :: B :: C :: Ap :: As :: nil) ++ (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApAsCsbetaOoOpmtmp;try rewrite HT2 in HABCApAsCsbetaOoOpmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: As :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) (A :: Ap :: As :: nil) 4 2 4 HABCApAsCsbetaOoOpmtmp HAApAsmtmp HABCApAsMtmp Hincl); apply HT.
}
try clear HABCApAsCsbetaOoOpM1. try clear HABCApAsCsbetaOoOpM2. try clear HABCApAsCsbetaOoOpM3. try clear HABCApAsCsbetaOoOpm4. try clear HABCApAsCsbetaOoOpm3. try clear HABCApAsCsbetaOoOpm2. try clear HABCApAsCsbetaOoOpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApAsCsbetaOoOpm4 : rk(A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) >= 4).
{
	try assert(HAApAsCseq : rk(A :: Ap :: As :: Cs :: nil) = 4) by (apply LAApAsCs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApAsCsmtmp : rk(A :: Ap :: As :: Cs :: nil) >= 4) by (solve_hyps_min HAApAsCseq HAApAsCsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: As :: Cs :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: As :: Cs :: nil) (A :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) 4 4 HAApAsCsmtmp Hcomp Hincl);apply HT.
}
try clear HAApAsCsM1. try clear HAApAsCsM2. try clear HAApAsCsM3. try clear HAApAsCsm4. try clear HAApAsCsm3. try clear HAApAsCsm2. try clear HAApAsCsm1. 

assert(HAApAsCsbetaOoOpM : rk(A :: Ap :: As :: Cs :: beta :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApAsCsbetaOoOpm : rk(A :: Ap :: As :: Cs :: beta :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HAApAsCsbetaOoOpeq HAApAsCsbetaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApAsCsbetaOoOp : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApAsCsbetaOoOp requis par la preuve de (?)ABCApAsCsbetaOoOp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApAsCsbetaOoOpm4 : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApAsCsbetaOoOpM : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApAsCsbetaOoOpm : rk(A :: B :: C :: Ap :: As :: Cs :: beta :: Oo :: Op ::  nil) >= 1) by (solve_hyps_min HABCApAsCsbetaOoOpeq HABCApAsCsbetaOoOpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Os ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HAApOsM : rk(A :: Ap :: Os ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAApOseq HAApOsM3).
assert(HAApOsm : rk(A :: Ap :: Os ::  nil) >= 1) by (solve_hyps_min HAApOseq HAApOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

assert(HBBpOsM : rk(B :: Bp :: Os ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBBpOseq HBBpOsM3).
assert(HBBpOsm : rk(B :: Bp :: Os ::  nil) >= 1) by (solve_hyps_min HBBpOseq HBBpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApOoOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Oo :: Os ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApOoOs requis par la preuve de (?)AApOoOs pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApOoOs requis par la preuve de (?)AApOoOs pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApalphaOoOs requis par la preuve de (?)AApOoOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalphaOoOs requis par la preuve de (?)ABCApalphaOoOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalphaOoOsm4 : rk(A :: B :: C :: Ap :: alpha :: Oo :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApOoOs requis par la preuve de (?)AApOoOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: alpha :: Oo :: Os ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HAApOoOsm2 : rk(A :: Ap :: Oo :: Os :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCApalphaOoOsmtmp : rk(A :: B :: C :: Ap :: alpha :: Oo :: Os :: nil) >= 4) by (solve_hyps_min HABCApalphaOoOseq HABCApalphaOoOsm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C :: alpha :: nil) (A :: Ap :: Oo :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: alpha :: Oo :: Os :: nil) (B :: C :: alpha :: A :: Ap :: Oo :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: Ap :: Oo :: Os :: nil) ((B :: C :: alpha :: nil) ++ (A :: Ap :: Oo :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApalphaOoOsmtmp;try rewrite HT2 in HABCApalphaOoOsmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: Ap :: Oo :: Os :: nil) (nil) 4 0 2 HABCApalphaOoOsmtmp Hmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCApalphaOoOsM1. try clear HABCApalphaOoOsM2. try clear HABCApalphaOoOsM3. try clear HABCApalphaOoOsm4. try clear HABCApalphaOoOsm3. try clear HABCApalphaOoOsm2. try clear HABCApalphaOoOsm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAApOoOsM3 : rk(A :: Ap :: Oo :: Os :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	try assert(HAApOseq : rk(A :: Ap :: Os :: nil) = 2) by (apply LAApOs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApOsMtmp : rk(A :: Ap :: Os :: nil) <= 2) by (solve_hyps_max HAApOseq HAApOsM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: Ap :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Oo :: Os :: nil) (Oo :: A :: Ap :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Os :: nil) ((Oo :: nil) ++ (A :: Ap :: Os :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: Ap :: Os :: nil) (nil) 1 2 0 HOoMtmp HAApOsMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HAApOsM1. try clear HAApOsM2. try clear HAApOsM3. try clear HAApOsm4. try clear HAApOsm3. try clear HAApOsm2. try clear HAApOsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApOoOsm3 : rk(A :: Ap :: Oo :: Os :: nil) >= 3).
{
	try assert(HAApOoeq : rk(A :: Ap :: Oo :: nil) = 3) by (apply LAApOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApOomtmp : rk(A :: Ap :: Oo :: nil) >= 3) by (solve_hyps_min HAApOoeq HAApOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Oo :: nil) (A :: Ap :: Oo :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Oo :: nil) (A :: Ap :: Oo :: Os :: nil) 3 3 HAApOomtmp Hcomp Hincl);apply HT.
}


assert(HAApOoOsM : rk(A :: Ap :: Oo :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApOoOsm : rk(A :: Ap :: Oo :: Os ::  nil) >= 1) by (solve_hyps_min HAApOoOseq HAApOoOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpOoOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: Oo :: Os ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpOoOs requis par la preuve de (?)BBpOoOs pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpOoOs requis par la preuve de (?)BBpOoOs pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpalphaOoOs requis par la preuve de (?)BBpOoOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpalphaOoOs requis par la preuve de (?)BCBpalphaOoOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOoOs requis par la preuve de (?)ABCBpalphaOoOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOoOsm4 : rk(A :: B :: C :: Bp :: alpha :: Oo :: Os :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Os :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpalphaOoOs requis par la preuve de (?)BCBpalphaOoOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalphaOoOs requis par la preuve de (?)BCBpalphaOoOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalphaOoOs requis par la preuve de (?)ABCApBpalphaOoOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalphaOoOsm4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpalphaOoOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpalphaOoOs requis par la preuve de (?)BCBpalphaOoOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpalphaOoOsm2 : rk(B :: C :: Bp :: alpha :: Oo :: Os :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpalphaOoOsmtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os :: nil) >= 4) by (solve_hyps_min HABCApBpalphaOoOseq HABCApBpalphaOoOsm4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: alpha :: Oo :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: alpha :: Oo :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: alpha :: Oo :: Os :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: alpha :: Oo :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphaOoOsmtmp;try rewrite HT2 in HABCApBpalphaOoOsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: alpha :: Oo :: Os :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpalphaOoOsmtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpalphaOoOsM1. try clear HABCApBpalphaOoOsM2. try clear HABCApBpalphaOoOsM3. try clear HABCApBpalphaOoOsm4. try clear HABCApBpalphaOoOsm3. try clear HABCApBpalphaOoOsm2. try clear HABCApBpalphaOoOsm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: alpha :: Oo :: Os ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : A :: alpha ::   de rang : 2 et 2 *)
assert(HBCBpalphaOoOsm3 : rk(B :: C :: Bp :: alpha :: Oo :: Os :: nil) >= 3).
{
	try assert(HAalphaeq : rk(A :: alpha :: nil) = 2) by (apply LAalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAalphaMtmp : rk(A :: alpha :: nil) <= 2) by (solve_hyps_max HAalphaeq HAalphaM2).
	assert(HABCBpalphaOoOsmtmp : rk(A :: B :: C :: Bp :: alpha :: Oo :: Os :: nil) >= 4) by (solve_hyps_min HABCBpalphaOoOseq HABCBpalphaOoOsm4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (A :: alpha :: nil) (B :: C :: Bp :: alpha :: Oo :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: alpha :: Oo :: Os :: nil) (A :: alpha :: B :: C :: Bp :: alpha :: Oo :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: alpha :: B :: C :: Bp :: alpha :: Oo :: Os :: nil) ((A :: alpha :: nil) ++ (B :: C :: Bp :: alpha :: Oo :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpalphaOoOsmtmp;try rewrite HT2 in HABCBpalphaOoOsmtmp.
	assert(HT := rule_4 (A :: alpha :: nil) (B :: C :: Bp :: alpha :: Oo :: Os :: nil) (alpha :: nil) 4 1 2 HABCBpalphaOoOsmtmp Halphamtmp HAalphaMtmp Hincl); apply HT.
}
try clear HABCBpalphaOoOsM1. try clear HABCBpalphaOoOsM2. try clear HABCBpalphaOoOsM3. try clear HABCBpalphaOoOsm4. try clear HABCBpalphaOoOsm3. try clear HABCBpalphaOoOsm2. try clear HABCBpalphaOoOsm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpOoOs requis par la preuve de (?)BBpOoOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: alpha :: Oo :: Os ::  de rang :  3 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HBBpOoOsm2 : rk(B :: Bp :: Oo :: Os :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpalphaOoOsmtmp : rk(B :: C :: Bp :: alpha :: Oo :: Os :: nil) >= 3) by (solve_hyps_min HBCBpalphaOoOseq HBCBpalphaOoOsm3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (B :: Bp :: Oo :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: alpha :: Oo :: Os :: nil) (B :: C :: alpha :: B :: Bp :: Oo :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: B :: Bp :: Oo :: Os :: nil) ((B :: C :: alpha :: nil) ++ (B :: Bp :: Oo :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpalphaOoOsmtmp;try rewrite HT2 in HBCBpalphaOoOsmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (B :: Bp :: Oo :: Os :: nil) (B :: nil) 3 1 2 HBCBpalphaOoOsmtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HBCBpalphaOoOsM1. try clear HBCBpalphaOoOsM2. try clear HBCBpalphaOoOsM3. try clear HBCBpalphaOoOsm4. try clear HBCBpalphaOoOsm3. try clear HBCBpalphaOoOsm2. try clear HBCBpalphaOoOsm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBBpOoOsM3 : rk(B :: Bp :: Oo :: Os :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	try assert(HBBpOseq : rk(B :: Bp :: Os :: nil) = 2) by (apply LBBpOs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpOsMtmp : rk(B :: Bp :: Os :: nil) <= 2) by (solve_hyps_max HBBpOseq HBBpOsM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (B :: Bp :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Oo :: Os :: nil) (Oo :: B :: Bp :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Os :: nil) ((Oo :: nil) ++ (B :: Bp :: Os :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (B :: Bp :: Os :: nil) (nil) 1 2 0 HOoMtmp HBBpOsMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HBBpOsM1. try clear HBBpOsM2. try clear HBBpOsM3. try clear HBBpOsm4. try clear HBBpOsm3. try clear HBBpOsm2. try clear HBBpOsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpOoOsm3 : rk(B :: Bp :: Oo :: Os :: nil) >= 3).
{
	try assert(HBBpOoeq : rk(B :: Bp :: Oo :: nil) = 3) by (apply LBBpOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpOomtmp : rk(B :: Bp :: Oo :: nil) >= 3) by (solve_hyps_min HBBpOoeq HBBpOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Oo :: nil) (B :: Bp :: Oo :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Oo :: nil) (B :: Bp :: Oo :: Os :: nil) 3 3 HBBpOomtmp Hcomp Hincl);apply HT.
}


assert(HBBpOoOsM : rk(B :: Bp :: Oo :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpOoOsm : rk(B :: Bp :: Oo :: Os ::  nil) >= 1) by (solve_hyps_min HBBpOoOseq HBBpOoOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApalphaOoOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: alpha :: Oo :: Os ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalphaOoOs requis par la preuve de (?)ABCApalphaOoOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalphaOoOsm4 : rk(A :: B :: C :: Ap :: alpha :: Oo :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApalphaOoOsM : rk(A :: B :: C :: Ap :: alpha :: Oo :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApalphaOoOsm : rk(A :: B :: C :: Ap :: alpha :: Oo :: Os ::  nil) >= 1) by (solve_hyps_min HABCApalphaOoOseq HABCApalphaOoOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpalphaOoOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: alpha :: Oo :: Os ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOoOs requis par la preuve de (?)ABCBpalphaOoOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOoOsm4 : rk(A :: B :: C :: Bp :: alpha :: Oo :: Os :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Os :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpalphaOoOsM : rk(A :: B :: C :: Bp :: alpha :: Oo :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpalphaOoOsm : rk(A :: B :: C :: Bp :: alpha :: Oo :: Os ::  nil) >= 1) by (solve_hyps_min HABCBpalphaOoOseq HABCBpalphaOoOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpalphaOoOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalphaOoOs requis par la preuve de (?)ABCApBpalphaOoOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalphaOoOsm4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpalphaOoOsM : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpalphaOoOsm : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Os ::  nil) >= 1) by (solve_hyps_min HABCApBpalphaOoOseq HABCApBpalphaOoOsm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAOoOpOs *)
(* dans la couche 0 *)
Lemma LAApOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Ap :: Oo :: Op :: Os ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApOoOpOs requis par la preuve de (?)AApOoOpOs pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApOoOpOs requis par la preuve de (?)AApOoOpOs pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApalphaOoOpOs requis par la preuve de (?)AApOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalphaOoOpOs requis par la preuve de (?)ABCApalphaOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalphaOoOpOsm4 : rk(A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApOoOpOs requis par la preuve de (?)AApOoOpOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HAApOoOpOsm2 : rk(A :: Ap :: Oo :: Op :: Os :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCApalphaOoOpOsmtmp : rk(A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os :: nil) >= 4) by (solve_hyps_min HABCApalphaOoOpOseq HABCApalphaOoOpOsm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C :: alpha :: nil) (A :: Ap :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os :: nil) (B :: C :: alpha :: A :: Ap :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: Ap :: Oo :: Op :: Os :: nil) ((B :: C :: alpha :: nil) ++ (A :: Ap :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApalphaOoOpOsmtmp;try rewrite HT2 in HABCApalphaOoOpOsmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: Ap :: Oo :: Op :: Os :: nil) (nil) 4 0 2 HABCApalphaOoOpOsmtmp Hmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCApalphaOoOpOsM1. try clear HABCApalphaOoOpOsM2. try clear HABCApalphaOoOpOsM3. try clear HABCApalphaOoOpOsm4. try clear HABCApalphaOoOpOsm3. try clear HABCApalphaOoOpOsm2. try clear HABCApalphaOoOpOsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApOoOpOsm3 : rk(A :: Ap :: Oo :: Op :: Os :: nil) >= 3).
{
	try assert(HAApOoeq : rk(A :: Ap :: Oo :: nil) = 3) by (apply LAApOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApOomtmp : rk(A :: Ap :: Oo :: nil) >= 3) by (solve_hyps_min HAApOoeq HAApOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Oo :: nil) (A :: Ap :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Oo :: nil) (A :: Ap :: Oo :: Op :: Os :: nil) 3 3 HAApOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAApOoOpOsM3 : rk(A :: Ap :: Oo :: Op :: Os :: nil) <= 3).
{
	try assert(HAApOoOpeq : rk(A :: Ap :: Oo :: Op :: nil) = 3) by (apply LAApOoOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApOoOpMtmp : rk(A :: Ap :: Oo :: Op :: nil) <= 3) by (solve_hyps_max HAApOoOpeq HAApOoOpM3).
	try assert(HAApOoOseq : rk(A :: Ap :: Oo :: Os :: nil) = 3) by (apply LAApOoOs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApOoOsMtmp : rk(A :: Ap :: Oo :: Os :: nil) <= 3) by (solve_hyps_max HAApOoOseq HAApOoOsM3).
	try assert(HAApOoeq : rk(A :: Ap :: Oo :: nil) = 3) by (apply LAApOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApOomtmp : rk(A :: Ap :: Oo :: nil) >= 3) by (solve_hyps_min HAApOoeq HAApOom3).
	assert(Hincl : incl (A :: Ap :: Oo :: nil) (list_inter (A :: Ap :: Oo :: Op :: nil) (A :: Ap :: Oo :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Oo :: Op :: Os :: nil) (A :: Ap :: Oo :: Op :: A :: Ap :: Oo :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: Op :: A :: Ap :: Oo :: Os :: nil) ((A :: Ap :: Oo :: Op :: nil) ++ (A :: Ap :: Oo :: Os :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: Ap :: Oo :: Op :: nil) (A :: Ap :: Oo :: Os :: nil) (A :: Ap :: Oo :: nil) 3 3 3 HAApOoOpMtmp HAApOoOsMtmp HAApOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HAApOoOpOsM : rk(A :: Ap :: Oo :: Op :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApOoOpOsm : rk(A :: Ap :: Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HAApOoOpOseq HAApOoOpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: Oo :: Op :: Os ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AOoOpOs requis par la preuve de (?)AOoOpOs pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AAsOoOpOs requis par la preuve de (?)AOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AAsOoOpOs requis par la preuve de (?)AAsOoOpOs pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCAsalphaOoOpOs requis par la preuve de (?)AAsOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAsalphaOoOpOs requis par la preuve de (?)ABCAsalphaOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCAsalphaOoOpOsm4 : rk(A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCAseq : rk(A :: B :: C :: As :: nil) = 4) by (apply LABCAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsmtmp : rk(A :: B :: C :: As :: nil) >= 4) by (solve_hyps_min HABCAseq HABCAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil) 4 4 HABCAsmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AAsOoOpOs requis par la preuve de (?)AAsOoOpOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: As :: alpha :: Oo :: Op :: Os ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HAAsOoOpOsm2 : rk(A :: As :: Oo :: Op :: Os :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCAsalphaOoOpOsmtmp : rk(A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil) >= 4) by (solve_hyps_min HABCAsalphaOoOpOseq HABCAsalphaOoOpOsm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C :: alpha :: nil) (A :: As :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil) (B :: C :: alpha :: A :: As :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: As :: Oo :: Op :: Os :: nil) ((B :: C :: alpha :: nil) ++ (A :: As :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCAsalphaOoOpOsmtmp;try rewrite HT2 in HABCAsalphaOoOpOsmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: As :: Oo :: Op :: Os :: nil) (nil) 4 0 2 HABCAsalphaOoOpOsmtmp Hmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCAsalphaOoOpOsM1. try clear HABCAsalphaOoOpOsM2. try clear HABCAsalphaOoOpOsM3. try clear HABCAsalphaOoOpOsm4. try clear HABCAsalphaOoOpOsm3. try clear HABCAsalphaOoOpOsm2. try clear HABCAsalphaOoOpOsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAAsOoOpOsm3 : rk(A :: As :: Oo :: Op :: Os :: nil) >= 3).
{
	try assert(HAAsOoeq : rk(A :: As :: Oo :: nil) = 3) by (apply LAAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAAsOomtmp : rk(A :: As :: Oo :: nil) >= 3) by (solve_hyps_min HAAsOoeq HAAsOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: As :: Oo :: nil) (A :: As :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: As :: Oo :: nil) (A :: As :: Oo :: Op :: Os :: nil) 3 3 HAAsOomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AOoOpOs requis par la preuve de (?)AOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApOoOpOs requis par la preuve de (?)AOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApOoOpOs requis par la preuve de (?)ABCApOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApOoOpOsm4 : rk(A :: B :: C :: Ap :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Oo :: Op :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AOoOpOs requis par la preuve de (?)AOoOpOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Oo :: Op :: Os ::  de rang :  4 et 4 	 AiB : A :: Oo ::  de rang :  2 et 2 	 A : A :: B :: C :: Ap :: Oo ::   de rang : 4 et 4 *)
assert(HAOoOpOsm2 : rk(A :: Oo :: Op :: Os :: nil) >= 2).
{
	try assert(HABCApOoeq : rk(A :: B :: C :: Ap :: Oo :: nil) = 4) by (apply LABCApOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApOoMtmp : rk(A :: B :: C :: Ap :: Oo :: nil) <= 4) by (solve_hyps_max HABCApOoeq HABCApOoM4).
	assert(HABCApOoOpOsmtmp : rk(A :: B :: C :: Ap :: Oo :: Op :: Os :: nil) >= 4) by (solve_hyps_min HABCApOoOpOseq HABCApOoOpOsm4).
	try assert(HAOoeq : rk(A :: Oo :: nil) = 2) by (apply LAOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAOomtmp : rk(A :: Oo :: nil) >= 2) by (solve_hyps_min HAOoeq HAOom2).
	assert(Hincl : incl (A :: Oo :: nil) (list_inter (A :: B :: C :: Ap :: Oo :: nil) (A :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Oo :: Op :: Os :: nil) (A :: B :: C :: Ap :: Oo :: A :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Oo :: A :: Oo :: Op :: Os :: nil) ((A :: B :: C :: Ap :: Oo :: nil) ++ (A :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApOoOpOsmtmp;try rewrite HT2 in HABCApOoOpOsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Oo :: nil) (A :: Oo :: Op :: Os :: nil) (A :: Oo :: nil) 4 2 4 HABCApOoOpOsmtmp HAOomtmp HABCApOoMtmp Hincl); apply HT.
}
try clear HABCApOoM1. try clear HABCApOoM2. try clear HABCApOoM3. try clear HABCApOom4. try clear HABCApOom3. try clear HABCApOom2. try clear HABCApOom1. try clear HAOoM1. try clear HAOoM2. try clear HAOoM3. try clear HAOom4. try clear HAOom3. try clear HAOom2. try clear HAOom1. try clear HABCApOoOpOsM1. try clear HABCApOoOpOsM2. try clear HABCApOoOpOsM3. try clear HABCApOoOpOsm4. try clear HABCApOoOpOsm3. try clear HABCApOoOpOsm2. try clear HABCApOoOpOsm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: As :: Oo :: Op :: Os ::  de rang :  3 et 4 	 AiB : A :: Op ::  de rang :  2 et 2 	 A : A :: As :: Op ::   de rang : 2 et 2 *)
assert(HAOoOpOsm3 : rk(A :: Oo :: Op :: Os :: nil) >= 3).
{
	try assert(HAAsOpeq : rk(A :: As :: Op :: nil) = 2) by (apply LAAsOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAAsOpMtmp : rk(A :: As :: Op :: nil) <= 2) by (solve_hyps_max HAAsOpeq HAAsOpM2).
	assert(HAAsOoOpOsmtmp : rk(A :: As :: Oo :: Op :: Os :: nil) >= 3) by (solve_hyps_min HAAsOoOpOseq HAAsOoOpOsm3).
	try assert(HAOpeq : rk(A :: Op :: nil) = 2) by (apply LAOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAOpmtmp : rk(A :: Op :: nil) >= 2) by (solve_hyps_min HAOpeq HAOpm2).
	assert(Hincl : incl (A :: Op :: nil) (list_inter (A :: As :: Op :: nil) (A :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: As :: Oo :: Op :: Os :: nil) (A :: As :: Op :: A :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: Op :: A :: Oo :: Op :: Os :: nil) ((A :: As :: Op :: nil) ++ (A :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAAsOoOpOsmtmp;try rewrite HT2 in HAAsOoOpOsmtmp.
	assert(HT := rule_4 (A :: As :: Op :: nil) (A :: Oo :: Op :: Os :: nil) (A :: Op :: nil) 3 2 2 HAAsOoOpOsmtmp HAOpmtmp HAAsOpMtmp Hincl); apply HT.
}
try clear HAOpM1. try clear HAOpM2. try clear HAOpM3. try clear HAOpm4. try clear HAOpm3. try clear HAOpm2. try clear HAOpm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAOoOpOsM3 : rk(A :: Oo :: Op :: Os :: nil) <= 3).
{
	try assert(HAApOoOpOseq : rk(A :: Ap :: Oo :: Op :: Os :: nil) = 3) by (apply LAApOoOpOs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAApOoOpOsMtmp : rk(A :: Ap :: Oo :: Op :: Os :: nil) <= 3) by (solve_hyps_max HAApOoOpOseq HAApOoOpOsM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Oo :: Op :: Os :: nil) (A :: Ap :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Oo :: Op :: Os :: nil) (A :: Ap :: Oo :: Op :: Os :: nil) 3 3 HAApOoOpOsMtmp Hcomp Hincl);apply HT.
}


assert(HAOoOpOsM : rk(A :: Oo :: Op :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAOoOpOsm : rk(A :: Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HAOoOpOseq HAOoOpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Oo :: Op :: Os ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApOoOpOs requis par la preuve de (?)ABCApOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApOoOpOsm4 : rk(A :: B :: C :: Ap :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Oo :: Op :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApOoOpOsM : rk(A :: B :: C :: Ap :: Oo :: Op :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApOoOpOsm : rk(A :: B :: C :: Ap :: Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HABCApOoOpOseq HABCApOoOpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(B :: Bp :: Oo :: Op :: Os ::  nil) = 3.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpOoOpOs requis par la preuve de (?)BBpOoOpOs pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpOoOpOs requis par la preuve de (?)BBpOoOpOs pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpalphaOoOpOs requis par la preuve de (?)BBpOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpalphaOoOpOs requis par la preuve de (?)BCBpalphaOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOoOpOs requis par la preuve de (?)ABCBpalphaOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOoOpOsm4 : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpalphaOoOpOs requis par la preuve de (?)BCBpalphaOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpalphaOoOpOs requis par la preuve de (?)BCBpalphaOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalphaOoOpOs requis par la preuve de (?)ABCApBpalphaOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalphaOoOpOsm4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBpalphaOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApbeta requis par la preuve de (?)BCBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApbeta requis par la preuve de (?)ACApbeta pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApbetaM3 : rk(A :: C :: Ap :: beta :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACbetaeq : rk(A :: C :: beta :: nil) = 2) by (apply LACbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HACbetaMtmp : rk(A :: C :: beta :: nil) <= 2) by (solve_hyps_max HACbetaeq HACbetaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: beta :: nil) (Ap :: A :: C :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: beta :: nil) ((Ap :: nil) ++ (A :: C :: beta :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: beta :: nil) (nil) 1 2 0 HApMtmp HACbetaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: beta ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Bp ::   de rang : 1 et 2 *)
assert(HACApbetam2 : rk(A :: C :: Ap :: beta :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (nil) 4 0 2 HABCApBpbetamtmp Hmtmp HBBpMtmp Hincl); apply HT.
}
try clear HBBpM1. try clear HBBpM2. try clear HBBpM3. try clear HBBpm4. try clear HBBpm3. try clear HBBpm2. try clear HBBpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HACApbetaMtmp : rk(A :: C :: Ap :: beta :: nil) <= 3) by (solve_hyps_max HACApbetaeq HACApbetaM3).
	try assert(HABCApBpbetaeq : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) = 4) by (apply LABCApBpbeta with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpbetamtmp : rk(A :: B :: C :: Ap :: Bp :: beta :: nil) >= 4) by (solve_hyps_min HABCApBpbetaeq HABCApBpbetam4).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: beta :: nil) (B :: C :: Bp :: A :: C :: Ap :: beta :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Bp :: A :: C :: Ap :: beta :: nil) ((B :: C :: Bp :: nil) ++ (A :: C :: Ap :: beta :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpbetamtmp;try rewrite HT2 in HABCApBpbetamtmp.
	assert(HT := rule_2 (B :: C :: Bp :: nil) (A :: C :: Ap :: beta :: nil) (C :: nil) 4 1 3 HABCApBpbetamtmp HCmtmp HACApbetaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpalphaOoOpOs requis par la preuve de (?)BCBpalphaOoOpOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os ::  de rang :  4 et 4 	 AiB : B :: C :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HBCBpalphaOoOpOsm2 : rk(B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpalphaOoOpOsmtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 4) by (solve_hyps_min HABCApBpalphaOoOpOseq HABCApBpalphaOoOpOsm4).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 2) by (solve_hyps_min HBCBpeq HBCBpm2).
	assert(Hincl : incl (B :: C :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os :: nil) (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphaOoOpOsmtmp;try rewrite HT2 in HABCApBpalphaOoOpOsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) (B :: C :: Bp :: nil) 4 2 4 HABCApBpalphaOoOpOsmtmp HBCBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpalphaOoOpOsM1. try clear HABCApBpalphaOoOpOsM2. try clear HABCApBpalphaOoOpOsM3. try clear HABCApBpalphaOoOpOsm4. try clear HABCApBpalphaOoOpOsm3. try clear HABCApBpalphaOoOpOsm2. try clear HABCApBpalphaOoOpOsm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os ::  de rang :  4 et 4 	 AiB : alpha ::  de rang :  1 et 1 	 A : A :: alpha ::   de rang : 2 et 2 *)
assert(HBCBpalphaOoOpOsm3 : rk(B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 3).
{
	try assert(HAalphaeq : rk(A :: alpha :: nil) = 2) by (apply LAalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAalphaMtmp : rk(A :: alpha :: nil) <= 2) by (solve_hyps_max HAalphaeq HAalphaM2).
	assert(HABCBpalphaOoOpOsmtmp : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 4) by (solve_hyps_min HABCBpalphaOoOpOseq HABCBpalphaOoOpOsm4).
	try assert(Halphaeq : rk(alpha :: nil) = 1) by (apply Lalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(Halphamtmp : rk(alpha :: nil) >= 1) by (solve_hyps_min Halphaeq Halpham1).
	assert(Hincl : incl (alpha :: nil) (list_inter (A :: alpha :: nil) (B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) (A :: alpha :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: alpha :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) ((A :: alpha :: nil) ++ (B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpalphaOoOpOsmtmp;try rewrite HT2 in HABCBpalphaOoOpOsmtmp.
	assert(HT := rule_4 (A :: alpha :: nil) (B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) (alpha :: nil) 4 1 2 HABCBpalphaOoOpOsmtmp Halphamtmp HAalphaMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpOoOpOs requis par la preuve de (?)BBpOoOpOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: alpha :: Oo :: Op :: Os ::  de rang :  3 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HBBpOoOpOsm2 : rk(B :: Bp :: Oo :: Op :: Os :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HBCBpalphaOoOpOsmtmp : rk(B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 3) by (solve_hyps_min HBCBpalphaOoOpOseq HBCBpalphaOoOpOsm3).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (B :: Bp :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) (B :: C :: alpha :: B :: Bp :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: B :: Bp :: Oo :: Op :: Os :: nil) ((B :: C :: alpha :: nil) ++ (B :: Bp :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpalphaOoOpOsmtmp;try rewrite HT2 in HBCBpalphaOoOpOsmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (B :: Bp :: Oo :: Op :: Os :: nil) (B :: nil) 3 1 2 HBCBpalphaOoOpOsmtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HBCBpalphaOoOpOsM1. try clear HBCBpalphaOoOpOsM2. try clear HBCBpalphaOoOpOsM3. try clear HBCBpalphaOoOpOsm4. try clear HBCBpalphaOoOpOsm3. try clear HBCBpalphaOoOpOsm2. try clear HBCBpalphaOoOpOsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpOoOpOsm3 : rk(B :: Bp :: Oo :: Op :: Os :: nil) >= 3).
{
	try assert(HBBpOoeq : rk(B :: Bp :: Oo :: nil) = 3) by (apply LBBpOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpOomtmp : rk(B :: Bp :: Oo :: nil) >= 3) by (solve_hyps_min HBBpOoeq HBBpOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Oo :: nil) (B :: Bp :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Oo :: nil) (B :: Bp :: Oo :: Op :: Os :: nil) 3 3 HBBpOomtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBBpOoOpOsM3 : rk(B :: Bp :: Oo :: Op :: Os :: nil) <= 3).
{
	try assert(HBBpOoOpeq : rk(B :: Bp :: Oo :: Op :: nil) = 3) by (apply LBBpOoOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpOoOpMtmp : rk(B :: Bp :: Oo :: Op :: nil) <= 3) by (solve_hyps_max HBBpOoOpeq HBBpOoOpM3).
	try assert(HBBpOoOseq : rk(B :: Bp :: Oo :: Os :: nil) = 3) by (apply LBBpOoOs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpOoOsMtmp : rk(B :: Bp :: Oo :: Os :: nil) <= 3) by (solve_hyps_max HBBpOoOseq HBBpOoOsM3).
	try assert(HBBpOoeq : rk(B :: Bp :: Oo :: nil) = 3) by (apply LBBpOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpOomtmp : rk(B :: Bp :: Oo :: nil) >= 3) by (solve_hyps_min HBBpOoeq HBBpOom3).
	assert(Hincl : incl (B :: Bp :: Oo :: nil) (list_inter (B :: Bp :: Oo :: Op :: nil) (B :: Bp :: Oo :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Oo :: Op :: Os :: nil) (B :: Bp :: Oo :: Op :: B :: Bp :: Oo :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Oo :: Op :: B :: Bp :: Oo :: Os :: nil) ((B :: Bp :: Oo :: Op :: nil) ++ (B :: Bp :: Oo :: Os :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: Bp :: Oo :: Op :: nil) (B :: Bp :: Oo :: Os :: nil) (B :: Bp :: Oo :: nil) 3 3 3 HBBpOoOpMtmp HBBpOoOsMtmp HBBpOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HBBpOoOpOsM : rk(B :: Bp :: Oo :: Op :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpOoOpOsm : rk(B :: Bp :: Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HBBpOoOpOseq HBBpOoOpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABBpOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: Bp :: Oo :: Op :: Os ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpOoOpOs requis par la preuve de (?)ABBpOoOpOs pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCBpalphaOoOpOs requis par la preuve de (?)ABBpOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOoOpOs requis par la preuve de (?)ABCBpalphaOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOoOpOsm4 : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpOoOpOs requis par la preuve de (?)ABBpOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpOoOpOs requis par la preuve de (?)ABBpOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpOoOpOs requis par la preuve de (?)ABCApBpOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpOoOpOsm4 : rk(A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBpOoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCApalpha requis par la preuve de (?)ABBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApalpha requis par la preuve de (?)BCApalpha pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCApalphaM3 : rk(B :: C :: Ap :: alpha :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: alpha :: nil) (Ap :: B :: C :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: alpha :: nil) ((Ap :: nil) ++ (B :: C :: alpha :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: alpha :: nil) (nil) 1 2 0 HApMtmp HBCalphaMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: alpha ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Bp ::   de rang : 1 et 2 *)
assert(HBCApalpham2 : rk(B :: C :: Ap :: alpha :: nil) >= 2).
{
	assert(HABpMtmp : rk(A :: Bp :: nil) <= 2) by (solve_hyps_max HABpeq HABpM2).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_4 (A :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (nil) 4 0 2 HABCApBpalphamtmp Hmtmp HABpMtmp Hincl); apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABBp requis par la preuve de (?)ABBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABBpm2 : rk(A :: B :: Bp :: nil) >= 2).
{
	assert(HBCApalphaMtmp : rk(B :: C :: Ap :: alpha :: nil) <= 3) by (solve_hyps_max HBCApalphaeq HBCApalphaM3).
	try assert(HABCApBpalphaeq : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) = 4) by (apply LABCApBpalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpalphamtmp : rk(A :: B :: C :: Ap :: Bp :: alpha :: nil) >= 4) by (solve_hyps_min HABCApBpalphaeq HABCApBpalpham4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: alpha :: nil) (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Bp :: B :: C :: Ap :: alpha :: nil) ((A :: B :: Bp :: nil) ++ (B :: C :: Ap :: alpha :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpalphamtmp;try rewrite HT2 in HABCApBpalphamtmp.
	assert(HT := rule_2 (A :: B :: Bp :: nil) (B :: C :: Ap :: alpha :: nil) (B :: nil) 4 1 3 HABCApBpalphamtmp HBmtmp HBCApalphaMtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpOoOpOs requis par la preuve de (?)ABBpOoOpOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os ::  de rang :  4 et 4 	 AiB : A :: B :: Bp ::  de rang :  2 et 3 	 A : A :: B :: C :: Ap :: Bp ::   de rang : 4 et 4 *)
assert(HABBpOoOpOsm2 : rk(A :: B :: Bp :: Oo :: Op :: Os :: nil) >= 2).
{
	try assert(HABCApBpeq : rk(A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LABCApBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApBpMtmp : rk(A :: B :: C :: Ap :: Bp :: nil) <= 4) by (solve_hyps_max HABCApBpeq HABCApBpM4).
	assert(HABCApBpOoOpOsmtmp : rk(A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os :: nil) >= 4) by (solve_hyps_min HABCApBpOoOpOseq HABCApBpOoOpOsm4).
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 2) by (solve_hyps_min HABBpeq HABBpm2).
	assert(Hincl : incl (A :: B :: Bp :: nil) (list_inter (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os :: nil) (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: Ap :: Bp :: A :: B :: Bp :: Oo :: Op :: Os :: nil) ((A :: B :: C :: Ap :: Bp :: nil) ++ (A :: B :: Bp :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpOoOpOsmtmp;try rewrite HT2 in HABCApBpOoOpOsmtmp.
	assert(HT := rule_4 (A :: B :: C :: Ap :: Bp :: nil) (A :: B :: Bp :: Oo :: Op :: Os :: nil) (A :: B :: Bp :: nil) 4 2 4 HABCApBpOoOpOsmtmp HABBpmtmp HABCApBpMtmp Hincl); apply HT.
}
try clear HABCApBpOoOpOsM1. try clear HABCApBpOoOpOsM2. try clear HABCApBpOoOpOsM3. try clear HABCApBpOoOpOsm4. try clear HABCApBpOoOpOsm3. try clear HABCApBpOoOpOsm2. try clear HABCApBpOoOpOsm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os ::  de rang :  4 et 4 	 AiB : B ::  de rang :  1 et 1 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HABBpOoOpOsm3 : rk(A :: B :: Bp :: Oo :: Op :: Os :: nil) >= 3).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	assert(HABCBpalphaOoOpOsmtmp : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 4) by (solve_hyps_min HABCBpalphaOoOpOseq HABCBpalphaOoOpOsm4).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: alpha :: nil) (A :: B :: Bp :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) (B :: C :: alpha :: A :: B :: Bp :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: B :: Bp :: Oo :: Op :: Os :: nil) ((B :: C :: alpha :: nil) ++ (A :: B :: Bp :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpalphaOoOpOsmtmp;try rewrite HT2 in HABCBpalphaOoOpOsmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: B :: Bp :: Oo :: Op :: Os :: nil) (B :: nil) 4 1 2 HABCBpalphaOoOpOsmtmp HBmtmp HBCalphaMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABBpOoOpOsm4 : rk(A :: B :: Bp :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABBpOpeq : rk(A :: B :: Bp :: Op :: nil) = 4) by (apply LABBpOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABBpOpmtmp : rk(A :: B :: Bp :: Op :: nil) >= 4) by (solve_hyps_min HABBpOpeq HABBpOpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: Op :: nil) (A :: B :: Bp :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: Op :: nil) (A :: B :: Bp :: Oo :: Op :: Os :: nil) 4 4 HABBpOpmtmp Hcomp Hincl);apply HT.
}


assert(HABBpOoOpOsM : rk(A :: B :: Bp :: Oo :: Op :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABBpOoOpOsm : rk(A :: B :: Bp :: Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HABBpOoOpOseq HABBpOoOpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpOoOpOs requis par la preuve de (?)ABCApBpOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpOoOpOsm4 : rk(A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApBpOoOpOsM : rk(A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpOoOpOsm : rk(A :: B :: C :: Ap :: Bp :: Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HABCApBpOoOpOseq HABCApBpOoOpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApalphaOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApalphaOoOpOs requis par la preuve de (?)ABCApalphaOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApalphaOoOpOsm4 : rk(A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}


assert(HABCApalphaOoOpOsM : rk(A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApalphaOoOpOsm : rk(A :: B :: C :: Ap :: alpha :: Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HABCApalphaOoOpOseq HABCApalphaOoOpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCBpalphaOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCBpalphaOoOpOs requis par la preuve de (?)ABCBpalphaOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCBpalphaOoOpOsm4 : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Bp :: nil) (A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os :: nil) 4 4 HABCBpmtmp Hcomp Hincl);apply HT.
}


assert(HABCBpalphaOoOpOsM : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpalphaOoOpOsm : rk(A :: B :: C :: Bp :: alpha :: Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HABCBpalphaOoOpOseq HABCBpalphaOoOpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpalphaOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpalphaOoOpOs requis par la preuve de (?)ABCApBpalphaOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCApBpalphaOoOpOsm4 : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os :: nil) 4 4 HABCApmtmp Hcomp Hincl);apply HT.
}
try clear HABCApM1. try clear HABCApM2. try clear HABCApM3. try clear HABCApm4. try clear HABCApm3. try clear HABCApm2. try clear HABCApm1. 

assert(HABCApBpalphaOoOpOsM : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpalphaOoOpOsm : rk(A :: B :: C :: Ap :: Bp :: alpha :: Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HABCApBpalphaOoOpOseq HABCApBpalphaOoOpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCAsalphaOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(A :: B :: C :: As :: alpha :: Oo :: Op :: Os ::  nil) = 4.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCAsalphaOoOpOs requis par la preuve de (?)ABCAsalphaOoOpOs pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCAsalphaOoOpOsm4 : rk(A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil) >= 4).
{
	try assert(HABCAseq : rk(A :: B :: C :: As :: nil) = 4) by (apply LABCAs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsmtmp : rk(A :: B :: C :: As :: nil) >= 4) by (solve_hyps_min HABCAseq HABCAsm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: As :: nil) (A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil) 4 4 HABCAsmtmp Hcomp Hincl);apply HT.
}


assert(HABCAsalphaOoOpOsM : rk(A :: B :: C :: As :: alpha :: Oo :: Op :: Os ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCAsalphaOoOpOsm : rk(A :: B :: C :: As :: alpha :: Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HABCAsalphaOoOpOseq HABCAsalphaOoOpOsm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoOpOs : forall A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os ,
rk(A :: B :: C :: Ap ::  nil) = 4 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(A :: B :: C :: Cp ::  nil) = 4 ->
rk(A :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(B :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(C :: Ap :: Bp :: Cp ::  nil) = 4 ->
rk(A :: B :: C :: As ::  nil) = 4 -> rk(B :: C :: Ap :: As ::  nil) = 4 -> rk(B :: C :: Bp :: As ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: As ::  nil) = 4 -> rk(A :: B :: C :: Bs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Bs ::  nil) = 4 ->
rk(A :: Ap :: As :: Bs ::  nil) = 4 -> rk(B :: Ap :: As :: Bs ::  nil) = 4 -> rk(C :: Ap :: As :: Bs ::  nil) = 4 ->
rk(A :: Bp :: As :: Bs ::  nil) = 4 -> rk(B :: Bp :: As :: Bs ::  nil) = 4 -> rk(C :: Bp :: As :: Bs ::  nil) = 4 ->
rk(A :: Cp :: As :: Bs ::  nil) = 4 -> rk(B :: Cp :: As :: Bs ::  nil) = 4 -> rk(C :: Cp :: As :: Bs ::  nil) = 4 ->
rk(A :: B :: C :: Cs ::  nil) = 4 -> rk(Ap :: Bp :: Cp :: Cs ::  nil) = 4 -> rk(A :: Ap :: As :: Cs ::  nil) = 4 ->
rk(B :: Ap :: As :: Cs ::  nil) = 4 -> rk(C :: Ap :: As :: Cs ::  nil) = 4 -> rk(A :: Bp :: As :: Cs ::  nil) = 4 ->
rk(B :: Bp :: As :: Cs ::  nil) = 4 -> rk(C :: Bp :: As :: Cs ::  nil) = 4 -> rk(A :: Cp :: As :: Cs ::  nil) = 4 ->
rk(B :: Cp :: As :: Cs ::  nil) = 4 -> rk(C :: Cp :: As :: Cs ::  nil) = 4 -> rk(A :: Ap :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(C :: Ap :: Bs :: Cs ::  nil) = 4 -> rk(A :: Bp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Bp :: Bs :: Cs ::  nil) = 4 -> rk(A :: Cp :: Bs :: Cs ::  nil) = 4 ->
rk(B :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(C :: Cp :: Bs :: Cs ::  nil) = 4 -> rk(A :: As :: Bs :: Cs ::  nil) = 4 ->
rk(B :: As :: Bs :: Cs ::  nil) = 4 -> rk(C :: As :: Bs :: Cs ::  nil) = 4 -> rk(Ap :: As :: Bs :: Cs ::  nil) = 4 ->
rk(Bp :: As :: Bs :: Cs ::  nil) = 4 -> rk(Cp :: As :: Bs :: Cs ::  nil) = 4 -> rk(B :: C :: alpha ::  nil) = 2 ->
rk(Bp :: Cp :: alpha ::  nil) = 2 -> rk(Bs :: Cs :: alpha ::  nil) = 2 -> rk(A :: C :: beta ::  nil) = 2 ->
rk(Ap :: Cp :: beta ::  nil) = 2 -> rk(As :: Cs :: beta ::  nil) = 2 -> rk(A :: B :: gamma ::  nil) = 2 ->
rk(Ap :: Bp :: gamma ::  nil) = 2 -> rk(As :: Bs :: gamma ::  nil) = 2 -> rk(Ap :: As :: Oo ::  nil) = 2 ->
rk(Bp :: Bs :: Oo ::  nil) = 2 -> rk(A :: As :: Op ::  nil) = 2 -> rk(B :: Bs :: Op ::  nil) = 2 ->
rk(A :: Ap :: Os ::  nil) = 2 -> rk(B :: Bp :: Os ::  nil) = 2 -> rk(Oo :: Op :: Os ::  nil) = 2.
Proof.

intros A B C Ap Bp Cp As Bs Cs alpha beta gamma Oo Op Os 
HABCApeq HABCBpeq HABCCpeq HAApBpCpeq HBApBpCpeq HCApBpCpeq HABCAseq HBCApAseq HBCBpAseq HApBpCpAseq
HABCBseq HApBpCpBseq HAApAsBseq HBApAsBseq HCApAsBseq HABpAsBseq HBBpAsBseq HCBpAsBseq HACpAsBseq HBCpAsBseq
HCCpAsBseq HABCCseq HApBpCpCseq HAApAsCseq HBApAsCseq HCApAsCseq HABpAsCseq HBBpAsCseq HCBpAsCseq HACpAsCseq
HBCpAsCseq HCCpAsCseq HAApBsCseq HBApBsCseq HCApBsCseq HABpBsCseq HBBpBsCseq HCBpBsCseq HACpBsCseq HBCpBsCseq
HCCpBsCseq HAAsBsCseq HBAsBsCseq HCAsBsCseq HApAsBsCseq HBpAsBsCseq HCpAsBsCseq HBCalphaeq HBpCpalphaeq HBsCsalphaeq
HACbetaeq HApCpbetaeq HAsCsbetaeq HABgammaeq HApBpgammaeq HAsBsgammaeq HApAsOoeq HBpBsOoeq HAAsOpeq HBBsOpeq
HAApOseq HBBpOseq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoOpOs requis par la preuve de (?)OoOpOs pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AAsOoOpOs requis par la preuve de (?)OoOpOs pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AAsOoOpOs requis par la preuve de (?)AAsOoOpOs pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AAsOoOpOs requis par la preuve de (?)AAsOoOpOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: As :: alpha :: Oo :: Op :: Os ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: C :: alpha ::   de rang : 2 et 2 *)
assert(HAAsOoOpOsm2 : rk(A :: As :: Oo :: Op :: Os :: nil) >= 2).
{
	try assert(HBCalphaeq : rk(B :: C :: alpha :: nil) = 2) by (apply LBCalpha with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBCalphaMtmp : rk(B :: C :: alpha :: nil) <= 2) by (solve_hyps_max HBCalphaeq HBCalphaM2).
	try assert(HABCAsalphaOoOpOseq : rk(A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil) = 4) by (apply LABCAsalphaOoOpOs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABCAsalphaOoOpOsmtmp : rk(A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil) >= 4) by (solve_hyps_min HABCAsalphaOoOpOseq HABCAsalphaOoOpOsm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: C :: alpha :: nil) (A :: As :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: As :: alpha :: Oo :: Op :: Os :: nil) (B :: C :: alpha :: A :: As :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: alpha :: A :: As :: Oo :: Op :: Os :: nil) ((B :: C :: alpha :: nil) ++ (A :: As :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCAsalphaOoOpOsmtmp;try rewrite HT2 in HABCAsalphaOoOpOsmtmp.
	assert(HT := rule_4 (B :: C :: alpha :: nil) (A :: As :: Oo :: Op :: Os :: nil) (nil) 4 0 2 HABCAsalphaOoOpOsmtmp Hmtmp HBCalphaMtmp Hincl); apply HT.
}
try clear HABCAsalphaOoOpOsM1. try clear HABCAsalphaOoOpOsM2. try clear HABCAsalphaOoOpOsM3. try clear HABCAsalphaOoOpOsm4. try clear HABCAsalphaOoOpOsm3. try clear HABCAsalphaOoOpOsm2. try clear HABCAsalphaOoOpOsm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAAsOoOpOsm3 : rk(A :: As :: Oo :: Op :: Os :: nil) >= 3).
{
	try assert(HAAsOoeq : rk(A :: As :: Oo :: nil) = 3) by (apply LAAsOo with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAAsOomtmp : rk(A :: As :: Oo :: nil) >= 3) by (solve_hyps_min HAAsOoeq HAAsOom3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: As :: Oo :: nil) (A :: As :: Oo :: Op :: Os :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: As :: Oo :: nil) (A :: As :: Oo :: Op :: Os :: nil) 3 3 HAAsOomtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoOpOs requis par la preuve de (?)OoOpOs pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: As :: Oo :: Op :: Os ::  de rang :  3 et 4 	 AiB : Op ::  de rang :  1 et 1 	 A : A :: As :: Op ::   de rang : 2 et 2 *)
assert(HOoOpOsm2 : rk(Oo :: Op :: Os :: nil) >= 2).
{
	try assert(HAAsOpeq : rk(A :: As :: Op :: nil) = 2) by (apply LAAsOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAAsOpMtmp : rk(A :: As :: Op :: nil) <= 2) by (solve_hyps_max HAAsOpeq HAAsOpM2).
	assert(HAAsOoOpOsmtmp : rk(A :: As :: Oo :: Op :: Os :: nil) >= 3) by (solve_hyps_min HAAsOoOpOseq HAAsOoOpOsm3).
	try assert(HOpeq : rk(Op :: nil) = 1) by (apply LOp with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HOpmtmp : rk(Op :: nil) >= 1) by (solve_hyps_min HOpeq HOpm1).
	assert(Hincl : incl (Op :: nil) (list_inter (A :: As :: Op :: nil) (Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: As :: Oo :: Op :: Os :: nil) (A :: As :: Op :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: As :: Op :: Oo :: Op :: Os :: nil) ((A :: As :: Op :: nil) ++ (Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAAsOoOpOsmtmp;try rewrite HT2 in HAAsOoOpOsmtmp.
	assert(HT := rule_4 (A :: As :: Op :: nil) (Oo :: Op :: Os :: nil) (Op :: nil) 3 1 2 HAAsOoOpOsmtmp HOpmtmp HAAsOpMtmp Hincl); apply HT.
}
try clear HOpM1. try clear HOpM2. try clear HOpM3. try clear HOpm4. try clear HOpm3. try clear HOpm2. try clear HOpm1. 

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HOoOpOsM2 : rk(Oo :: Op :: Os :: nil) <= 2).
{
	try assert(HAOoOpOseq : rk(A :: Oo :: Op :: Os :: nil) = 3) by (apply LAOoOpOs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HAOoOpOsMtmp : rk(A :: Oo :: Op :: Os :: nil) <= 3) by (solve_hyps_max HAOoOpOseq HAOoOpOsM3).
	try assert(HBBpOoOpOseq : rk(B :: Bp :: Oo :: Op :: Os :: nil) = 3) by (apply LBBpOoOpOs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HBBpOoOpOsMtmp : rk(B :: Bp :: Oo :: Op :: Os :: nil) <= 3) by (solve_hyps_max HBBpOoOpOseq HBBpOoOpOsM3).
	try assert(HABBpOoOpOseq : rk(A :: B :: Bp :: Oo :: Op :: Os :: nil) = 4) by (apply LABBpOoOpOs with (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (As := As) (Bs := Bs) (Cs := Cs) (alpha := alpha) (beta := beta) (gamma := gamma) (Oo := Oo) (Op := Op) (Os := Os) ;try assumption).
	assert(HABBpOoOpOsmtmp : rk(A :: B :: Bp :: Oo :: Op :: Os :: nil) >= 4) by (solve_hyps_min HABBpOoOpOseq HABBpOoOpOsm4).
	assert(Hincl : incl (Oo :: Op :: Os :: nil) (list_inter (A :: Oo :: Op :: Os :: nil) (B :: Bp :: Oo :: Op :: Os :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: Oo :: Op :: Os :: nil) (A :: Oo :: Op :: Os :: B :: Bp :: Oo :: Op :: Os :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Oo :: Op :: Os :: B :: Bp :: Oo :: Op :: Os :: nil) ((A :: Oo :: Op :: Os :: nil) ++ (B :: Bp :: Oo :: Op :: Os :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpOoOpOsmtmp;try rewrite HT2 in HABBpOoOpOsmtmp.
	assert(HT := rule_3 (A :: Oo :: Op :: Os :: nil) (B :: Bp :: Oo :: Op :: Os :: nil) (Oo :: Op :: Os :: nil) 3 3 4 HAOoOpOsMtmp HBBpOoOpOsMtmp HABBpOoOpOsmtmp Hincl);apply HT.
}


assert(HOoOpOsM : rk(Oo :: Op :: Os ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoOpOseq HOoOpOsM3).
assert(HOoOpOsm : rk(Oo :: Op :: Os ::  nil) >= 1) by (solve_hyps_min HOoOpOseq HOoOpOsm1).
intuition.
Qed.

