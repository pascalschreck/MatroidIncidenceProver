Require Import lemmas_automation_g.


(* dans la couche 0 *)
Lemma LOo : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoM : rk(Oo ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HOoeq HOoM1).
assert(HOom : rk(Oo ::  nil) >= 1) by (solve_hyps_min HOoeq HOom1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LA : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HAM : rk(A ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HAeq HAM1).
assert(HAm : rk(A ::  nil) >= 1) by (solve_hyps_min HAeq HAm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LB : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HBM : rk(B ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBeq HBM1).
assert(HBm : rk(B ::  nil) >= 1) by (solve_hyps_min HBeq HBm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LC : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HCM : rk(C ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCeq HCM1).
assert(HCm : rk(C ::  nil) >= 1) by (solve_hyps_min HCeq HCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABC : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoABCM : rk(Oo :: A :: B :: C ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCm : rk(Oo :: A :: B :: C ::  nil) >= 1) by (solve_hyps_min HOoABCeq HOoABCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HApM : rk(Ap ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HApeq HApM1).
assert(HApm : rk(Ap ::  nil) >= 1) by (solve_hyps_min HApeq HApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAp *)
(* dans la couche 0 *)
Lemma LOoApBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoApBpDpM : rk(Oo :: Ap :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpDpm : rk(Oo :: Ap :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoApBpDpeq HOoApBpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAp *)
(* dans la couche 0 *)
Lemma LApBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HApBpDpM : rk(Ap :: Bp :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpDpeq HApBpDpM3).
assert(HApBpDpm : rk(Ap :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HApBpDpeq HApBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoAp requis par la preuve de (?)OoAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApm2 : rk(Oo :: Ap :: nil) >= 2).
{
	try assert(HApBpDpeq : rk(Ap :: Bp :: Dp :: nil) = 3) by (apply LApBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpDpMtmp : rk(Ap :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HApBpDpeq HApBpDpM3).
	try assert(HOoApBpDpeq : rk(Oo :: Ap :: Bp :: Dp :: nil) = 4) by (apply LOoApBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApBpDpmtmp : rk(Oo :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoApBpDpeq HOoApBpDpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: nil) (Ap :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Dp :: nil) (Oo :: Ap :: Ap :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Ap :: Bp :: Dp :: nil) ((Oo :: Ap :: nil) ++ (Ap :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpDpmtmp;try rewrite HT2 in HOoApBpDpmtmp.
	assert(HT := rule_2 (Oo :: Ap :: nil) (Ap :: Bp :: Dp :: nil) (Ap :: nil) 4 1 3 HOoApBpDpmtmp HApmtmp HApBpDpMtmp Hincl);apply HT.
}


assert(HOoApM : rk(Oo :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoApeq HOoApM2).
assert(HOoApm : rk(Oo :: Ap ::  nil) >= 1) by (solve_hyps_min HOoApeq HOoApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAAp *)
(* dans constructLemma(), requis par LABAp *)
(* dans la couche 0 *)
Lemma LABCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HABCApM : rk(A :: B :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApm : rk(A :: B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HABCApeq HABCApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABAp *)
(* dans constructLemma(), requis par LBAp *)
(* dans la couche 0 *)
Lemma LOoABCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCAp requis par la preuve de (?)OoABCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApm4 : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApM : rk(Oo :: A :: B :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApm : rk(Oo :: A :: B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABCApeq HOoABCApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBAp *)
(* dans la couche 0 *)
Lemma LBAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)BAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour OoAAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (C :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HCMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)BAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBApm2 : rk(B :: Ap :: nil) >= 2).
{
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_2 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (Ap :: nil) 4 1 3 HOoABCApmtmp HApmtmp HOoACApMtmp Hincl);apply HT.
}


assert(HBApM : rk(B :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBApeq HBApM2).
assert(HBApm : rk(B :: Ap ::  nil) >= 1) by (solve_hyps_min HBApeq HBApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABAp *)
(* dans constructLemma(), requis par LBCAp *)
(* dans la couche 0 *)
Lemma LOoAAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoAApM : rk(Oo :: A :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAApeq HOoAApM3).
assert(HOoAApm : rk(Oo :: A :: Ap ::  nil) >= 1) by (solve_hyps_min HOoAApeq HOoAApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCAp requis par la preuve de (?)BCAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApm3 : rk(B :: C :: Ap :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HBCApM : rk(B :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCApeq HBCApM3).
assert(HBCApm : rk(B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HBCApeq HBCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour OoACAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (C :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HCMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApm3 : rk(Oo :: A :: C :: Ap :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (A :: B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (A :: B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Oo :: A :: C :: Ap :: nil) ((A :: B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApmtmp HAApmtmp HOoACApMtmp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABApm3 : rk(A :: B :: Ap :: nil) >= 3).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (A :: B :: Ap :: nil) (B :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: nil) (A :: B :: Ap :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: B :: C :: Ap :: nil) ((A :: B :: Ap :: nil) ++ (B :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApmtmp;try rewrite HT2 in HABCApmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (B :: C :: Ap :: nil) (B :: Ap :: nil) 4 2 3 HABCApmtmp HBApmtmp HBCApMtmp Hincl);apply HT.
}


assert(HABApM : rk(A :: B :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABApeq HABApM3).
assert(HABApm : rk(A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HABApeq HABApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)AAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApm2 : rk(A :: Ap :: nil) >= 2).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (B :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: nil) (A :: Ap :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: B :: Ap :: nil) ((A :: Ap :: nil) ++ (B :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApmtmp;try rewrite HT2 in HABApmtmp.
	assert(HT := rule_2 (A :: Ap :: nil) (B :: Ap :: nil) (Ap :: nil) 3 1 2 HABApmtmp HApmtmp HBApMtmp Hincl);apply HT.
}


assert(HAApM : rk(A :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAApeq HAApM2).
assert(HAApm : rk(A :: Ap ::  nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBAp *)
(* dans la couche 0 *)
Lemma LOoACAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (C :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HCMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApm3 : rk(Oo :: A :: C :: Ap :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


assert(HOoACApM : rk(Oo :: A :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApm : rk(Oo :: A :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoACApeq HOoACApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBAp requis par la preuve de (?)OoBAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApm3 : rk(Oo :: B :: Ap :: nil) >= 3).
{
	try assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: Oo :: A :: C :: Ap :: nil) ((Oo :: B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApmtmp HOoApmtmp HOoACApMtmp Hincl);apply HT.
}


assert(HOoBApM : rk(Oo :: B :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBApeq HOoBApM3).
assert(HOoBApm : rk(Oo :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoBApeq HOoBApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABAp *)
(* dans la couche 0 *)
Lemma LOoABAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)OoABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoABApM3 : rk(Oo :: A :: B :: Ap :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: nil) (B :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: Ap :: nil) ((B :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HBMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm2 : rk(Oo :: A :: B :: Ap :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HOoABApm3 : rk(Oo :: A :: B :: Ap :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HCApMtmp Hincl);apply HT.
}


assert(HOoABApM : rk(Oo :: A :: B :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApm : rk(Oo :: A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABApeq HOoABApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)CAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApm2 : rk(C :: Ap :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: nil) (Ap :: nil) 4 1 3 HOoABCApmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HCApM : rk(C :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCApeq HCApM2).
assert(HCApm : rk(C :: Ap ::  nil) >= 1) by (solve_hyps_min HCApeq HCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACAp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACApm3 : rk(A :: C :: Ap :: nil) >= 3).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	try assert(HABCApeq : rk(A :: B :: C :: Ap :: nil) = 4) by (apply LABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (A :: C :: Ap :: nil) (B :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: nil) (A :: C :: Ap :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: B :: C :: Ap :: nil) ((A :: C :: Ap :: nil) ++ (B :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApmtmp;try rewrite HT2 in HABCApmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (B :: C :: Ap :: nil) (C :: Ap :: nil) 4 2 3 HABCApmtmp HCApmtmp HBCApMtmp Hincl);apply HT.
}
try clear HABCApM1. try clear HABCApM2. try clear HABCApM3. try clear HABCApm4. try clear HABCApm3. try clear HABCApm2. try clear HABCApm1. 

assert(HACApM : rk(A :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACApeq HACApM3).
assert(HACApm : rk(A :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HACApeq HACApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HBpM : rk(Bp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HBpeq HBpM1).
assert(HBpm : rk(Bp ::  nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBp *)
(* dans la couche 0 *)
Lemma LOoApBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoApBpCpM : rk(Oo :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpCpm : rk(Oo :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBp *)
(* dans la couche 0 *)
Lemma LOoApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpm2 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpm3 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApCpm2 : rk(Oo :: Ap :: Cp :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApCpeq HOoABApCpm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpmtmp;try rewrite HT2 in HOoABApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Cp :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApCpmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HOoApCpm3 : rk(Oo :: Ap :: Cp :: nil) >= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApBpCpmtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (Oo :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: Oo :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Oo :: Ap :: Cp :: nil) ((Bp :: nil) ++ (Oo :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpCpmtmp;try rewrite HT2 in HOoApBpCpmtmp.
	assert(HT := rule_4 (Bp :: nil) (Oo :: Ap :: Cp :: nil) (nil) 4 0 1 HOoApBpCpmtmp Hmtmp HBpMtmp Hincl); apply HT.
}


assert(HOoApCpM : rk(Oo :: Ap :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApCpeq HOoApCpM3).
assert(HOoApCpm : rk(Oo :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApCpeq HOoApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoBp requis par la preuve de (?)OoBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpm2 : rk(Oo :: Bp :: nil) >= 2).
{
	try assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 3) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoApCpeq HOoApCpM3).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApBpCpmtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Bp :: nil) (Oo :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: Oo :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Oo :: Ap :: Cp :: nil) ((Oo :: Bp :: nil) ++ (Oo :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpCpmtmp;try rewrite HT2 in HOoApBpCpmtmp.
	assert(HT := rule_2 (Oo :: Bp :: nil) (Oo :: Ap :: Cp :: nil) (Oo :: nil) 4 1 3 HOoApBpCpmtmp HOomtmp HOoApCpMtmp Hincl);apply HT.
}


assert(HOoBpM : rk(Oo :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoBpeq HOoBpM2).
assert(HOoBpm : rk(Oo :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBpeq HOoBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LABCBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HABCBpM : rk(A :: B :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCBpm : rk(A :: B :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HABCBpeq HABCBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LABp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)ABp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBp requis par la preuve de (?)BCBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBp requis par la preuve de (?)OoABCApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: nil) (nil) 4 0 2 HOoABCApBpmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)ABp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABpm2 : rk(A :: Bp :: nil) >= 2).
{
	assert(HBCBpMtmp : rk(B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HBCBpeq HBCBpM3).
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: Bp :: nil) (B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: nil) (A :: Bp :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Bp :: nil) ((A :: Bp :: nil) ++ (B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpmtmp;try rewrite HT2 in HABCBpmtmp.
	assert(HT := rule_2 (A :: Bp :: nil) (B :: C :: Bp :: nil) (Bp :: nil) 4 1 3 HABCBpmtmp HBpmtmp HBCBpMtmp Hincl);apply HT.
}
try clear HBCBpM1. try clear HBCBpM2. try clear HBCBpM3. try clear HBCBpm4. try clear HBCBpm3. try clear HBCBpm2. try clear HBCBpm1. 

assert(HABpM : rk(A :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABpeq HABpM2).
assert(HABpm : rk(A :: Bp ::  nil) >= 1) by (solve_hyps_min HABpeq HABpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABp *)
(* dans la couche 0 *)
Lemma LOoABCBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBp requis par la preuve de (?)OoABCBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpm4 : rk(Oo :: A :: B :: C :: Bp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCBpM : rk(Oo :: A :: B :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpm : rk(Oo :: A :: B :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABCBpeq HOoABCBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABp *)
(* dans constructLemma(), requis par LOoBCBp *)
(* dans la couche 0 *)
Lemma LOoABCApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBp requis par la preuve de (?)OoABCApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpM : rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpm : rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)OoBCBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour OoBBp requis par la preuve de (?)OoBCBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoBCBpM3 : rk(Oo :: B :: C :: Bp :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: nil) (C :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: B :: Bp :: nil) ((C :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: B :: Bp :: nil) (nil) 1 2 0 HCMtmp HOoBBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 1 et 2 *)
assert(HOoBCBpm2 : rk(Oo :: B :: C :: Bp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	try assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil) (nil) 4 0 2 HOoABCApBpmtmp Hmtmp HAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpm3 : rk(Oo :: B :: C :: Bp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil) (Oo :: nil) 4 1 2 HOoABCApBpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCBpM : rk(Oo :: B :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpm : rk(Oo :: B :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBCBpeq HOoBCBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABp requis par la preuve de (?)OoABp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABBp requis par la preuve de (?)OoABp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour OoBBp requis par la preuve de (?)OoABBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoABBpM3 : rk(Oo :: A :: B :: Bp :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: nil) (A :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Oo :: B :: Bp :: nil) ((A :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Oo :: B :: Bp :: nil) (nil) 1 2 0 HAMtmp HOoBBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpm2 : rk(Oo :: A :: B :: Bp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	try assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: nil) (nil) 4 0 2 HOoABCApBpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABp requis par la preuve de (?)OoABp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et 5*)
assert(HOoABpm2 : rk(Oo :: A :: Bp :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpmtmp : rk(Oo :: A :: B :: Bp :: nil) >= 2) by (solve_hyps_min HOoABBpeq HOoABBpm2).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: Bp :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: nil) (Oo :: A :: Bp :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: Oo :: B :: Bp :: nil) ((Oo :: A :: Bp :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpmtmp;try rewrite HT2 in HOoABBpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: nil) (Oo :: B :: Bp :: nil) (Oo :: Bp :: nil) 2 2 2 HOoABBpmtmp HOoBpmtmp HOoBBpMtmp Hincl);apply HT.
}
try clear HOoABBpM1. try clear HOoABBpM2. try clear HOoABBpM3. try clear HOoABBpm4. try clear HOoABBpm3. try clear HOoABBpm2. try clear HOoABBpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpm3 : rk(Oo :: A :: Bp :: nil) >= 3).
{
	try assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	try assert(HOoABCBpeq : rk(Oo :: A :: B :: C :: Bp :: nil) = 4) by (apply LOoABCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCBpmtmp : rk(Oo :: A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCBpeq HOoABCBpm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: Bp :: nil) (Oo :: B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: nil) (Oo :: A :: Bp :: Oo :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: Oo :: B :: C :: Bp :: nil) ((Oo :: A :: Bp :: nil) ++ (Oo :: B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpmtmp;try rewrite HT2 in HOoABCBpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: nil) (Oo :: B :: C :: Bp :: nil) (Oo :: Bp :: nil) 4 2 3 HOoABCBpmtmp HOoBpmtmp HOoBCBpMtmp Hincl);apply HT.
}
try clear HOoABCBpM1. try clear HOoABCBpM2. try clear HOoABCBpM3. try clear HOoABCBpm4. try clear HOoABCBpm3. try clear HOoABCBpm2. try clear HOoABCBpm1. 

assert(HOoABpM : rk(Oo :: A :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoABpeq HOoABpM3).
assert(HOoABpm : rk(Oo :: A :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABpeq HOoABpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBp *)
(* dans la couche 0 *)
Lemma LBBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACBp requis par la preuve de (?)BBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACBpm2 : rk(A :: C :: Bp :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: A :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Bp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Bp :: nil) (A :: nil) 4 1 3 HOoABCApBpmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)BBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HBBpm2 : rk(B :: Bp :: nil) >= 2).
{
	assert(HACBpMtmp : rk(A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HACBpeq HACBpM3).
	try assert(HABCBpeq : rk(A :: B :: C :: Bp :: nil) = 4) by (apply LABCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: nil) (B :: Bp :: A :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpmtmp;try rewrite HT2 in HABCBpmtmp.
	assert(HT := rule_2 (B :: Bp :: nil) (A :: C :: Bp :: nil) (Bp :: nil) 4 1 3 HABCBpmtmp HBpmtmp HACBpMtmp Hincl);apply HT.
}
try clear HACBpM1. try clear HACBpM2. try clear HACBpM3. try clear HACBpm4. try clear HACBpm3. try clear HACBpm2. try clear HACBpm1. try clear HABCBpM1. try clear HABCBpM2. try clear HABCBpM3. try clear HABCBpm4. try clear HABCBpm3. try clear HABCBpm2. try clear HABCBpm1. 

assert(HBBpM : rk(B :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBBpeq HBBpM2).
assert(HBBpm : rk(B :: Bp ::  nil) >= 1) by (solve_hyps_min HBBpeq HBBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoBBpM : rk(Oo :: B :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBBpeq HOoBBpM3).
assert(HOoBBpm : rk(Oo :: B :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBBpeq HOoBBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApBp *)
(* dans la couche 0 *)
Lemma LOoBApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBApBp requis par la preuve de (?)OoBApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBApBp requis par la preuve de (?)OoBApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBp requis par la preuve de (?)OoBApBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBApBpM3 : rk(Oo :: B :: Ap :: Bp :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: nil) (Ap :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: B :: Bp :: nil) ((Ap :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (Oo :: B :: Bp :: nil) (nil) 1 2 0 HApMtmp HOoBBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpm2 : rk(Oo :: B :: Ap :: Bp :: nil) >= 2).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpm3 : rk(Oo :: B :: Ap :: Bp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


assert(HOoBApBpM : rk(Oo :: B :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpm : rk(Oo :: B :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBApBpeq HOoBApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApBp requis par la preuve de (?)ApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp ::  de rang :  3 et 3 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HApBpm2 : rk(Ap :: Bp :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HOoBApBpeq : rk(Oo :: B :: Ap :: Bp :: nil) = 3) by (apply LOoBApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApBpmtmp : rk(Oo :: B :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HOoBApBpeq HOoBApBpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: nil) (Oo :: B :: Bp :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Ap :: Bp :: nil) ((Oo :: B :: Bp :: nil) ++ (Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpmtmp;try rewrite HT2 in HOoBApBpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Ap :: Bp :: nil) (Bp :: nil) 3 1 2 HOoBApBpmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}


assert(HApBpM : rk(Ap :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApBpeq HApBpM2).
assert(HApBpm : rk(Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HApBpeq HApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABApBpM3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) <= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoBBpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpm2 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpm3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp ::  de rang :  3 et 3 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApBpm2 : rk(Oo :: Ap :: Bp :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HOoABApBpeq HOoABApBpm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: Bp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpmtmp;try rewrite HT2 in HOoABApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Bp :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApBpmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApBpM1. try clear HOoABApBpM2. try clear HOoABApBpM3. try clear HOoABApBpm4. try clear HOoABApBpm3. try clear HOoABApBpm2. try clear HOoABApBpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp ::  de rang :  3 et 3 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoApBpm3 : rk(Oo :: Ap :: Bp :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HOoBApBpeq : rk(Oo :: B :: Ap :: Bp :: nil) = 3) by (apply LOoBApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApBpmtmp : rk(Oo :: B :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HOoBApBpeq HOoBApBpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: nil) (Oo :: B :: Bp :: Oo :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Ap :: Bp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpmtmp;try rewrite HT2 in HOoBApBpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBApBpmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


assert(HOoApBpM : rk(Oo :: Ap :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApBpeq HOoApBpM3).
assert(HOoApBpm : rk(Oo :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoApBpeq HOoApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABApBpM3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) <= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoBBpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpm2 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpm3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApBpM : rk(Oo :: A :: B :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpm : rk(Oo :: A :: B :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABApBpeq HOoABApBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACApBp *)
(* dans constructLemma(), requis par LOoACApBpCp *)
(* dans la couche 0 *)
Lemma LOoABCApBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCp requis par la preuve de (?)OoABCApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpCpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApBpCpm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	try assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACApBpCpm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 4).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 4 2 2 HOoABCApBpCpmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


assert(HOoACApBpCpM : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpm : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACApBp *)
(* dans constructLemma(), requis par LOoACApCp *)
(* dans la couche 0 *)
Lemma LOoABCApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCp requis par la preuve de (?)OoABCApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApCpM : rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpm : rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour OoCCp requis par la preuve de (?)OoACApCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoACApCpM3 : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Oo :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: C :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: C :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: C :: Cp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoCCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApCpm2 : rk(Oo :: A :: C :: Ap :: Cp :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApCpm3 : rk(Oo :: A :: C :: Ap :: Cp :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	try assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) (Ap :: nil) 4 1 2 HOoABCApCpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


assert(HOoACApCpM : rk(Oo :: A :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApCpm : rk(Oo :: A :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApCpeq HOoACApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Bp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApBpm2 : rk(A :: C :: Ap :: Bp :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: Bp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: Bp :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApBpmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApBpm3 : rk(A :: C :: Ap :: Bp :: nil) >= 3).
{
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: Bp :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACApBpm4 : rk(A :: C :: Ap :: Bp :: nil) >= 4).
{
	try assert(HOoACApCpeq : rk(Oo :: A :: C :: Ap :: Cp :: nil) = 3) by (apply LOoACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACApCpMtmp : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApCpeq HOoACApCpM3).
	try assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm4).
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (A :: C :: Ap :: Bp :: Oo :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Bp :: Oo :: A :: C :: Ap :: Cp :: nil) ((A :: C :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) (A :: C :: Ap :: nil) 4 3 3 HOoACApBpCpmtmp HACApmtmp HOoACApCpMtmp Hincl);apply HT.
}


assert(HACApBpM : rk(A :: C :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpm : rk(A :: C :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HACApBpeq HACApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HCpM : rk(Cp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HCpeq HCpM1).
assert(HCpm : rk(Cp ::  nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoCp requis par la preuve de (?)OoCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoCpm2 : rk(Oo :: Cp :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApBpCpmtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: nil) (Oo :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Cp :: nil) (Ap :: Bp :: Oo :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Oo :: Cp :: nil) ((Ap :: Bp :: nil) ++ (Oo :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpCpmtmp;try rewrite HT2 in HOoApBpCpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Oo :: Cp :: nil) (nil) 4 0 2 HOoApBpCpmtmp Hmtmp HApBpMtmp Hincl); apply HT.
}


assert(HOoCpM : rk(Oo :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoCpeq HOoCpM2).
assert(HOoCpm : rk(Oo :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCpeq HOoCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCp *)
(* dans la couche 0 *)
Lemma LABCCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HABCCpM : rk(A :: B :: C :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCCpm : rk(A :: B :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HABCCpeq HABCCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCp *)
(* dans la couche 0 *)
Lemma LABCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpm3 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpm4 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABCpm2 : rk(A :: B :: Cp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApCpmtmp : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABCApCpeq HABCApCpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: nil) (C :: Ap :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: Cp :: nil) ((C :: Ap :: nil) ++ (A :: B :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpmtmp;try rewrite HT2 in HABCApCpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: Cp :: nil) (nil) 4 0 2 HABCApCpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApCpM1. try clear HABCApCpM2. try clear HABCApCpM3. try clear HABCApCpm4. try clear HABCApCpm3. try clear HABCApCpm2. try clear HABCApCpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HABCpm3 : rk(A :: B :: Cp :: nil) >= 3).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	try assert(HABCCpeq : rk(A :: B :: C :: Cp :: nil) = 4) by (apply LABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HABCCpeq HABCCpm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: Cp :: nil) (C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Cp :: nil) (A :: B :: Cp :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: C :: Cp :: nil) ((A :: B :: Cp :: nil) ++ (C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCCpmtmp;try rewrite HT2 in HABCCpmtmp.
	assert(HT := rule_2 (A :: B :: Cp :: nil) (C :: Cp :: nil) (Cp :: nil) 4 1 2 HABCCpmtmp HCpmtmp HCCpMtmp Hincl);apply HT.
}


assert(HABCpM : rk(A :: B :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABCpeq HABCpM3).
assert(HABCpm : rk(A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HABCpeq HABCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABCp *)
(* dans la couche 0 *)
Lemma LOoABCCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCp requis par la preuve de (?)OoABCCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCCpm4 : rk(Oo :: A :: B :: C :: Cp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCCpM : rk(Oo :: A :: B :: C :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpm : rk(Oo :: A :: B :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCCpeq HOoABCCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABCp *)
(* dans la couche 0 *)
Lemma LOoCCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoCCpM : rk(Oo :: C :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCCpeq HOoCCpM3).
assert(HOoCCpm : rk(Oo :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCCpeq HOoCCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour CCp requis par la preuve de (?)OoABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)CCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Cp ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HCCpm2 : rk(C :: Cp :: nil) >= 2).
{
	try assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCpMtmp : rk(A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HABCpeq HABCpM3).
	try assert(HABCCpeq : rk(A :: B :: C :: Cp :: nil) = 4) by (apply LABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HABCCpeq HABCCpm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: Cp :: nil) (C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Cp :: nil) (A :: B :: Cp :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: C :: Cp :: nil) ((A :: B :: Cp :: nil) ++ (C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCCpmtmp;try rewrite HT2 in HABCCpmtmp.
	assert(HT := rule_4 (A :: B :: Cp :: nil) (C :: Cp :: nil) (Cp :: nil) 4 1 3 HABCCpmtmp HCpmtmp HABCpMtmp Hincl); apply HT.
}
try clear HABCCpM1. try clear HABCCpM2. try clear HABCCpM3. try clear HABCCpm4. try clear HABCCpm3. try clear HABCCpm2. try clear HABCCpm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABCpm2 : rk(Oo :: A :: B :: Cp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	try assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (C :: Ap :: Oo :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Cp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Cp :: nil) (nil) 4 0 2 HOoABCApCpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HOoABCpm3 : rk(Oo :: A :: B :: Cp :: nil) >= 3).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	try assert(HOoABCCpeq : rk(Oo :: A :: B :: C :: Cp :: nil) = 4) by (apply LOoABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCCpmtmp : rk(Oo :: A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCCpeq HOoABCCpm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: nil) (Oo :: A :: B :: Cp :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: C :: Cp :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpmtmp;try rewrite HT2 in HOoABCCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Cp :: nil) (C :: Cp :: nil) (Cp :: nil) 4 1 2 HOoABCCpmtmp HCpmtmp HCCpMtmp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABCpm4 : rk(Oo :: A :: B :: Cp :: nil) >= 4).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HOoABCCpeq : rk(Oo :: A :: B :: C :: Cp :: nil) = 4) by (apply LOoABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCCpmtmp : rk(Oo :: A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCCpeq HOoABCCpm4).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (Oo :: C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: nil) (Oo :: A :: B :: Cp :: Oo :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: Oo :: C :: Cp :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (Oo :: C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpmtmp;try rewrite HT2 in HOoABCCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Cp :: nil) (Oo :: C :: Cp :: nil) (Oo :: Cp :: nil) 4 2 2 HOoABCCpmtmp HOoCpmtmp HOoCCpMtmp Hincl);apply HT.
}
try clear HOoABCCpM1. try clear HOoABCCpM2. try clear HOoABCCpM3. try clear HOoABCCpm4. try clear HOoABCCpm3. try clear HOoABCCpm2. try clear HOoABCCpm1. 

assert(HOoABCpM : rk(Oo :: A :: B :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpm : rk(Oo :: A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCpeq HOoABCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)CCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Cp ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HCCpm2 : rk(C :: Cp :: nil) >= 2).
{
	try assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCpMtmp : rk(A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HABCpeq HABCpM3).
	try assert(HABCCpeq : rk(A :: B :: C :: Cp :: nil) = 4) by (apply LABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HABCCpeq HABCCpm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: Cp :: nil) (C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Cp :: nil) (A :: B :: Cp :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: C :: Cp :: nil) ((A :: B :: Cp :: nil) ++ (C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCCpmtmp;try rewrite HT2 in HABCCpmtmp.
	assert(HT := rule_4 (A :: B :: Cp :: nil) (C :: Cp :: nil) (Cp :: nil) 4 1 3 HABCCpmtmp HCpmtmp HABCpMtmp Hincl); apply HT.
}
try clear HABCCpM1. try clear HABCCpM2. try clear HABCCpM3. try clear HABCCpm4. try clear HABCCpm3. try clear HABCCpm2. try clear HABCCpm1. 

assert(HCCpM : rk(C :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCCpeq HCCpM2).
assert(HCCpm : rk(C :: Cp ::  nil) >= 1) by (solve_hyps_min HCCpeq HCCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApCp requis par la preuve de (?)ApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HApCpm2 : rk(Ap :: Cp :: nil) >= 2).
{
	try assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 3) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoApBpeq HOoApBpM3).
	try assert(HOoApBpCpeq : rk(Oo :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApBpCpmtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Ap :: Cp :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpCpmtmp;try rewrite HT2 in HOoApBpCpmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Ap :: Cp :: nil) (Ap :: nil) 4 1 3 HOoApBpCpmtmp HApmtmp HOoApBpMtmp Hincl); apply HT.
}
try clear HOoApBpCpM1. try clear HOoApBpCpM2. try clear HOoApBpCpM3. try clear HOoApBpCpm4. try clear HOoApBpCpm3. try clear HOoApBpCpm2. try clear HOoApBpCpm1. 

assert(HApCpM : rk(Ap :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApCpeq HApCpM2).
assert(HApCpm : rk(Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HApCpeq HApCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApCp *)
(* dans la couche 0 *)
Lemma LOoABApCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 4).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 4) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCpmtmp : rk(Oo :: A :: B :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCpeq HOoABCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 4 4 HOoABCpmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApCpabM : rk(Oo :: A :: B :: Ap :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabm : rk(Oo :: A :: B :: Ap :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABApCpabeq HOoABApCpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApCp *)
(* dans la couche 0 *)
Lemma LOoABApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ABab requis par la preuve de (?)OoABApab pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoABApabM3 : rk(Oo :: A :: B :: Ap :: ab :: nil) <= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: nil) (Oo :: A :: Ap :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (A :: B :: ab :: nil) (A :: nil) 2 2 1 HOoAApMtmp HABabMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabm2 : rk(Oo :: A :: B :: Ap :: ab :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabm3 : rk(Oo :: A :: B :: Ap :: ab :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApabM : rk(Oo :: A :: B :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApabm : rk(Oo :: A :: B :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoABApabeq HOoABApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCp requis par la preuve de (?)ABApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpm2 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpm3 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpm3 : rk(A :: B :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApCpeq HOoABApCpm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpmtmp;try rewrite HT2 in HOoABApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABApCpm4 : rk(A :: B :: Ap :: Cp :: nil) >= 4).
{
	try assert(HOoABApabeq : rk(Oo :: A :: B :: Ap :: ab :: nil) = 3) by (apply LOoABApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApabMtmp : rk(Oo :: A :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoABApabeq HOoABApabM3).
	try assert(HOoABApCpabeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) = 4) by (apply LOoABApCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApCpabmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABApCpabeq HOoABApCpabm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: nil) (A :: B :: Ap :: Cp :: Oo :: A :: B :: Ap :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Cp :: Oo :: A :: B :: Ap :: ab :: nil) ((A :: B :: Ap :: Cp :: nil) ++ (Oo :: A :: B :: Ap :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabmtmp;try rewrite HT2 in HOoABApCpabmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: ab :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABApCpabmtmp HABApmtmp HOoABApabMtmp Hincl);apply HT.
}


assert(HABApCpM : rk(A :: B :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpm : rk(A :: B :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HABApCpeq HABApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpm3 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpm4 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HABCApCpM : rk(A :: B :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpm : rk(A :: B :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HABCApCpeq HABCApCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBpCp *)
(* dans la couche 0 *)
Lemma LOoABBpCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpCpab requis par la preuve de (?)OoABBpCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpCpab requis par la preuve de (?)OoABBpCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpab requis par la preuve de (?)OoABBpCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpab requis par la preuve de (?)OoABCApBpCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpCpab requis par la preuve de (?)OoABBpCpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpCpabm2 : rk(Oo :: A :: B :: Bp :: Cp :: ab :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpCpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabeq HOoABCApBpCpabm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: Cp :: ab :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabmtmp;try rewrite HT2 in HOoABCApBpCpabmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil) (nil) 4 0 2 HOoABCApBpCpabmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoABCApBpCpabM1. try clear HOoABCApBpCpabM2. try clear HOoABCApBpCpabM3. try clear HOoABCApBpCpabm4. try clear HOoABCApBpCpabm3. try clear HOoABCApBpCpabm2. try clear HOoABCApBpCpabm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpCpabm3 : rk(Oo :: A :: B :: Bp :: Cp :: ab :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpCpabm4 : rk(Oo :: A :: B :: Bp :: Cp :: ab :: nil) >= 4).
{
	try assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 4) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCpmtmp : rk(Oo :: A :: B :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCpeq HOoABCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil) 4 4 HOoABCpmtmp Hcomp Hincl);apply HT.
}


assert(HOoABBpCpabM : rk(Oo :: A :: B :: Bp :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpCpabm : rk(Oo :: A :: B :: Bp :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABBpCpabeq HOoABBpCpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBpCp *)
(* dans constructLemma(), requis par LOoABBpab *)
(* dans la couche 0 *)
Lemma LABab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HABabM : rk(A :: B :: ab ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABabeq HABabM3).
assert(HABabm : rk(A :: B :: ab ::  nil) >= 1) by (solve_hyps_min HABabeq HABabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpab requis par la preuve de (?)OoABBpab pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpab requis par la preuve de (?)OoABBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)OoABBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)OoABCApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpab requis par la preuve de (?)OoABBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpabm2 : rk(Oo :: A :: B :: Bp :: ab :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: ab :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabmtmp;try rewrite HT2 in HOoABCApBpabmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ab :: nil) (nil) 4 0 2 HOoABCApBpabmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpabm3 : rk(Oo :: A :: B :: Bp :: ab :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ab :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoABBpabM3 : rk(Oo :: A :: B :: Bp :: ab :: nil) <= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: Bp :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: ab :: nil) (Oo :: B :: Bp :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: A :: B :: ab :: nil) ((Oo :: B :: Bp :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (A :: B :: ab :: nil) (B :: nil) 2 2 1 HOoBBpMtmp HABabMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoABBpabM : rk(Oo :: A :: B :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpabm : rk(Oo :: A :: B :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABBpabeq HOoABBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpCp requis par la preuve de (?)BBpCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpCp requis par la preuve de (?)BBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCp requis par la preuve de (?)OoBBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpCp requis par la preuve de (?)OoBBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCp requis par la preuve de (?)OoBCApBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpm4 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpCpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCp requis par la preuve de (?)OoBBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpCpm2 : rk(Oo :: B :: Bp :: Cp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpCpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoBCApBpCpeq HOoBCApBpCpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (C :: Ap :: Oo :: B :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: Cp :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpmtmp;try rewrite HT2 in HOoBCApBpCpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: Cp :: nil) (nil) 4 0 2 HOoBCApBpCpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApBpCpM1. try clear HOoBCApBpCpM2. try clear HOoBCApBpCpM3. try clear HOoBCApBpCpm4. try clear HOoBCApBpCpm3. try clear HOoBCApBpCpm2. try clear HOoBCApBpCpm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBBpCpM3 : rk(Oo :: B :: Bp :: Cp :: nil) <= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: nil) (Oo :: B :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Cp :: nil) ((Oo :: B :: Bp :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (Cp :: nil) (nil) 2 1 0 HOoBBpMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpCp requis par la preuve de (?)BBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp ::  de rang :  2 et 3 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBBpCpm2 : rk(B :: Bp :: Cp :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpCpmtmp : rk(Oo :: B :: Bp :: Cp :: nil) >= 2) by (solve_hyps_min HOoBBpCpeq HOoBBpCpm2).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: nil) (Oo :: B :: Bp :: B :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: Bp :: Cp :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpmtmp;try rewrite HT2 in HOoBBpCpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: Bp :: Cp :: nil) (B :: Bp :: nil) 2 2 2 HOoBBpCpmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBBpCpM1. try clear HOoBBpCpM2. try clear HOoBBpCpM3. try clear HOoBBpCpm4. try clear HOoBBpCpm3. try clear HOoBBpCpm2. try clear HOoBBpCpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBBpCpm3 : rk(B :: Bp :: Cp :: nil) >= 3).
{
	try assert(HOoABBpabeq : rk(Oo :: A :: B :: Bp :: ab :: nil) = 3) by (apply LOoABBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABBpabMtmp : rk(Oo :: A :: B :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoABBpabeq HOoABBpabM3).
	try assert(HOoABBpCpabeq : rk(Oo :: A :: B :: Bp :: Cp :: ab :: nil) = 4) by (apply LOoABBpCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABBpCpabmtmp : rk(Oo :: A :: B :: Bp :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABBpCpabeq HOoABBpCpabm4).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (B :: Bp :: Cp :: nil) (Oo :: A :: B :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: Cp :: ab :: nil) (B :: Bp :: Cp :: Oo :: A :: B :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Cp :: Oo :: A :: B :: Bp :: ab :: nil) ((B :: Bp :: Cp :: nil) ++ (Oo :: A :: B :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpCpabmtmp;try rewrite HT2 in HOoABBpCpabmtmp.
	assert(HT := rule_2 (B :: Bp :: Cp :: nil) (Oo :: A :: B :: Bp :: ab :: nil) (B :: Bp :: nil) 4 2 3 HOoABBpCpabmtmp HBBpmtmp HOoABBpabMtmp Hincl);apply HT.
}


assert(HBBpCpM : rk(B :: Bp :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBBpCpeq HBBpCpM3).
assert(HBBpCpm : rk(B :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HBBpCpeq HBBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCp requis par la preuve de (?)OoBCApBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpm4 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpCpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApBpCpM : rk(Oo :: B :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpCpm : rk(Oo :: B :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoBCApBpCpeq HOoBCApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HabM : rk(ab ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Habeq HabM1).
assert(Habm : rk(ab ::  nil) >= 1) by (solve_hyps_min Habeq Habm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAab *)
(* dans la couche 0 *)
Lemma LACApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Bp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpab requis par la preuve de (?)ACApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpab requis par la preuve de (?)ACApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)ACApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)OoABCApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpab requis par la preuve de (?)ACApBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApBpabm2 : rk(A :: C :: Ap :: Bp :: ab :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: Bp :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabmtmp;try rewrite HT2 in HOoABCApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: Bp :: ab :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApBpabmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApBpabm3 : rk(A :: C :: Ap :: Bp :: ab :: nil) >= 3).
{
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: Bp :: ab :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApBpabm4 : rk(A :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	try assert(HACApBpeq : rk(A :: C :: Ap :: Bp :: nil) = 4) by (apply LACApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApBpmtmp : rk(A :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACApBpeq HACApBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: ab :: nil) 4 4 HACApBpmtmp Hcomp Hincl);apply HT.
}


assert(HACApBpabM : rk(A :: C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpabm : rk(A :: C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HACApBpabeq HACApBpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAab *)
(* dans constructLemma(), requis par LCApBpab *)
(* dans constructLemma(), requis par LOoBCApBpab *)
(* dans la couche 0 *)
Lemma LOoABCApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)OoABCApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpabM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpab requis par la preuve de (?)OoBCApBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabm4 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpabeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LOoABCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabmtmp;try rewrite HT2 in HOoABCApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpabmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApBpabM : rk(Oo :: B :: C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpabm : rk(Oo :: B :: C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoBCApBpabeq HOoBCApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApBpab requis par la preuve de (?)CApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApBpab requis par la preuve de (?)CApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApBpab requis par la preuve de (?)BCApBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApBpabm3 : rk(B :: C :: Ap :: Bp :: ab :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpabeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LOoABCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Bp :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabmtmp;try rewrite HT2 in HOoABCApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Bp :: ab :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApBpab requis par la preuve de (?)CApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApBpab requis par la preuve de (?)CApBpab pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpab requis par la preuve de (?)CApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HCApBpabM3 : rk(C :: Ap :: Bp :: ab :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: ab :: nil) (C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Bp :: ab :: nil) ((C :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HCMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Bp :: ab ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApBpabm2 : rk(C :: Ap :: Bp :: ab :: nil) >= 2).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApBpabmtmp : rk(B :: C :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HBCApBpabeq HBCApBpabm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Bp :: ab :: nil) (B :: Ap :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: Bp :: ab :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApBpabmtmp;try rewrite HT2 in HBCApBpabmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: Bp :: ab :: nil) (Ap :: nil) 3 1 2 HBCApBpabmtmp HApmtmp HBApMtmp Hincl); apply HT.
}
try clear HBCApBpabM1. try clear HBCApBpabM2. try clear HBCApBpabM3. try clear HBCApBpabm4. try clear HBCApBpabm3. try clear HBCApBpabm2. try clear HBCApBpabm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpabm3 : rk(C :: Ap :: Bp :: ab :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HOoBCApBpabeq : rk(Oo :: B :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LOoBCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCApBpabmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoBCApBpabeq HOoBCApBpabm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: B :: Bp :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Ap :: Bp :: ab :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabmtmp;try rewrite HT2 in HOoBCApBpabmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Ap :: Bp :: ab :: nil) (Bp :: nil) 4 1 2 HOoBCApBpabmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBCApBpabM1. try clear HOoBCApBpabM2. try clear HOoBCApBpabM3. try clear HOoBCApBpabm4. try clear HOoBCApBpabm3. try clear HOoBCApBpabm2. try clear HOoBCApBpabm1. 

assert(HCApBpabM : rk(C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpabm : rk(C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HCApBpabeq HCApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aab requis par la preuve de (?)Aab pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAabm2 : rk(A :: ab :: nil) >= 2).
{
	try assert(HCApBpabeq : rk(C :: Ap :: Bp :: ab :: nil) = 3) by (apply LCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApBpabMtmp : rk(C :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HCApBpabeq HCApBpabM3).
	try assert(HACApBpabeq : rk(A :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LACApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApBpabmtmp : rk(A :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HACApBpabeq HACApBpabm4).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: ab :: nil) (C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: ab :: nil) (A :: ab :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: C :: Ap :: Bp :: ab :: nil) ((A :: ab :: nil) ++ (C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpabmtmp;try rewrite HT2 in HACApBpabmtmp.
	assert(HT := rule_2 (A :: ab :: nil) (C :: Ap :: Bp :: ab :: nil) (ab :: nil) 4 1 3 HACApBpabmtmp Habmtmp HCApBpabMtmp Hincl);apply HT.
}


assert(HAabM : rk(A :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAabeq HAabM2).
assert(HAabm : rk(A :: ab ::  nil) >= 1) by (solve_hyps_min HAabeq HAabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBab *)
(* dans constructLemma(), requis par LBApBpab *)
(* dans constructLemma(), requis par LOoBApBpab *)
(* dans la couche 0 *)
Lemma LApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HApBpabM : rk(Ap :: Bp :: ab ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpabeq HApBpabM3).
assert(HApBpabm : rk(Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HApBpabeq HApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpab requis par la preuve de (?)OoBApBpab pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoBApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoABApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoABApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpab requis par la preuve de (?)OoBApBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpabm3 : rk(Oo :: B :: Ap :: Bp :: ab :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoABApBpabeq HOoABApBpabm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabmtmp;try rewrite HT2 in HOoABApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpabmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoBApBpabM3 : rk(Oo :: B :: Ap :: Bp :: ab :: nil) <= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HApBpabeq : rk(Ap :: Bp :: ab :: nil) = 2) by (apply LApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: nil) (Oo :: B :: Bp :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Ap :: Bp :: ab :: nil) ((Oo :: B :: Bp :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: nil) (Bp :: nil) 2 2 1 HOoBBpMtmp HApBpabMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoBApBpabM : rk(Oo :: B :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpabm : rk(Oo :: B :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoBApBpabeq HOoBApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBApBpabM3 : rk(B :: Ap :: Bp :: ab :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HApBpabeq : rk(Ap :: Bp :: ab :: nil) = 2) by (apply LApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: ab :: nil) (B :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Bp :: ab :: nil) ((B :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HBMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApBpabm2 : rk(B :: Ap :: Bp :: ab :: nil) >= 2).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: Bp :: ab :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBApBpabm3 : rk(B :: Ap :: Bp :: ab :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HOoBApBpabeq : rk(Oo :: B :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoBApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApBpabmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoBApBpabeq HOoBApBpabm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: nil) (Oo :: B :: Bp :: B :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: Ap :: Bp :: ab :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabmtmp;try rewrite HT2 in HOoBApBpabmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: Ap :: Bp :: ab :: nil) (B :: Bp :: nil) 3 2 2 HOoBApBpabmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}


assert(HBApBpabM : rk(B :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApBpabm : rk(B :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HBApBpabeq HBApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bab requis par la preuve de (?)Bab pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBabm2 : rk(B :: ab :: nil) >= 2).
{
	try assert(HApBpabeq : rk(Ap :: Bp :: ab :: nil) = 2) by (apply LApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	try assert(HBApBpabeq : rk(B :: Ap :: Bp :: ab :: nil) = 3) by (apply LBApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApBpabmtmp : rk(B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HBApBpabeq HBApBpabm3).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (B :: ab :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: ab :: nil) (B :: ab :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: Ap :: Bp :: ab :: nil) ((B :: ab :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApBpabmtmp;try rewrite HT2 in HBApBpabmtmp.
	assert(HT := rule_2 (B :: ab :: nil) (Ap :: Bp :: ab :: nil) (ab :: nil) 3 1 2 HBApBpabmtmp Habmtmp HApBpabMtmp Hincl);apply HT.
}


assert(HBabM : rk(B :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBabeq HBabM2).
assert(HBabm : rk(B :: ab ::  nil) >= 1) by (solve_hyps_min HBabeq HBabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApab *)
(* dans la couche 0 *)
Lemma LABApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABApab requis par la preuve de (?)ABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABApab requis par la preuve de (?)ABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApab requis par la preuve de (?)ABApab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABApabM3 : rk(A :: B :: Ap :: ab :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: nil) (Ap :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: ab :: nil) ((Ap :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HApMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApabm2 : rk(A :: B :: Ap :: ab :: nil) >= 2).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (A :: B :: Ap :: ab :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApabm3 : rk(A :: B :: Ap :: ab :: nil) >= 3).
{
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}


assert(HABApabM : rk(A :: B :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApabm : rk(A :: B :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HABApabeq HABApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Apab requis par la preuve de (?)Apab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab ::  de rang :  3 et 3 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabm2 : rk(Ap :: ab :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HABApabeq : rk(A :: B :: Ap :: ab :: nil) = 3) by (apply LABApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApabmtmp : rk(A :: B :: Ap :: ab :: nil) >= 3) by (solve_hyps_min HABApabeq HABApabm3).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: nil) (A :: B :: ab :: Ap :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabmtmp;try rewrite HT2 in HABApabmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: nil) (ab :: nil) 3 1 2 HABApabmtmp Habmtmp HABabMtmp Hincl); apply HT.
}


assert(HApabM : rk(Ap :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApabeq HApabM2).
assert(HApabm : rk(Ap :: ab ::  nil) >= 1) by (solve_hyps_min HApabeq HApabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApab *)
(* dans la couche 0 *)
Lemma LOoApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpab requis par la preuve de (?)OoApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoABApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoABApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApBpab requis par la preuve de (?)OoApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpab requis par la preuve de (?)OoApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApBpabM3 : rk(Oo :: Ap :: Bp :: ab :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	try assert(HApBpabeq : rk(Ap :: Bp :: ab :: nil) = 2) by (apply LApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: ab :: nil) (Oo :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: ab :: nil) ((Oo :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HOoMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApBpabm2 : rk(Oo :: Ap :: Bp :: ab :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoABApBpabeq HOoABApBpabm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: Bp :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabmtmp;try rewrite HT2 in HOoABApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Bp :: ab :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApBpabmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoApBpabm3 : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HOoBApBpabeq : rk(Oo :: B :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoBApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApBpabmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoBApBpabeq HOoBApBpabm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: nil) (Oo :: B :: Bp :: Oo :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Ap :: Bp :: ab :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabmtmp;try rewrite HT2 in HOoBApBpabmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: ab :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBApBpabmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


assert(HOoApBpabM : rk(Oo :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpabm : rk(Oo :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoApBpabeq HOoApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApab requis par la preuve de (?)OoApab pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApab requis par la preuve de (?)OoApab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab ::  de rang :  3 et 3 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApabm2 : rk(Oo :: Ap :: ab :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABApabeq : rk(Oo :: A :: B :: Ap :: ab :: nil) = 3) by (apply LOoABApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApabmtmp : rk(Oo :: A :: B :: Ap :: ab :: nil) >= 3) by (solve_hyps_min HOoABApabeq HOoABApabm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabmtmp;try rewrite HT2 in HOoABApabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ab :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApabmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApabm3 : rk(Oo :: Ap :: ab :: nil) >= 3).
{
	try assert(HApBpabeq : rk(Ap :: Bp :: ab :: nil) = 2) by (apply LApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	try assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	try assert(HApabeq : rk(Ap :: ab :: nil) = 2) by (apply LApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApabmtmp : rk(Ap :: ab :: nil) >= 2) by (solve_hyps_min HApabeq HApabm2).
	assert(Hincl : incl (Ap :: ab :: nil) (list_inter (Oo :: Ap :: ab :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: ab :: nil) (Oo :: Ap :: ab :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: ab :: Ap :: Bp :: ab :: nil) ((Oo :: Ap :: ab :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpabmtmp;try rewrite HT2 in HOoApBpabmtmp.
	assert(HT := rule_2 (Oo :: Ap :: ab :: nil) (Ap :: Bp :: ab :: nil) (Ap :: ab :: nil) 3 2 2 HOoApBpabmtmp HApabmtmp HApBpabMtmp Hincl);apply HT.
}
try clear HApabM1. try clear HApabM2. try clear HApabM3. try clear HApabm4. try clear HApabm3. try clear HApabm2. try clear HApabm1. 

assert(HOoApabM : rk(Oo :: Ap :: ab ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApabeq HOoApabM3).
assert(HOoApabm : rk(Oo :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoApabeq HOoApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpab requis par la preuve de (?)OoABCApBpCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpCpabM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpabm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpabeq HOoABCApBpCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HacM : rk(ac ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Haceq HacM1).
assert(Hacm : rk(ac ::  nil) >= 1) by (solve_hyps_min Haceq Hacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAac *)
(* dans constructLemma(), requis par LAApCpac *)
(* dans la couche 0 *)
Lemma LABApCpabac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabac requis par la preuve de (?)ABApCpabac pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)ABApCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoABApCpabac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoABApCpabac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabac requis par la preuve de (?)ABApCpabac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ac ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpabacm3 : rk(A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabacmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 3) by (solve_hyps_min HOoABApCpabaceq HOoABApCpabacm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabacmtmp;try rewrite HT2 in HOoABApCpabacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpabacmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApCpabacM1. try clear HOoABApCpabacM2. try clear HOoABApCpabacM3. try clear HOoABApCpabacm4. try clear HOoABApCpabacm3. try clear HOoABApCpabacm2. try clear HOoABApCpabacm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabacm4 : rk(A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 4).
{
	try assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}


assert(HABApCpabacM : rk(A :: B :: Ap :: Cp :: ab :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabacm : rk(A :: B :: Ap :: Cp :: ab :: ac ::  nil) >= 1) by (solve_hyps_min HABApCpabaceq HABApCpabacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCpac requis par la preuve de (?)AApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCpac requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpac requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacm3 : rk(A :: B :: C :: Ap :: Cp :: ac :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpacm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpacmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApCpac requis par la preuve de (?)AApCpac pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HAApCpacM3 : rk(A :: Ap :: Cp :: ac :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ac :: nil) (A :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Cp :: ac :: nil) ((A :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HAMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApCpacm2 : rk(A :: Ap :: Cp :: ac :: nil) >= 2).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApCpacmtmp : rk(A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HABCApCpaceq HABCApCpacm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: ac :: nil) (B :: C :: Ap :: A :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Cp :: ac :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpacmtmp;try rewrite HT2 in HABCApCpacmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Cp :: ac :: nil) (Ap :: nil) 4 1 3 HABCApCpacmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}
try clear HABCApCpacM1. try clear HABCApCpacM2. try clear HABCApCpacM3. try clear HABCApCpacm4. try clear HABCApCpacm3. try clear HABCApCpacm2. try clear HABCApCpacm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApCpacm3 : rk(A :: Ap :: Cp :: ac :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HABApCpabaceq : rk(A :: B :: Ap :: Cp :: ab :: ac :: nil) = 4) by (apply LABApCpabac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApCpabacmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HABApCpabaceq HABApCpabacm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: nil) (A :: B :: ab :: A :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Cp :: ac :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacmtmp;try rewrite HT2 in HABApCpabacmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Cp :: ac :: nil) (A :: nil) 4 1 2 HABApCpabacmtmp HAmtmp HABabMtmp Hincl); apply HT.
}


assert(HAApCpacM : rk(A :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpacm : rk(A :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HAApCpaceq HAApCpacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAac *)
(* dans la couche 0 *)
Lemma LApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HApCpacM : rk(Ap :: Cp :: ac ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpaceq HApCpacM3).
assert(HApCpacm : rk(Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HApCpaceq HApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aac requis par la preuve de (?)Aac pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAacm2 : rk(A :: ac :: nil) >= 2).
{
	try assert(HApCpaceq : rk(Ap :: Cp :: ac :: nil) = 2) by (apply LApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	try assert(HAApCpaceq : rk(A :: Ap :: Cp :: ac :: nil) = 3) by (apply LAApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApCpacmtmp : rk(A :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HAApCpaceq HAApCpacm3).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ac :: nil) (A :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: Ap :: Cp :: ac :: nil) ((A :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpacmtmp;try rewrite HT2 in HAApCpacmtmp.
	assert(HT := rule_2 (A :: ac :: nil) (Ap :: Cp :: ac :: nil) (ac :: nil) 3 1 2 HAApCpacmtmp Hacmtmp HApCpacMtmp Hincl);apply HT.
}


assert(HAacM : rk(A :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAaceq HAacM2).
assert(HAacm : rk(A :: ac ::  nil) >= 1) by (solve_hyps_min HAaceq HAacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCac *)
(* dans constructLemma(), requis par LCApCpac *)
(* dans la couche 0 *)
Lemma LOoCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpac requis par la preuve de (?)OoCApCpac pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpac requis par la preuve de (?)OoCApCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpacm3 : rk(Oo :: C :: Ap :: Cp :: ac :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpacmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoCApCpacM3 : rk(Oo :: C :: Ap :: Cp :: ac :: nil) <= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HApCpaceq : rk(Ap :: Cp :: ac :: nil) = 2) by (apply LApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: nil) (Oo :: C :: Cp :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: ac :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: nil) (Cp :: nil) 2 2 1 HOoCCpMtmp HApCpacMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoCApCpacM : rk(Oo :: C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApCpacm : rk(Oo :: C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoCApCpaceq HOoCApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpac requis par la preuve de (?)CApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)BCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpac requis par la preuve de (?)BCApCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpacm3 : rk(B :: C :: Ap :: Cp :: ac :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApCpacmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCApCpacM3 : rk(C :: Ap :: Cp :: ac :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HApCpaceq : rk(Ap :: Cp :: ac :: nil) = 2) by (apply LApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Cp :: ac :: nil) (C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Cp :: ac :: nil) ((C :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HCMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: ac ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApCpacm2 : rk(C :: Ap :: Cp :: ac :: nil) >= 2).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApCpacmtmp : rk(B :: C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HBCApCpaceq HBCApCpacm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: ac :: nil) (B :: Ap :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: Cp :: ac :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpacmtmp;try rewrite HT2 in HBCApCpacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: Cp :: ac :: nil) (Ap :: nil) 3 1 2 HBCApCpacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}
try clear HBCApCpacM1. try clear HBCApCpacM2. try clear HBCApCpacM3. try clear HBCApCpacm4. try clear HBCApCpacm3. try clear HBCApCpacm2. try clear HBCApCpacm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ac ::  de rang :  3 et 3 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HCApCpacm3 : rk(C :: Ap :: Cp :: ac :: nil) >= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HOoCApCpaceq : rk(Oo :: C :: Ap :: Cp :: ac :: nil) = 3) by (apply LOoCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCApCpacmtmp : rk(Oo :: C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoCApCpaceq HOoCApCpacm3).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: nil) (Oo :: C :: Cp :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: C :: Ap :: Cp :: ac :: nil) ((Oo :: C :: Cp :: nil) ++ (C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpacmtmp;try rewrite HT2 in HOoCApCpacmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (C :: Ap :: Cp :: ac :: nil) (C :: Cp :: nil) 3 2 2 HOoCApCpacmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}


assert(HCApCpacM : rk(C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApCpacm : rk(C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HCApCpaceq HCApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cac requis par la preuve de (?)Cac pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCacm2 : rk(C :: ac :: nil) >= 2).
{
	try assert(HApCpaceq : rk(Ap :: Cp :: ac :: nil) = 2) by (apply LApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	try assert(HCApCpaceq : rk(C :: Ap :: Cp :: ac :: nil) = 3) by (apply LCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApCpacmtmp : rk(C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HCApCpaceq HCApCpacm3).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (C :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Cp :: ac :: nil) (C :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: Ap :: Cp :: ac :: nil) ((C :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApCpacmtmp;try rewrite HT2 in HCApCpacmtmp.
	assert(HT := rule_2 (C :: ac :: nil) (Ap :: Cp :: ac :: nil) (ac :: nil) 3 1 2 HCApCpacmtmp Hacmtmp HApCpacMtmp Hincl);apply HT.
}


assert(HCacM : rk(C :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCaceq HCacM2).
assert(HCacm : rk(C :: ac ::  nil) >= 1) by (solve_hyps_min HCaceq HCacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HACacM : rk(A :: C :: ac ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACaceq HACacM3).
assert(HACacm : rk(A :: C :: ac ::  nil) >= 1) by (solve_hyps_min HACaceq HACacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApac *)
(* dans la couche 0 *)
Lemma LACApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApac requis par la preuve de (?)ACApac pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApac requis par la preuve de (?)ACApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApac requis par la preuve de (?)ABCApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApac requis par la preuve de (?)OoABCApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApac requis par la preuve de (?)ABCApac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacm3 : rk(A :: B :: C :: Ap :: ac :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApaceq HOoABCApacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacmtmp;try rewrite HT2 in HOoABCApacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApacM1. try clear HOoABCApacM2. try clear HOoABCApacM3. try clear HOoABCApacm4. try clear HOoABCApacm3. try clear HOoABCApacm2. try clear HOoABCApacm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApac requis par la preuve de (?)ACApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApac requis par la preuve de (?)ACApac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACApacM3 : rk(A :: C :: Ap :: ac :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: nil) (Ap :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: ac :: nil) ((Ap :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: ac :: nil) (nil) 1 2 0 HApMtmp HACacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacm2 : rk(A :: C :: Ap :: ac :: nil) >= 2).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacmtmp : rk(A :: B :: C :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HABCApaceq HABCApacm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: nil) (B :: Ap :: A :: C :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacmtmp;try rewrite HT2 in HABCApacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: nil) (Ap :: nil) 3 1 2 HABCApacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}
try clear HABCApacM1. try clear HABCApacM2. try clear HABCApacM3. try clear HABCApacm4. try clear HABCApacm3. try clear HABCApacm2. try clear HABCApacm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacm3 : rk(A :: C :: Ap :: ac :: nil) >= 3).
{
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}


assert(HACApacM : rk(A :: C :: Ap :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApacm : rk(A :: C :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HACApaceq HACApacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Apac requis par la preuve de (?)Apac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac ::  de rang :  3 et 3 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacm2 : rk(Ap :: ac :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	try assert(HACApaceq : rk(A :: C :: Ap :: ac :: nil) = 3) by (apply LACApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApacmtmp : rk(A :: C :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HACApaceq HACApacm3).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: nil) (A :: C :: ac :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacmtmp;try rewrite HT2 in HACApacmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: nil) (ac :: nil) 3 1 2 HACApacmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}


assert(HApacM : rk(Ap :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApaceq HApacM2).
assert(HApacm : rk(Ap :: ac ::  nil) >= 1) by (solve_hyps_min HApaceq HApacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApac *)
(* dans la couche 0 *)
Lemma LOoApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCpac requis par la preuve de (?)OoApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpac requis par la preuve de (?)OoApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpac requis par la preuve de (?)OoABApCpac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpac requis par la preuve de (?)OoABApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpacm2 : rk(Oo :: A :: B :: Ap :: Cp :: ac :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpacm3 : rk(Oo :: A :: B :: Ap :: Cp :: ac :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApCpac requis par la preuve de (?)OoApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpac requis par la preuve de (?)OoApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApCpacM3 : rk(Oo :: Ap :: Cp :: ac :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	try assert(HApCpaceq : rk(Ap :: Cp :: ac :: nil) = 2) by (apply LApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: ac :: nil) (Oo :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: ac :: nil) ((Oo :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HOoMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ac ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApCpacm2 : rk(Oo :: Ap :: Cp :: ac :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpacmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoABApCpaceq HOoABApCpacm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ac :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: Cp :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpacmtmp;try rewrite HT2 in HOoABApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Cp :: ac :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApCpacmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApCpacM1. try clear HOoABApCpacM2. try clear HOoABApCpacM3. try clear HOoABApCpacm4. try clear HOoABApCpacm3. try clear HOoABApCpacm2. try clear HOoABApCpacm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ac ::  de rang :  3 et 3 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoApCpacm3 : rk(Oo :: Ap :: Cp :: ac :: nil) >= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HOoCApCpaceq : rk(Oo :: C :: Ap :: Cp :: ac :: nil) = 3) by (apply LOoCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCApCpacmtmp : rk(Oo :: C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoCApCpaceq HOoCApCpacm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: nil) (Oo :: C :: Cp :: Oo :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: Ap :: Cp :: ac :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpacmtmp;try rewrite HT2 in HOoCApCpacmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: Ap :: Cp :: ac :: nil) (Oo :: Cp :: nil) 3 2 2 HOoCApCpacmtmp HOoCpmtmp HOoCCpMtmp Hincl); apply HT.
}


assert(HOoApCpacM : rk(Oo :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpacm : rk(Oo :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoApCpaceq HOoApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApac requis par la preuve de (?)OoApac pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABApac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApacm2 : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApacm3 : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApac requis par la preuve de (?)OoApac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApacm2 : rk(Oo :: Ap :: ac :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApacmtmp : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoABApaceq HOoABApacm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacmtmp;try rewrite HT2 in HOoABApacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ac :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApacmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApacM1. try clear HOoABApacM2. try clear HOoABApacM3. try clear HOoABApacm4. try clear HOoABApacm3. try clear HOoABApacm2. try clear HOoABApacm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApacm3 : rk(Oo :: Ap :: ac :: nil) >= 3).
{
	try assert(HApCpaceq : rk(Ap :: Cp :: ac :: nil) = 2) by (apply LApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	try assert(HOoApCpaceq : rk(Oo :: Ap :: Cp :: ac :: nil) = 3) by (apply LOoApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApCpacmtmp : rk(Oo :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoApCpaceq HOoApCpacm3).
	try assert(HApaceq : rk(Ap :: ac :: nil) = 2) by (apply LApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApacmtmp : rk(Ap :: ac :: nil) >= 2) by (solve_hyps_min HApaceq HApacm2).
	assert(Hincl : incl (Ap :: ac :: nil) (list_inter (Oo :: Ap :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: ac :: nil) (Oo :: Ap :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: ac :: Ap :: Cp :: ac :: nil) ((Oo :: Ap :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApCpacmtmp;try rewrite HT2 in HOoApCpacmtmp.
	assert(HT := rule_2 (Oo :: Ap :: ac :: nil) (Ap :: Cp :: ac :: nil) (Ap :: ac :: nil) 3 2 2 HOoApCpacmtmp HApacmtmp HApCpacMtmp Hincl);apply HT.
}
try clear HApacM1. try clear HApacM2. try clear HApacM3. try clear HApacm4. try clear HApacm3. try clear HApacm2. try clear HApacm1. 

assert(HOoApacM : rk(Oo :: Ap :: ac ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApaceq HOoApacM3).
assert(HOoApacm : rk(Oo :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HOoApaceq HOoApacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApac requis par la preuve de (?)OoABCApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApacM : rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacm : rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApaceq HOoABCApacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApCpac *)
(* dans la couche 0 *)
Lemma LOoABCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApCpacM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCpac requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpac requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacm3 : rk(A :: B :: C :: Ap :: Cp :: ac :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApCpaceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) = 4) by (apply LOoABCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpacm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApCpaceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) = 4) by (apply LOoABCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpacmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HABCApCpacM : rk(A :: B :: C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpacm : rk(A :: B :: C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HABCApCpaceq HABCApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(bc ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HbcM : rk(bc ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Hbceq HbcM1).
assert(Hbcm : rk(bc ::  nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbc *)
(* dans la couche 0 *)
Lemma LBBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BpCpbc requis par la preuve de (?)BBpCpbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HBBpCpbcM3 : rk(B :: Bp :: Cp :: bc :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: bc :: nil) (B :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Cp :: bc :: nil) ((B :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Bp :: Cp :: bc :: nil) (nil) 1 2 0 HBMtmp HBpCpbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpCpbcm2 : rk(B :: Bp :: Cp :: bc :: nil) >= 2).
{
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: Cp :: bc :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpCpbcm3 : rk(B :: Bp :: Cp :: bc :: nil) >= 3).
{
	try assert(HBBpCpeq : rk(B :: Bp :: Cp :: nil) = 3) by (apply LBBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpCpmtmp : rk(B :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HBBpCpeq HBBpCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: bc :: nil) 3 3 HBBpCpmtmp Hcomp Hincl);apply HT.
}


assert(HBBpCpbcM : rk(B :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpbcm : rk(B :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HBBpCpbceq HBBpCpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbc *)
(* dans la couche 0 *)
Lemma LBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HBpCpbcM : rk(Bp :: Cp :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpCpbceq HBpCpbcM3).
assert(HBpCpbcm : rk(Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HBpCpbceq HBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bbc requis par la preuve de (?)Bbc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBbcm2 : rk(B :: bc :: nil) >= 2).
{
	try assert(HBpCpbceq : rk(Bp :: Cp :: bc :: nil) = 2) by (apply LBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	try assert(HBBpCpbceq : rk(B :: Bp :: Cp :: bc :: nil) = 3) by (apply LBBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpCpbcmtmp : rk(B :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HBBpCpbceq HBBpCpbcm3).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: bc :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: bc :: nil) (B :: bc :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: Bp :: Cp :: bc :: nil) ((B :: bc :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpbcmtmp;try rewrite HT2 in HBBpCpbcmtmp.
	assert(HT := rule_2 (B :: bc :: nil) (Bp :: Cp :: bc :: nil) (bc :: nil) 3 1 2 HBBpCpbcmtmp Hbcmtmp HBpCpbcMtmp Hincl);apply HT.
}


assert(HBbcM : rk(B :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBbceq HBbcM2).
assert(HBbcm : rk(B :: bc ::  nil) >= 1) by (solve_hyps_min HBbceq HBbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCbc *)
(* dans constructLemma(), requis par LCBpCpbc *)
(* dans la couche 0 *)
Lemma LOoCBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpCpbc requis par la preuve de (?)OoCBpCpbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)OoCBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoABCApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpCpbc requis par la preuve de (?)OoCBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpCpbc requis par la preuve de (?)OoCBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpCpbcm2 : rk(Oo :: C :: Bp :: Cp :: bc :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: nil) (Oo :: nil) 4 1 3 HOoABCApBpCpbcmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApBpCpbcM1. try clear HOoABCApBpCpbcM2. try clear HOoABCApBpCpbcM3. try clear HOoABCApBpCpbcm4. try clear HOoABCApBpCpbcm3. try clear HOoABCApBpCpbcm2. try clear HOoABCApBpCpbcm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpCpbcm3 : rk(Oo :: C :: Bp :: Cp :: bc :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpCpbcmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoBCBpCpbceq HOoBCBpCpbcm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcmtmp;try rewrite HT2 in HOoBCBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpCpbcmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoCBpCpbcM3 : rk(Oo :: C :: Bp :: Cp :: bc :: nil) <= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HBpCpbceq : rk(Bp :: Cp :: bc :: nil) = 2) by (apply LBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: bc :: nil) (Oo :: C :: Cp :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Bp :: Cp :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (Bp :: Cp :: bc :: nil) (Cp :: nil) 2 2 1 HOoCCpMtmp HBpCpbcMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoCBpCpbcM : rk(Oo :: C :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpCpbcm : rk(Oo :: C :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoCBpCpbceq HOoCBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoABCApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCBpCpbcM3 : rk(C :: Bp :: Cp :: bc :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HBpCpbceq : rk(Bp :: Cp :: bc :: nil) = 2) by (apply LBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Cp :: bc :: nil) (C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Cp :: bc :: nil) ((C :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Bp :: Cp :: bc :: nil) (nil) 1 2 0 HCMtmp HBpCpbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpCpbcm2 : rk(C :: Bp :: Cp :: bc :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpCpbcmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoBCBpCpbceq HOoBCBpCpbcm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: B :: Bp :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: Cp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcmtmp;try rewrite HT2 in HOoBCBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: Cp :: bc :: nil) (Bp :: nil) 3 1 2 HOoBCBpCpbcmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: Cp :: bc ::  de rang :  3 et 3 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HCBpCpbcm3 : rk(C :: Bp :: Cp :: bc :: nil) >= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HOoCBpCpbceq : rk(Oo :: C :: Bp :: Cp :: bc :: nil) = 3) by (apply LOoCBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCBpCpbcmtmp : rk(Oo :: C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoCBpCpbceq HOoCBpCpbcm3).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: bc :: nil) (Oo :: C :: Cp :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: C :: Bp :: Cp :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpCpbcmtmp;try rewrite HT2 in HOoCBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (C :: Bp :: Cp :: bc :: nil) (C :: Cp :: nil) 3 2 2 HOoCBpCpbcmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}


assert(HCBpCpbcM : rk(C :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpCpbcm : rk(C :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HCBpCpbceq HCBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cbc requis par la preuve de (?)Cbc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HCbcm2 : rk(C :: bc :: nil) >= 2).
{
	try assert(HBpCpbceq : rk(Bp :: Cp :: bc :: nil) = 2) by (apply LBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	try assert(HCBpCpbceq : rk(C :: Bp :: Cp :: bc :: nil) = 3) by (apply LCBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCBpCpbcmtmp : rk(C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HCBpCpbceq HCBpCpbcm3).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (C :: bc :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Cp :: bc :: nil) (C :: bc :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: Bp :: Cp :: bc :: nil) ((C :: bc :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpCpbcmtmp;try rewrite HT2 in HCBpCpbcmtmp.
	assert(HT := rule_2 (C :: bc :: nil) (Bp :: Cp :: bc :: nil) (bc :: nil) 3 1 2 HCBpCpbcmtmp Hbcmtmp HBpCpbcMtmp Hincl);apply HT.
}


assert(HCbcM : rk(C :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCbceq HCbcM2).
assert(HCbcm : rk(C :: bc ::  nil) >= 1) by (solve_hyps_min HCbceq HCbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACbc *)
(* dans constructLemma(), requis par LABCbc *)
(* dans la couche 0 *)
Lemma LOoABCApbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbc requis par la preuve de (?)OoABCApbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApbcM : rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcm : rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApbceq HOoABCApbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoAp requis par la preuve de (?)ABCbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BCbc requis par la preuve de (?)ABCbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HABCbcM3 : rk(A :: B :: C :: bc :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: bc :: nil) (A :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: bc :: nil) ((A :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: C :: bc :: nil) (nil) 1 2 0 HAMtmp HBCbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap ::   de rang : 1 et 2 *)
assert(HABCbcm2 : rk(A :: B :: C :: bc :: nil) >= 2).
{
	assert(HOoApMtmp : rk(Oo :: Ap :: nil) <= 2) by (solve_hyps_max HOoApeq HOoApM2).
	try assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: nil) (A :: B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: Ap :: A :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: A :: B :: C :: bc :: nil) ((Oo :: Ap :: nil) ++ (A :: B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: Ap :: nil) (A :: B :: C :: bc :: nil) (nil) 4 0 2 HOoABCApbcmtmp Hmtmp HOoApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCbcm3 : rk(A :: B :: C :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: bc :: nil) (A :: nil) 4 1 2 HOoABCApbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HABCbcM : rk(A :: B :: C :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCbcm : rk(A :: B :: C :: bc ::  nil) >= 1) by (solve_hyps_min HABCbceq HABCbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACbc *)
(* dans la couche 0 *)
Lemma LBCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HBCbcM : rk(B :: C :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCbceq HBCbcM3).
assert(HBCbcm : rk(B :: C :: bc ::  nil) >= 1) by (solve_hyps_min HBCbceq HBCbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACbc requis par la preuve de (?)ACbc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACbc requis par la preuve de (?)ACbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACbcm2 : rk(A :: C :: bc :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: bc :: nil) (A :: nil) 4 1 3 HOoABCApbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACbcm3 : rk(A :: C :: bc :: nil) >= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	try assert(HABCbceq : rk(A :: B :: C :: bc :: nil) = 3) by (apply LABCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCbcmtmp : rk(A :: B :: C :: bc :: nil) >= 3) by (solve_hyps_min HABCbceq HABCbcm3).
	try assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (A :: C :: bc :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: bc :: nil) (A :: C :: bc :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: bc :: B :: C :: bc :: nil) ((A :: C :: bc :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCbcmtmp;try rewrite HT2 in HABCbcmtmp.
	assert(HT := rule_2 (A :: C :: bc :: nil) (B :: C :: bc :: nil) (C :: bc :: nil) 3 2 2 HABCbcmtmp HCbcmtmp HBCbcMtmp Hincl);apply HT.
}


assert(HACbcM : rk(A :: C :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACbceq HACbcM3).
assert(HACbcm : rk(A :: C :: bc ::  nil) >= 1) by (solve_hyps_min HACbceq HACbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpbc *)
(* dans constructLemma(), requis par LBCBpbc *)
(* dans la couche 0 *)
Lemma LOoBCBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbc requis par la preuve de (?)OoBCBpbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoBCBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoABCApBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbc requis par la preuve de (?)OoBCBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcm3 : rk(Oo :: B :: C :: Bp :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoBCBpbcM3 : rk(Oo :: B :: C :: Bp :: bc :: nil) <= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: nil) (Oo :: B :: Bp :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (B :: C :: bc :: nil) (B :: nil) 2 2 1 HOoBBpMtmp HBCbcMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoBCBpbcM : rk(Oo :: B :: C :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpbcm : rk(Oo :: B :: C :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCBpbceq HOoBCBpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Bp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBpbc requis par la preuve de (?)BCBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbc requis par la preuve de (?)BCBpbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)BCBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoABCApBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbc requis par la preuve de (?)BCBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcm2 : rk(B :: C :: Bp :: bc :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: nil) (nil) 4 0 2 HOoABCApBpbcmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCBpbcM3 : rk(B :: C :: Bp :: bc :: nil) <= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: nil) (Bp :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: B :: C :: bc :: nil) ((Bp :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (B :: C :: bc :: nil) (nil) 1 2 0 HBpMtmp HBCbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc ::  de rang :  3 et 3 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcm3 : rk(B :: C :: Bp :: bc :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HOoBCBpbceq : rk(Oo :: B :: C :: Bp :: bc :: nil) = 3) by (apply LOoBCBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCBpbcmtmp : rk(Oo :: B :: C :: Bp :: bc :: nil) >= 3) by (solve_hyps_min HOoBCBpbceq HOoBCBpbcm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcmtmp;try rewrite HT2 in HOoBCBpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}


assert(HBCBpbcM : rk(B :: C :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpbcm : rk(B :: C :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HBCBpbceq HBCBpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bpbc requis par la preuve de (?)Bpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc ::  de rang :  3 et 3 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBpbcm2 : rk(Bp :: bc :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	try assert(HBCBpbceq : rk(B :: C :: Bp :: bc :: nil) = 3) by (apply LBCBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCBpbcmtmp : rk(B :: C :: Bp :: bc :: nil) >= 3) by (solve_hyps_min HBCBpbceq HBCBpbcm3).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: nil) (B :: C :: bc :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Bp :: bc :: nil) ((B :: C :: bc :: nil) ++ (Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcmtmp;try rewrite HT2 in HBCBpbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Bp :: bc :: nil) (bc :: nil) 3 1 2 HBCBpbcmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}


assert(HBpbcM : rk(Bp :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpbceq HBpbcM2).
assert(HBpbcm : rk(Bp :: bc ::  nil) >= 1) by (solve_hyps_min HBpbceq HBpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpbc *)
(* dans la couche 0 *)
Lemma LOoBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpCpbc requis par la preuve de (?)OoBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpCpbc requis par la preuve de (?)OoBpCpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpCpbc requis par la preuve de (?)OoBpCpbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBpCpbcM3 : rk(Oo :: Bp :: Cp :: bc :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	try assert(HBpCpbceq : rk(Bp :: Cp :: bc :: nil) = 2) by (apply LBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: Cp :: bc :: nil) (Oo :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: bc :: nil) ((Oo :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Bp :: Cp :: bc :: nil) (nil) 1 2 0 HOoMtmp HBpCpbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpbcm2 : rk(Oo :: Bp :: Cp :: bc :: nil) >= 2).
{
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: bc :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: Cp :: bc ::  de rang :  3 et 3 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoBpCpbcm3 : rk(Oo :: Bp :: Cp :: bc :: nil) >= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HOoCBpCpbceq : rk(Oo :: C :: Bp :: Cp :: bc :: nil) = 3) by (apply LOoCBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCBpCpbcmtmp : rk(Oo :: C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoCBpCpbceq HOoCBpCpbcm3).
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: bc :: nil) (Oo :: C :: Cp :: Oo :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: Bp :: Cp :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpCpbcmtmp;try rewrite HT2 in HOoCBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: Bp :: Cp :: bc :: nil) (Oo :: Cp :: nil) 3 2 2 HOoCBpCpbcmtmp HOoCpmtmp HOoCCpMtmp Hincl); apply HT.
}


assert(HOoBpCpbcM : rk(Oo :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBpCpbcm : rk(Oo :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBpCpbceq HOoBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpbc requis par la preuve de (?)OoBpbc pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpbc requis par la preuve de (?)OoBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpbc requis par la preuve de (?)OoBBpbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpbc requis par la preuve de (?)OoBBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoBCApBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoABCApBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpbc requis par la preuve de (?)OoBCApBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpbcm4 : rk(Oo :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpbc requis par la preuve de (?)OoBBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpbcm2 : rk(Oo :: B :: Bp :: bc :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpbcmtmp : rk(Oo :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApBpbceq HOoBCApBpbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: bc :: nil) (C :: Ap :: Oo :: B :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: bc :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpbcmtmp;try rewrite HT2 in HOoBCApBpbcmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: bc :: nil) (nil) 4 0 2 HOoBCApBpbcmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApBpbcM1. try clear HOoBCApBpbcM2. try clear HOoBCApBpbcM3. try clear HOoBCApBpbcm4. try clear HOoBCApBpbcm3. try clear HOoBCApBpbcm2. try clear HOoBCApBpbcm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBBpbcM3 : rk(Oo :: B :: Bp :: bc :: nil) <= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: bc :: nil) (Oo :: B :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (bc :: nil) (nil) 2 1 0 HOoBBpMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpbc requis par la preuve de (?)OoBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: bc ::  de rang :  2 et 3 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpbcm2 : rk(Oo :: Bp :: bc :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpbcmtmp : rk(Oo :: B :: Bp :: bc :: nil) >= 2) by (solve_hyps_min HOoBBpbceq HOoBBpbcm2).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: bc :: nil) (Oo :: B :: Bp :: Oo :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Bp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpbcmtmp;try rewrite HT2 in HOoBBpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Bp :: bc :: nil) (Oo :: Bp :: nil) 2 2 2 HOoBBpbcmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBBpbcM1. try clear HOoBBpbcM2. try clear HOoBBpbcM3. try clear HOoBBpbcm4. try clear HOoBBpbcm3. try clear HOoBBpbcm2. try clear HOoBBpbcm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpbcm3 : rk(Oo :: Bp :: bc :: nil) >= 3).
{
	try assert(HBpCpbceq : rk(Bp :: Cp :: bc :: nil) = 2) by (apply LBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	try assert(HOoBpCpbceq : rk(Oo :: Bp :: Cp :: bc :: nil) = 3) by (apply LOoBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpCpbcmtmp : rk(Oo :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoBpCpbceq HOoBpCpbcm3).
	try assert(HBpbceq : rk(Bp :: bc :: nil) = 2) by (apply LBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpbcmtmp : rk(Bp :: bc :: nil) >= 2) by (solve_hyps_min HBpbceq HBpbcm2).
	assert(Hincl : incl (Bp :: bc :: nil) (list_inter (Oo :: Bp :: bc :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: Cp :: bc :: nil) (Oo :: Bp :: bc :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: bc :: Bp :: Cp :: bc :: nil) ((Oo :: Bp :: bc :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBpCpbcmtmp;try rewrite HT2 in HOoBpCpbcmtmp.
	assert(HT := rule_2 (Oo :: Bp :: bc :: nil) (Bp :: Cp :: bc :: nil) (Bp :: bc :: nil) 3 2 2 HOoBpCpbcmtmp HBpbcmtmp HBpCpbcMtmp Hincl);apply HT.
}
try clear HBpbcM1. try clear HBpbcM2. try clear HBpbcM3. try clear HBpbcm4. try clear HBpbcm3. try clear HBpbcm2. try clear HBpbcm1. 

assert(HOoBpbcM : rk(Oo :: Bp :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpbceq HOoBpbcM3).
assert(HOoBpbcm : rk(Oo :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBpbceq HOoBpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpbc *)
(* dans la couche 0 *)
Lemma LOoABCApBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoABCApBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpbc requis par la preuve de (?)OoBCApBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpbcm4 : rk(Oo :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) = 4) by (apply LOoABCApBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApBpbcM : rk(Oo :: B :: C :: Ap :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpbcm : rk(Oo :: B :: C :: Ap :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCApBpbceq HOoBCApBpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpbc *)
(* dans constructLemma(), requis par LBCApCpbc *)
(* dans constructLemma(), requis par LOoBCApCpbc *)
(* dans la couche 0 *)
Lemma LOoABCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbc requis par la preuve de (?)OoABCApCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApCpbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApCpbc requis par la preuve de (?)OoBCApCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApCpbcm4 : rk(Oo :: B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApCpbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcmtmp;try rewrite HT2 in HOoABCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApCpbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApCpbcM : rk(Oo :: B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApCpbcm : rk(Oo :: B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCApCpbceq HOoBCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpbc requis par la preuve de (?)BCApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpbc requis par la preuve de (?)BCApCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpbcm3 : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApCpbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcmtmp;try rewrite HT2 in HOoABCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApCpbcmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HBCApCpbcm4 : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HOoBCApCpbceq : rk(Oo :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoBCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCApCpbcmtmp : rk(Oo :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApCpbceq HOoBCApCpbcm4).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: C :: Cp :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: B :: C :: Ap :: Cp :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApCpbcmtmp;try rewrite HT2 in HOoBCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (B :: C :: Ap :: Cp :: bc :: nil) (C :: Cp :: nil) 4 2 2 HOoBCApCpbcmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}
try clear HOoBCApCpbcM1. try clear HOoBCApCpbcM2. try clear HOoBCApCpbcM3. try clear HOoBCApCpbcm4. try clear HOoBCApCpbcm3. try clear HOoBCApCpbcm2. try clear HOoBCApCpbcm1. 

assert(HBCApCpbcM : rk(B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApCpbcm : rk(B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HBCApCpbceq HBCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpbc requis par la preuve de (?)ApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpbc requis par la preuve de (?)ApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpbc requis par la preuve de (?)OoCApCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpbcm3 : rk(Oo :: C :: Ap :: Cp :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApCpbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcmtmp;try rewrite HT2 in HOoABCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpbc requis par la preuve de (?)ApCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: bc ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApCpbcm2 : rk(Ap :: Cp :: bc :: nil) >= 2).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpbcmtmp : rk(Oo :: C :: Ap :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoCApCpbceq HOoCApCpbcm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: bc :: nil) (Oo :: C :: Cp :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpbcmtmp;try rewrite HT2 in HOoCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Cp :: bc :: nil) (Cp :: nil) 3 1 2 HOoCApCpbcmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}
try clear HOoCApCpbcM1. try clear HOoCApCpbcM2. try clear HOoCApCpbcM3. try clear HOoCApCpbcm4. try clear HOoCApCpbcm3. try clear HOoCApCpbcm2. try clear HOoCApCpbcm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HApCpbcm3 : rk(Ap :: Cp :: bc :: nil) >= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	try assert(HBCApCpbceq : rk(B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LBCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApCpbcmtmp : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HBCApCpbceq HBCApCpbcm4).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: bc :: nil) (B :: C :: bc :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Ap :: Cp :: bc :: nil) ((B :: C :: bc :: nil) ++ (Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpbcmtmp;try rewrite HT2 in HBCApCpbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Ap :: Cp :: bc :: nil) (bc :: nil) 4 1 2 HBCApCpbcmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}


assert(HApCpbcM : rk(Ap :: Cp :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpbceq HApCpbcM3).
assert(HApCpbcm : rk(Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HApCpbceq HApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoABCApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpCpbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACabbc *)
(* dans la couche 0 *)
Lemma LABCabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbc requis par la preuve de (?)ABCabbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)ABCabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbc requis par la preuve de (?)ABCabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcm3 : rk(A :: B :: C :: ab :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcmtmp;try rewrite HT2 in HOoABCApabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABCabbcM3 : rk(A :: B :: C :: ab :: bc :: nil) <= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: nil) (A :: B :: ab :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: bc :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: C :: bc :: nil) (B :: nil) 2 2 1 HABabMtmp HBCbcMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HABCabbcM : rk(A :: B :: C :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabbcm : rk(A :: B :: C :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABCabbceq HABCabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabbcm2 : rk(A :: C :: ab :: bc :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcmtmp;try rewrite HT2 in HOoABCApabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: bc :: nil) (A :: nil) 4 1 3 HOoABCApabbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc ::  de rang :  3 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabbcm3 : rk(A :: C :: ab :: bc :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HABCabbceq : rk(A :: B :: C :: ab :: bc :: nil) = 3) by (apply LABCabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCabbcmtmp : rk(A :: B :: C :: ab :: bc :: nil) >= 3) by (solve_hyps_min HABCabbceq HABCabbcm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcmtmp;try rewrite HT2 in HABCabbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACabbcM3 : rk(A :: C :: ab :: bc :: nil) <= 3).
{
	try assert(HABCabbceq : rk(A :: B :: C :: ab :: bc :: nil) = 3) by (apply LABCabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCabbcMtmp : rk(A :: B :: C :: ab :: bc :: nil) <= 3) by (solve_hyps_max HABCabbceq HABCabbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: ab :: bc :: nil) (A :: B :: C :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: ab :: bc :: nil) (A :: B :: C :: ab :: bc :: nil) 3 3 HABCabbcMtmp Hcomp Hincl);apply HT.
}


assert(HACabbcM : rk(A :: C :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabbcm : rk(A :: C :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HACabbceq HACabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApabbcM : rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabbcm : rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpabbc *)
(* dans la couche 0 *)
Lemma LApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpCpabbc requis par la preuve de (?)OoCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)OoBCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)OoABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpabbc requis par la preuve de (?)OoBCApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpabbcm4 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpCpabbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpabbc requis par la preuve de (?)OoCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpabbc requis par la preuve de (?)OoCApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpCpabbcm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApBpCpabbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApBpCpabbcM1. try clear HOoABCApBpCpabbcM2. try clear HOoABCApBpCpabbcM3. try clear HOoABCApBpCpabbcm4. try clear HOoABCApBpCpabbcm3. try clear HOoABCApBpCpabbcm2. try clear HOoABCApBpCpabbcm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCApBpCpabbcm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCApBpCpabbcmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApBpCpabbceq HOoBCApBpCpabbcm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: B :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpabbcmtmp;try rewrite HT2 in HOoBCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Bp :: nil) 4 2 2 HOoBCApBpCpabbcmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBCApBpCpabbcM1. try clear HOoBCApBpCpabbcM2. try clear HOoBCApBpCpabbcM3. try clear HOoBCApBpCpabbcm4. try clear HOoBCApBpCpabbcm3. try clear HOoBCApBpCpabbcm2. try clear HOoBCApBpCpabbcm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpCpabbc requis par la preuve de (?)OoBApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpCpabbc requis par la preuve de (?)OoABApBpCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpCpabbc requis par la preuve de (?)OoABApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpabbcm2 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpabbcm3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpCpabbc requis par la preuve de (?)OoBApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpCpabbcm3 : rk(Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpCpabbcmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3) by (solve_hyps_min HOoABApBpCpabbceq HOoABApBpCpabbcm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpabbcmtmp;try rewrite HT2 in HOoABApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpCpabbcmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApBpCpabbcM1. try clear HOoABApBpCpabbcM2. try clear HOoABApBpCpabbcM3. try clear HOoABApBpCpabbcm4. try clear HOoABApBpCpabbcm3. try clear HOoABApBpCpabbcm2. try clear HOoABApBpCpabbcm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HApBpCpabbcm2 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBApBpCpabbcmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3) by (solve_hyps_min HOoBApBpCpabbceq HOoBApBpCpabbcm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: B :: Bp :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpabbcmtmp;try rewrite HT2 in HOoBApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) (Bp :: nil) 3 1 2 HOoBApBpCpabbcmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBApBpCpabbcM1. try clear HOoBApBpCpabbcM2. try clear HOoBApBpCpabbcM3. try clear HOoBApBpCpabbcm4. try clear HOoBApBpCpabbcm3. try clear HOoBApBpCpabbcm2. try clear HOoBApBpCpabbcm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApBpCpabbcm3 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApBpCpabbcmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoCApBpCpabbceq HOoCApBpCpabbcm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: C :: Cp :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpabbcmtmp;try rewrite HT2 in HOoCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) (Cp :: nil) 4 1 2 HOoCApBpCpabbcmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}
try clear HOoCApBpCpabbcM1. try clear HOoCApBpCpabbcM2. try clear HOoCApBpCpabbcM3. try clear HOoCApBpCpabbcm4. try clear HOoCApBpCpabbcm3. try clear HOoCApBpCpabbcm2. try clear HOoCApBpCpabbcm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApBpCpabbcM3 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) <= 3).
{
	try assert(HApBpabeq : rk(Ap :: Bp :: ab :: nil) = 2) by (apply LApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	try assert(HBpCpbceq : rk(Bp :: Cp :: bc :: nil) = 2) by (apply LBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: ab :: bc :: nil) (Ap :: Bp :: ab :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: Bp :: Cp :: bc :: nil) ((Ap :: Bp :: ab :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (Bp :: Cp :: bc :: nil) (Bp :: nil) 2 2 1 HApBpabMtmp HBpCpbcMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HApBpCpabbcM : rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpabbcm : rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HApBpCpabbceq HApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)OoABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)OoABApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabbcm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabbcm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: bc ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpabbcm3 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabbcmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3) by (solve_hyps_min HOoABApCpabbceq HOoABApCpabbcm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabbcmtmp;try rewrite HT2 in HOoABApCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpabbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApCpabbcM1. try clear HOoABApCpabbcM2. try clear HOoABApCpabbcM3. try clear HOoABApCpabbcm4. try clear HOoABApCpabbcm3. try clear HOoABApCpabbcm2. try clear HOoABApCpabbcm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabbcm4 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	try assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabbc requis par la preuve de (?)OoCApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabbc requis par la preuve de (?)OoABCApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpabbc requis par la preuve de (?)OoCApCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpabbcm3 : rk(Oo :: C :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabbceq HOoABCApCpabbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabbcmtmp;try rewrite HT2 in HOoABCApCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ab :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpabbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApCpabbcM1. try clear HOoABCApCpabbcM2. try clear HOoABCApCpabbcM3. try clear HOoABCApCpabbcm4. try clear HOoABCApCpabbcm3. try clear HOoABCApCpabbcm2. try clear HOoABCApCpabbcm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ab :: bc ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApCpabbcm2 : rk(Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpabbcmtmp : rk(Oo :: C :: Ap :: Cp :: ab :: bc :: nil) >= 3) by (solve_hyps_min HOoCApCpabbceq HOoCApCpabbcm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ab :: bc :: nil) (Oo :: C :: Cp :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: ab :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpabbcmtmp;try rewrite HT2 in HOoCApCpabbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Cp :: ab :: bc :: nil) (Cp :: nil) 3 1 2 HOoCApCpabbcmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}
try clear HOoCApCpabbcM1. try clear HOoCApCpabbcM2. try clear HOoCApCpabbcM3. try clear HOoCApCpabbcm4. try clear HOoCApCpabbcm3. try clear HOoCApCpabbcm2. try clear HOoCApCpabbcm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApCpabbcm3 : rk(Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabbceq HABApCpabbcm4).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: bc :: nil) (A :: B :: ab :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: Cp :: ab :: bc :: nil) ((A :: B :: ab :: nil) ++ (Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabbcmtmp;try rewrite HT2 in HABApCpabbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: Cp :: ab :: bc :: nil) (ab :: nil) 4 1 2 HABApCpabbcmtmp Habmtmp HABabMtmp Hincl); apply HT.
}
try clear HABApCpabbcM1. try clear HABApCpabbcM2. try clear HABApCpabbcM3. try clear HABApCpabbcm4. try clear HABApCpabbcm3. try clear HABApCpabbcm2. try clear HABApCpabbcm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpabbcM3 : rk(Ap :: Cp :: ab :: bc :: nil) <= 3).
{
	try assert(HApBpCpabbceq : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) = 3) by (apply LApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpCpabbcMtmp : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) <= 3) by (solve_hyps_max HApBpCpabbceq HApBpCpabbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: ab :: bc :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: Cp :: ab :: bc :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) 3 3 HApBpCpabbcMtmp Hcomp Hincl);apply HT.
}


assert(HApCpabbcM : rk(Ap :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpabbcm : rk(Ap :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HApCpabbceq HApCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)OoABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)OoABApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabbcm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabbcm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: bc ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpabbcm3 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabbcmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3) by (solve_hyps_min HOoABApCpabbceq HOoABApCpabbcm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabbcmtmp;try rewrite HT2 in HOoABApCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpabbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApCpabbcM1. try clear HOoABApCpabbcM2. try clear HOoABApCpabbcM3. try clear HOoABApCpabbcm4. try clear HOoABApCpabbcm3. try clear HOoABApCpabbcm2. try clear HOoABApCpabbcm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabbcm4 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	try assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}


assert(HABApCpabbcM : rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabbcm : rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABApCpabbceq HABApCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabbc requis par la preuve de (?)OoABCApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApCpabbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabbceq HOoABCApCpabbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApBpCpabbc *)
(* dans constructLemma(), requis par LOoBCApBpCpabbc *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)OoABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpCpabbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpabbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpabbc requis par la preuve de (?)OoBCApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpabbcm4 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpCpabbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LOoABCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpCpabbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApBpCpabbcM : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpCpabbcm : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCApBpCpabbceq HOoBCApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpabbc requis par la preuve de (?)OoCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpabbc requis par la preuve de (?)OoCApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpCpabbcm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApBpCpabbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LOoABCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApBpCpabbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApBpCpabbcM1. try clear HOoABCApBpCpabbcM2. try clear HOoABCApBpCpabbcM3. try clear HOoABCApBpCpabbcm4. try clear HOoABCApBpCpabbcm3. try clear HOoABCApBpCpabbcm2. try clear HOoABCApBpCpabbcm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCApBpCpabbcm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HOoBCApBpCpabbceq : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LOoBCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCApBpCpabbcmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApBpCpabbceq HOoBCApBpCpabbcm4).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: B :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpabbcmtmp;try rewrite HT2 in HOoBCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Bp :: nil) 4 2 2 HOoBCApBpCpabbcmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBCApBpCpabbcM1. try clear HOoBCApBpCpabbcM2. try clear HOoBCApBpCpabbcM3. try clear HOoBCApBpCpabbcm4. try clear HOoBCApBpCpabbcm3. try clear HOoBCApBpCpabbcm2. try clear HOoBCApBpCpabbcm1. 

assert(HOoCApBpCpabbcM : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpabbcm : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpabbceq HOoCApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)ACacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)OoABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacbcm2 : rk(A :: C :: ac :: bc :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApacbceq HOoABCApacbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacbcmtmp;try rewrite HT2 in HOoABCApacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: bc :: nil) (A :: nil) 4 1 3 HOoABCApacbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacbcM1. try clear HOoABCApacbcM2. try clear HOoABCApacbcM3. try clear HOoABCApacbcm4. try clear HOoABCApacbcm3. try clear HOoABCApacbcm2. try clear HOoABCApacbcm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACacbcM3 : rk(A :: C :: ac :: bc :: nil) <= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: ac :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: bc :: nil) (A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (bc :: nil) (nil) 2 1 0 HACacMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacbcm3 : rk(A :: C :: ac :: bc :: nil) >= 3).
{
	try assert(HACbceq : rk(A :: C :: bc :: nil) = 3) by (apply LACbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACbcmtmp : rk(A :: C :: bc :: nil) >= 3) by (solve_hyps_min HACbceq HACbcm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: bc :: nil) (A :: C :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: bc :: nil) (A :: C :: ac :: bc :: nil) 3 3 HACbcmtmp Hcomp Hincl);apply HT.
}


assert(HACacbcM : rk(A :: C :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacbcm : rk(A :: C :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HACacbceq HACacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)OoABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApacbcM : rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacbcm : rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApacbceq HOoABCApacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpacbc *)
(* dans constructLemma(), requis par LBCApCpacbc *)
(* dans constructLemma(), requis par LOoBCApCpacbc *)
(* dans la couche 0 *)
Lemma LOoABCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacbc requis par la preuve de (?)OoABCApCpacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpacbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApCpacbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApCpacbc requis par la preuve de (?)OoBCApCpacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApCpacbcm4 : rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApCpacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacbcmtmp;try rewrite HT2 in HOoABCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApCpacbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApCpacbcM : rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApCpacbcm : rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCApCpacbceq HOoBCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpacbc requis par la preuve de (?)BCApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpacbc requis par la preuve de (?)BCApCpacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpacbcm3 : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApCpacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacbcmtmp;try rewrite HT2 in HOoABCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApCpacbcmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HBCApCpacbcm4 : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HOoBCApCpacbceq : rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoBCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCApCpacbcmtmp : rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApCpacbceq HOoBCApCpacbcm4).
	try assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: C :: Cp :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApCpacbcmtmp;try rewrite HT2 in HOoBCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil) (C :: Cp :: nil) 4 2 2 HOoBCApCpacbcmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}
try clear HOoBCApCpacbcM1. try clear HOoBCApCpacbcM2. try clear HOoBCApCpacbcM3. try clear HOoBCApCpacbcm4. try clear HOoBCApCpacbcm3. try clear HOoBCApCpacbcm2. try clear HOoBCApCpacbcm1. 

assert(HBCApCpacbcM : rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApCpacbcm : rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HBCApCpacbceq HBCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpacbc requis par la preuve de (?)OoCApCpacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpacbcm3 : rk(Oo :: C :: Ap :: Cp :: ac :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApCpacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacbcmtmp;try rewrite HT2 in HOoABCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpacbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ac :: bc ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApCpacbcm2 : rk(Ap :: Cp :: ac :: bc :: nil) >= 2).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpacbcmtmp : rk(Oo :: C :: Ap :: Cp :: ac :: bc :: nil) >= 3) by (solve_hyps_min HOoCApCpacbceq HOoCApCpacbcm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: C :: Cp :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpacbcmtmp;try rewrite HT2 in HOoCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: bc :: nil) (Cp :: nil) 3 1 2 HOoCApCpacbcmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}
try clear HOoCApCpacbcM1. try clear HOoCApCpacbcM2. try clear HOoCApCpacbcM3. try clear HOoCApCpacbcm4. try clear HOoCApCpacbcm3. try clear HOoCApCpacbcm2. try clear HOoCApCpacbcm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApCpacbcM3 : rk(Ap :: Cp :: ac :: bc :: nil) <= 3).
{
	try assert(HApCpaceq : rk(Ap :: Cp :: ac :: nil) = 2) by (apply LApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Cp :: ac :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ac :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ac :: bc :: nil) ((Ap :: Cp :: ac :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ac :: nil) (bc :: nil) (nil) 2 1 0 HApCpacMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HApCpacbcm3 : rk(Ap :: Cp :: ac :: bc :: nil) >= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	try assert(HBCApCpacbceq : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LBCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApCpacbcmtmp : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HBCApCpacbceq HBCApCpacbcm4).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: ac :: bc :: nil) (B :: C :: bc :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Ap :: Cp :: ac :: bc :: nil) ((B :: C :: bc :: nil) ++ (Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpacbcmtmp;try rewrite HT2 in HBCApCpacbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil) (bc :: nil) 4 1 2 HBCApCpacbcmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}


assert(HApCpacbcM : rk(Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpacbcm : rk(Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HApCpacbceq HApCpacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabacbc *)
(* dans la couche 0 *)
Lemma LACabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 3 HOoABCApabacbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABCabacbcM1. try clear HABCabacbcM2. try clear HABCabacbcM3. try clear HABCabacbcm4. try clear HABCabacbcm3. try clear HABCabacbcm2. try clear HABCabacbcm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACabacbcM3 : rk(A :: C :: ab :: ac :: bc :: nil) <= 3).
{
	try assert(HACabbceq : rk(A :: C :: ab :: bc :: nil) = 3) by (apply LACabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACabbcMtmp : rk(A :: C :: ab :: bc :: nil) <= 3) by (solve_hyps_max HACabbceq HACabbcM3).
	try assert(HACacbceq : rk(A :: C :: ac :: bc :: nil) = 3) by (apply LACacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacbcMtmp : rk(A :: C :: ac :: bc :: nil) <= 3) by (solve_hyps_max HACacbceq HACacbcM3).
	try assert(HACbceq : rk(A :: C :: bc :: nil) = 3) by (apply LACbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACbcmtmp : rk(A :: C :: bc :: nil) >= 3) by (solve_hyps_min HACbceq HACbcm3).
	assert(Hincl : incl (A :: C :: bc :: nil) (list_inter (A :: C :: ab :: bc :: nil) (A :: C :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ab :: bc :: A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ab :: bc :: A :: C :: ac :: bc :: nil) ((A :: C :: ab :: bc :: nil) ++ (A :: C :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ab :: bc :: nil) (A :: C :: ac :: bc :: nil) (A :: C :: bc :: nil) 3 3 3 HACabbcMtmp HACacbcMtmp HACbcmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HACabacbcM : rk(A :: C :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabacbcm : rk(A :: C :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HACabacbceq HACabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 3 HOoABCApabacbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABCabacbcM1. try clear HABCabacbcM2. try clear HABCabacbcM3. try clear HABCabacbcm4. try clear HABCabacbcm3. try clear HABCabacbcm2. try clear HABCabacbcm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm3 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabacbcM1. try clear HOoABCApabacbcM2. try clear HOoABCApabacbcM3. try clear HOoABCApabacbcm4. try clear HOoABCApabacbcm3. try clear HOoABCApabacbcm2. try clear HOoABCApabacbcm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabacbc requis par la preuve de (?)ABabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabacbcm2 : rk(A :: B :: ab :: ac :: bc :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabacbcmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApabacbceq HABCApabacbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (C :: Ap :: A :: B :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: ac :: bc :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcmtmp;try rewrite HT2 in HABCApabacbcmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: ac :: bc :: nil) (nil) 4 0 2 HABCApabacbcmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabacbcM1. try clear HABCApabacbcM2. try clear HABCApabacbcM3. try clear HABCApabacbcm4. try clear HABCApabacbcm3. try clear HABCApabacbcm2. try clear HABCApabacbcm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: ac :: bc ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabacbcm2 : rk(A :: ab :: ac :: bc :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabacbcmtmp : rk(A :: B :: ab :: ac :: bc :: nil) >= 2) by (solve_hyps_min HABabacbceq HABabacbcm2).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabacbcmtmp;try rewrite HT2 in HABabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: ac :: bc :: nil) (A :: ab :: nil) 2 2 2 HABabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABabacbcM1. try clear HABabacbcM2. try clear HABabacbcM3. try clear HABabacbcm4. try clear HABabacbcm3. try clear HABabacbcm2. try clear HABabacbcm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAabacbcm3 : rk(A :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcmtmp : rk(A :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HACabacbceq HACabacbcm3).
	try assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ac :: A :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ab :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (A :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcmtmp;try rewrite HT2 in HACabacbcmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ab :: ac :: bc :: nil) (A :: ac :: nil) 3 2 2 HACabacbcmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabacbcM3 : rk(A :: ab :: ac :: bc :: nil) <= 3).
{
	try assert(HACabacbceq : rk(A :: C :: ab :: ac :: bc :: nil) = 3) by (apply LACabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACabacbcMtmp : rk(A :: C :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HACabacbceq HACabacbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: ac :: bc :: nil) (A :: C :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ab :: ac :: bc :: nil) (A :: C :: ab :: ac :: bc :: nil) 3 3 HACabacbcMtmp Hcomp Hincl);apply HT.
}


assert(HAabacbcM : rk(A :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabacbcm : rk(A :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HAabacbceq HAabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabacbc *)
(* dans la couche 0 *)
Lemma LOoABCApabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApabacbcM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm3 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApabacbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApabacbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HABCApabacbcM : rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabacbcm : rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABCApabacbceq HABCApabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)OoABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)OoABApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacbcm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacbcm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpabacbcm3 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabacbcmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HOoABApCpabacbceq HOoABApCpabacbcm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabacbcmtmp;try rewrite HT2 in HOoABApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApCpabacbcM1. try clear HOoABApCpabacbcM2. try clear HOoABApCpabacbcM3. try clear HOoABApCpabacbcm4. try clear HOoABApCpabacbcm3. try clear HOoABApCpabacbcm2. try clear HOoABApCpabacbcm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabacbcm4 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabacbc requis par la preuve de (?)OoCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabacbc requis par la preuve de (?)OoABCApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpabacbc requis par la preuve de (?)OoCApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpabacbcm3 : rk(Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacbcmtmp;try rewrite HT2 in HOoABCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpabacbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApCpabacbcm2 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpabacbcmtmp : rk(Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HOoCApCpabacbceq HOoCApCpabacbcm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: C :: Cp :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpabacbcmtmp;try rewrite HT2 in HOoCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (Cp :: nil) 3 1 2 HOoCApCpabacbcmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}
try clear HOoCApCpabacbcM1. try clear HOoCApCpabacbcM2. try clear HOoCApCpabacbcM3. try clear HOoCApCpabacbcm4. try clear HOoCApCpabacbcm3. try clear HOoCApCpabacbcm2. try clear HOoCApCpabacbcm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApCpabacbcm3 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabacbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm4).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: ab :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacbcmtmp;try rewrite HT2 in HABApCpabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: nil) 4 1 2 HABApCpabacbcmtmp Habmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApCpabacbcM3 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) <= 3).
{
	try assert(HApCpabbceq : rk(Ap :: Cp :: ab :: bc :: nil) = 3) by (apply LApCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpabbcMtmp : rk(Ap :: Cp :: ab :: bc :: nil) <= 3) by (solve_hyps_max HApCpabbceq HApCpabbcM3).
	try assert(HApCpacbceq : rk(Ap :: Cp :: ac :: bc :: nil) = 3) by (apply LApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpacbcMtmp : rk(Ap :: Cp :: ac :: bc :: nil) <= 3) by (solve_hyps_max HApCpacbceq HApCpacbcM3).
	try assert(HApCpbceq : rk(Ap :: Cp :: bc :: nil) = 3) by (apply LApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpbcmtmp : rk(Ap :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HApCpbceq HApCpbcm3).
	assert(Hincl : incl (Ap :: Cp :: bc :: nil) (list_inter (Ap :: Cp :: ab :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: bc :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ab :: bc :: Ap :: Cp :: ac :: bc :: nil) ((Ap :: Cp :: ab :: bc :: nil) ++ (Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ab :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil) (Ap :: Cp :: bc :: nil) 3 3 3 HApCpabbcMtmp HApCpacbcMtmp HApCpbcmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HApCpabacbcM : rk(Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpabacbcm : rk(Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HApCpabacbceq HApCpabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApCpabacbc *)
(* dans la couche 0 *)
Lemma LABApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)OoABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)OoABApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacbcm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacbcm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpabacbcm3 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabacbcmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HOoABApCpabacbceq HOoABApCpabacbcm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabacbcmtmp;try rewrite HT2 in HOoABApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApCpabacbcM1. try clear HOoABApCpabacbcM2. try clear HOoABApCpabacbcM3. try clear HOoABApCpabacbcm4. try clear HOoABApCpabacbcm3. try clear HOoABApCpabacbcm2. try clear HOoABApCpabacbcm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabacbcm4 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}


assert(HABApCpabacbcM : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabacbcm : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabacbc requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabacbc requis par la preuve de (?)OoABCApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCpabacbc requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpabacbc requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpabacbcm3 : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacbcmtmp;try rewrite HT2 in HOoABCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpabacbcm4 : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacbcmtmp;try rewrite HT2 in HOoABCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApCpabacbcm2 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApCpabacbcmtmp : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApCpabacbceq HABCApCpabacbcm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (B :: C :: Ap :: A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Cp :: ab :: ac :: bc :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpabacbcmtmp;try rewrite HT2 in HABCApCpabacbcmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (Ap :: nil) 4 1 3 HABCApCpabacbcmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}
try clear HABCApCpabacbcM1. try clear HABCApCpabacbcM2. try clear HABCApCpabacbcM3. try clear HABCApCpabacbcm4. try clear HABCApCpabacbcm3. try clear HABCApCpabacbcm2. try clear HABCApCpabacbcm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : B :: ab ::   de rang : 2 et 2 *)
assert(HAApCpabacbcm3 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabMtmp : rk(B :: ab :: nil) <= 2) by (solve_hyps_max HBabeq HBabM2).
	try assert(HABApCpabacbceq : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LABApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApCpabacbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm4).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil) ((B :: ab :: nil) ++ (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacbcmtmp;try rewrite HT2 in HABApCpabacbcmtmp.
	assert(HT := rule_4 (B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: nil) 4 1 2 HABApCpabacbcmtmp Habmtmp HBabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApCpabacbcm4 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HABApCpabacbceq : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LABApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApCpabacbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm4).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacbcmtmp;try rewrite HT2 in HABApCpabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: ab :: nil) 4 2 2 HABApCpabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}


assert(HAApCpabacbcM : rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpabacbcm : rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HAApCpabacbceq HAApCpabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApCpabacbc *)
(* dans la couche 0 *)
Lemma LOoABCApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabacbc requis par la preuve de (?)OoABCApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApCpabacbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabacbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCpabacbc requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpabacbc requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpabacbcm3 : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApCpabacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacbcmtmp;try rewrite HT2 in HOoABCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpabacbcm4 : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApCpabacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApCpabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacbcmtmp;try rewrite HT2 in HOoABCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HABCApCpabacbcM : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpabacbcm : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABCApCpabacbceq HABCApCpabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HDM : rk(D ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HDeq HDM1).
assert(HDm : rk(D ::  nil) >= 1) by (solve_hyps_min HDeq HDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoD *)
(* dans la couche 0 *)
Lemma LOoABD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoABDM : rk(Oo :: A :: B :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDm : rk(Oo :: A :: B :: D ::  nil) >= 1) by (solve_hyps_min HOoABDeq HOoABDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoD *)
(* dans la couche 0 *)
Lemma LOoD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABD requis par la preuve de (?)OoD pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDm3 : rk(A :: B :: C :: Ap :: D :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDm4 : rk(A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABDm2 : rk(A :: B :: D :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApDmtmp : rk(A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HABCApDeq HABCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: nil) (C :: Ap :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDmtmp;try rewrite HT2 in HABCApDmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: nil) (nil) 4 0 2 HABCApDmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApDM1. try clear HABCApDM2. try clear HABCApDM3. try clear HABCApDm4. try clear HABCApDm3. try clear HABCApDm2. try clear HABCApDm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoD requis par la preuve de (?)OoD pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HOoDm2 : rk(Oo :: D :: nil) >= 2).
{
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 3) by (solve_hyps_max HABDeq HABDM3).
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: D :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: B :: D :: nil) ((Oo :: D :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_2 (Oo :: D :: nil) (A :: B :: D :: nil) (D :: nil) 4 1 3 HOoABDmtmp HDmtmp HABDMtmp Hincl);apply HT.
}


assert(HOoDM : rk(Oo :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoDeq HOoDM2).
assert(HOoDm : rk(Oo :: D ::  nil) >= 1) by (solve_hyps_min HOoDeq HOoDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAD *)
(* dans la couche 0 *)
Lemma LAD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBD requis par la preuve de (?)AD pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApD requis par la preuve de (?)OoBD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoBCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApD requis par la preuve de (?)OoBCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDm4 : rk(Oo :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBD requis par la preuve de (?)OoBD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBDm2 : rk(Oo :: B :: D :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApDmtmp : rk(Oo :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoBCApDeq HOoBCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: nil) (C :: Ap :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: D :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDmtmp;try rewrite HT2 in HOoBCApDmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: D :: nil) (nil) 4 0 2 HOoBCApDmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApDM1. try clear HOoBCApDM2. try clear HOoBCApDM3. try clear HOoBCApDm4. try clear HOoBCApDm3. try clear HOoBCApDm2. try clear HOoBCApDm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AD requis par la preuve de (?)AD pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HADm2 : rk(A :: D :: nil) >= 2).
{
	assert(HOoBDMtmp : rk(Oo :: B :: D :: nil) <= 3) by (solve_hyps_max HOoBDeq HOoBDM3).
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (A :: D :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Oo :: B :: D :: nil) ((A :: D :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_2 (A :: D :: nil) (Oo :: B :: D :: nil) (D :: nil) 4 1 3 HOoABDmtmp HDmtmp HOoBDMtmp Hincl);apply HT.
}


assert(HADM : rk(A :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HADeq HADM2).
assert(HADm : rk(A :: D ::  nil) >= 1) by (solve_hyps_min HADeq HADm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAD *)
(* dans la couche 0 *)
Lemma LOoAD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BD requis par la preuve de (?)OoAD pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAD requis par la preuve de (?)OoAD pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoAD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoABBpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABCApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoABBpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDm2 : rk(Oo :: A :: B :: Bp :: D :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: D :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDmtmp;try rewrite HT2 in HOoABCApBpDmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: nil) (nil) 4 0 2 HOoABCApBpDmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoABCApBpDM1. try clear HOoABCApBpDM2. try clear HOoABCApBpDM3. try clear HOoABCApBpDm4. try clear HOoABCApBpDm3. try clear HOoABCApBpDm2. try clear HOoABCApBpDm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDm3 : rk(Oo :: A :: B :: Bp :: D :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAD requis par la preuve de (?)OoAD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: D ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoADm2 : rk(Oo :: A :: D :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDmtmp : rk(Oo :: A :: B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HOoABBpDeq HOoABBpDm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: nil) (Oo :: B :: Bp :: Oo :: A :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: D :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDmtmp;try rewrite HT2 in HOoABBpDmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: D :: nil) (Oo :: nil) 3 1 2 HOoABBpDmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoABBpDM1. try clear HOoABBpDM2. try clear HOoABBpDM3. try clear HOoABBpDm4. try clear HOoABBpDm3. try clear HOoABBpDm2. try clear HOoABBpDm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 5*)
assert(HOoADm3 : rk(Oo :: A :: D :: nil) >= 3).
{
	assert(HBDMtmp : rk(B :: D :: nil) <= 2) by (solve_hyps_max HBDeq HBDM2).
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: A :: D :: nil) (B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: A :: D :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: B :: D :: nil) ((Oo :: A :: D :: nil) ++ (B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_2 (Oo :: A :: D :: nil) (B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HBDMtmp Hincl);apply HT.
}


assert(HOoADM : rk(Oo :: A :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoADeq HOoADM3).
assert(HOoADm : rk(Oo :: A :: D ::  nil) >= 1) by (solve_hyps_min HOoADeq HOoADm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BD requis par la preuve de (?)BD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: A :: D ::   de rang : 3 et 3 *)
assert(HBDm2 : rk(B :: D :: nil) >= 2).
{
	try assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoADMtmp : rk(Oo :: A :: D :: nil) <= 3) by (solve_hyps_max HOoADeq HOoADM3).
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: A :: D :: nil) (B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: A :: D :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: B :: D :: nil) ((Oo :: A :: D :: nil) ++ (B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_4 (Oo :: A :: D :: nil) (B :: D :: nil) (D :: nil) 4 1 3 HOoABDmtmp HDmtmp HOoADMtmp Hincl); apply HT.
}


assert(HBDM : rk(B :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBDeq HBDM2).
assert(HBDm : rk(B :: D ::  nil) >= 1) by (solve_hyps_min HBDeq HBDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBD requis par la preuve de (?)OoBD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApD requis par la preuve de (?)OoBD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoBCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApD requis par la preuve de (?)OoBCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDm4 : rk(Oo :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBD requis par la preuve de (?)OoBD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBDm2 : rk(Oo :: B :: D :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApDmtmp : rk(Oo :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoBCApDeq HOoBCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: nil) (C :: Ap :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: D :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDmtmp;try rewrite HT2 in HOoBCApDmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: D :: nil) (nil) 4 0 2 HOoBCApDmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApDM1. try clear HOoBCApDM2. try clear HOoBCApDM3. try clear HOoBCApDm4. try clear HOoBCApDm3. try clear HOoBCApDm2. try clear HOoBCApDm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: D ::   de rang : 2 et 2 *)
assert(HOoBDm3 : rk(Oo :: B :: D :: nil) >= 3).
{
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADMtmp : rk(A :: D :: nil) <= 2) by (solve_hyps_max HADeq HADM2).
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (A :: D :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Oo :: B :: D :: nil) ((A :: D :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_4 (A :: D :: nil) (Oo :: B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HADMtmp Hincl); apply HT.
}


assert(HOoBDM : rk(Oo :: B :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBDeq HOoBDM3).
assert(HOoBDm : rk(Oo :: B :: D ::  nil) >= 1) by (solve_hyps_min HOoBDeq HOoBDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDm3 : rk(A :: B :: C :: Ap :: D :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDm4 : rk(A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABDm2 : rk(A :: B :: D :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApDmtmp : rk(A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HABCApDeq HABCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: nil) (C :: Ap :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDmtmp;try rewrite HT2 in HABCApDmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: nil) (nil) 4 0 2 HABCApDmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApDM1. try clear HABCApDM2. try clear HABCApDM3. try clear HABCApDm4. try clear HABCApDm3. try clear HABCApDm2. try clear HABCApDm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HABDm3 : rk(A :: B :: D :: nil) >= 3).
{
	try assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: D :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: B :: D :: nil) ((Oo :: D :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (A :: B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}


assert(HABDM : rk(A :: B :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABDeq HABDM3).
assert(HABDm : rk(A :: B :: D ::  nil) >= 1) by (solve_hyps_min HABDeq HABDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCD *)
(* dans la couche 0 *)
Lemma LOoACD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoACDM : rk(Oo :: A :: C :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACDm : rk(Oo :: A :: C :: D ::  nil) >= 1) by (solve_hyps_min HOoACDeq HOoACDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD requis par la preuve de (?)CD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: A :: D ::   de rang : 3 et 3 *)
assert(HCDm2 : rk(C :: D :: nil) >= 2).
{
	try assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoADMtmp : rk(Oo :: A :: D :: nil) <= 3) by (solve_hyps_max HOoADeq HOoADM3).
	try assert(HOoACDeq : rk(Oo :: A :: C :: D :: nil) = 4) by (apply LOoACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: A :: D :: nil) (C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: nil) (Oo :: A :: D :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: C :: D :: nil) ((Oo :: A :: D :: nil) ++ (C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDmtmp;try rewrite HT2 in HOoACDmtmp.
	assert(HT := rule_4 (Oo :: A :: D :: nil) (C :: D :: nil) (D :: nil) 4 1 3 HOoACDmtmp HDmtmp HOoADMtmp Hincl); apply HT.
}


assert(HCDM : rk(C :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCDeq HCDM2).
assert(HCDm : rk(C :: D ::  nil) >= 1) by (solve_hyps_min HCDeq HCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCD requis par la preuve de (?)OoCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCD requis par la preuve de (?)OoCD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCDm2 : rk(Oo :: C :: D :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApDmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: D ::   de rang : 2 et 2 *)
assert(HOoCDm3 : rk(Oo :: C :: D :: nil) >= 3).
{
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADMtmp : rk(A :: D :: nil) <= 2) by (solve_hyps_max HADeq HADM2).
	try assert(HOoACDeq : rk(Oo :: A :: C :: D :: nil) = 4) by (apply LOoACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (Oo :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: nil) (A :: D :: Oo :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Oo :: C :: D :: nil) ((A :: D :: nil) ++ (Oo :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDmtmp;try rewrite HT2 in HOoACDmtmp.
	assert(HT := rule_4 (A :: D :: nil) (Oo :: C :: D :: nil) (D :: nil) 4 1 2 HOoACDmtmp HDmtmp HADMtmp Hincl); apply HT.
}


assert(HOoCDM : rk(Oo :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCDeq HOoCDM3).
assert(HOoCDm : rk(Oo :: C :: D ::  nil) >= 1) by (solve_hyps_min HOoCDeq HOoCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACD requis par la preuve de (?)ACD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)ACD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACD requis par la preuve de (?)ACD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACDm2 : rk(A :: C :: D :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: nil) (A :: nil) 4 1 3 HOoABCApDmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HACDm3 : rk(A :: C :: D :: nil) >= 3).
{
	try assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	try assert(HOoACDeq : rk(Oo :: A :: C :: D :: nil) = 4) by (apply LOoACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: nil) (Oo :: D :: A :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: C :: D :: nil) ((Oo :: D :: nil) ++ (A :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDmtmp;try rewrite HT2 in HOoACDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (A :: C :: D :: nil) (D :: nil) 4 1 2 HOoACDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}


assert(HACDM : rk(A :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACDeq HACDM3).
assert(HACDm : rk(A :: C :: D ::  nil) >= 1) by (solve_hyps_min HACDeq HACDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCD *)
(* dans la couche 0 *)
Lemma LOoBCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoBCDM : rk(Oo :: B :: C :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCDm : rk(Oo :: B :: C :: D ::  nil) >= 1) by (solve_hyps_min HOoBCDeq HOoBCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCD requis par la preuve de (?)BCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)BCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCD requis par la preuve de (?)BCD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCDm2 : rk(B :: C :: D :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: B :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: D :: nil) (nil) 4 0 2 HOoABCApDmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HBCDm3 : rk(B :: C :: D :: nil) >= 3).
{
	try assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	try assert(HOoBCDeq : rk(Oo :: B :: C :: D :: nil) = 4) by (apply LOoBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (B :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: D :: nil) (Oo :: D :: B :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: B :: C :: D :: nil) ((Oo :: D :: nil) ++ (B :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCDmtmp;try rewrite HT2 in HOoBCDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (B :: C :: D :: nil) (D :: nil) 4 1 2 HOoBCDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}


assert(HBCDM : rk(B :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCDeq HBCDM3).
assert(HBCDm : rk(B :: C :: D ::  nil) >= 1) by (solve_hyps_min HBCDeq HBCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HABCDM : rk(A :: B :: C :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCDm : rk(A :: B :: C :: D ::  nil) >= 1) by (solve_hyps_min HABCDeq HABCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCD requis par la preuve de (?)OoABCD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCDm4 : rk(Oo :: A :: B :: C :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCDM : rk(Oo :: A :: B :: C :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDm : rk(Oo :: A :: B :: C :: D ::  nil) >= 1) by (solve_hyps_min HOoABCDeq HOoABCDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApD *)
(* dans la couche 0 *)
Lemma LOoABCApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApDM : rk(Oo :: A :: B :: C :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDm : rk(Oo :: A :: B :: C :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApDeq HOoABCApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApD requis par la preuve de (?)OoBCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDm4 : rk(Oo :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApDeq : rk(Oo :: A :: B :: C :: Ap :: D :: nil) = 4) by (apply LOoABCApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApDM : rk(Oo :: B :: C :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDm : rk(Oo :: B :: C :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HOoBCApDeq HOoBCApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDm3 : rk(A :: B :: C :: Ap :: D :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApDeq : rk(Oo :: A :: B :: C :: Ap :: D :: nil) = 4) by (apply LOoABCApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDm4 : rk(A :: B :: C :: Ap :: D :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApDeq : rk(Oo :: A :: B :: C :: Ap :: D :: nil) = 4) by (apply LOoABCApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HABCApDM : rk(A :: B :: C :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDm : rk(A :: B :: C :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HABCApDeq HABCApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABCApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpDM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Dp ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HDpM : rk(Dp ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max HDpeq HDpM1).
assert(HDpm : rk(Dp ::  nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoDp requis par la preuve de (?)OoDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoDpm2 : rk(Oo :: Dp :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	try assert(HOoApBpDpeq : rk(Oo :: Ap :: Bp :: Dp :: nil) = 4) by (apply LOoApBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApBpDpmtmp : rk(Oo :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoApBpDpeq HOoApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: nil) (Oo :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Dp :: nil) (Ap :: Bp :: Oo :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Oo :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Oo :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpDpmtmp;try rewrite HT2 in HOoApBpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Oo :: Dp :: nil) (nil) 4 0 2 HOoApBpDpmtmp Hmtmp HApBpMtmp Hincl); apply HT.
}


assert(HOoDpM : rk(Oo :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoDpeq HOoDpM2).
assert(HOoDpm : rk(Oo :: Dp ::  nil) >= 1) by (solve_hyps_min HOoDpeq HOoDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoADp *)
(* dans la couche 0 *)
Lemma LOoADDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoADDp requis par la preuve de (?)OoADDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoADDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABCApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDDpm2 : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpeq HOoABCApBpDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpmtmp;try rewrite HT2 in HOoABCApBpDDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil) (nil) 4 0 2 HOoABCApBpDDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoABCApBpDDpM1. try clear HOoABCApBpDDpM2. try clear HOoABCApBpDDpM3. try clear HOoABCApBpDDpm4. try clear HOoABCApBpDDpm3. try clear HOoABCApBpDDpm2. try clear HOoABCApBpDDpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDDpm3 : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoADDp requis par la preuve de (?)OoADDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour OoDDp requis par la preuve de (?)OoADDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoADDp requis par la preuve de (?)OoADDp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoADDpM3 : rk(Oo :: A :: D :: Dp :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: Dp :: nil) (A :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Oo :: D :: Dp :: nil) ((A :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Oo :: D :: Dp :: nil) (nil) 1 2 0 HAMtmp HOoDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: D :: Dp ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoADDpm2 : rk(Oo :: A :: D :: Dp :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDDpmtmp : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoABBpDDpeq HOoABBpDDpm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: D :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDDpmtmp;try rewrite HT2 in HOoABBpDDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: D :: Dp :: nil) (Oo :: nil) 3 1 2 HOoABBpDDpmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoABBpDDpM1. try clear HOoABBpDDpM2. try clear HOoABBpDDpM3. try clear HOoABBpDDpm4. try clear HOoABBpDDpm3. try clear HOoABBpDDpm2. try clear HOoABBpDDpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoADDpm3 : rk(Oo :: A :: D :: Dp :: nil) >= 3).
{
	try assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: D :: Dp :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}


assert(HOoADDpM : rk(Oo :: A :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoADDpm : rk(Oo :: A :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoADDpeq HOoADDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoADp *)
(* dans la couche 0 *)
Lemma LOoDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoDDpM : rk(Oo :: D :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoDDpeq HOoDDpM3).
assert(HOoDDpm : rk(Oo :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoDDpeq HOoDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoADp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoADp requis par la preuve de (?)OoADp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoADp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDpm2 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) (nil) 4 0 2 HOoABCApBpDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDpm3 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoADp requis par la preuve de (?)OoADp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: Dp ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoADpm2 : rk(Oo :: A :: Dp :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDpmtmp : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoABBpDpeq HOoABBpDpm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDpmtmp;try rewrite HT2 in HOoABBpDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: Dp :: nil) (Oo :: nil) 3 1 2 HOoABBpDpmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoADpm3 : rk(Oo :: A :: Dp :: nil) >= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoADDpeq : rk(Oo :: A :: D :: Dp :: nil) = 3) by (apply LOoADDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoADDpmtmp : rk(Oo :: A :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoADDpeq HOoADDpm3).
	try assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: A :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: Dp :: nil) (Oo :: A :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: A :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoADDpmtmp;try rewrite HT2 in HOoADDpmtmp.
	assert(HT := rule_2 (Oo :: A :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 3 2 2 HOoADDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}


assert(HOoADpM : rk(Oo :: A :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoADpeq HOoADpM3).
assert(HOoADpm : rk(Oo :: A :: Dp ::  nil) >= 1) by (solve_hyps_min HOoADpeq HOoADpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBDp *)
(* dans la couche 0 *)
Lemma LOoBDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBDDp requis par la preuve de (?)OoBDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDDp requis par la preuve de (?)OoBDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoBCApDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDp requis par la preuve de (?)OoBCApDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBDDp requis par la preuve de (?)OoBDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBDDp requis par la preuve de (?)OoBDDp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBDDpM3 : rk(Oo :: B :: D :: Dp :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: D :: Dp :: nil) (B :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: D :: Dp :: nil) ((B :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Oo :: D :: Dp :: nil) (nil) 1 2 0 HBMtmp HOoDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBDDpm2 : rk(Oo :: B :: D :: Dp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApDDpmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCApDDpeq HOoBCApDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: nil) (C :: Ap :: Oo :: B :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: D :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpmtmp;try rewrite HT2 in HOoBCApDDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: D :: Dp :: nil) (nil) 4 0 2 HOoBCApDDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBDDpm3 : rk(Oo :: B :: D :: Dp :: nil) >= 3).
{
	try assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: nil) (Oo :: B :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: D :: nil) (Oo :: B :: D :: Dp :: nil) 3 3 HOoBDmtmp Hcomp Hincl);apply HT.
}


assert(HOoBDDpM : rk(Oo :: B :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBDDpm : rk(Oo :: B :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBDDpeq HOoBDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBDp requis par la preuve de (?)OoBDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDp requis par la preuve de (?)OoBDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoBCApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDp requis par la preuve de (?)OoBCApDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpm4 : rk(Oo :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBDp requis par la preuve de (?)OoBDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBDpm2 : rk(Oo :: B :: Dp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApDpmtmp : rk(Oo :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCApDpeq HOoBCApDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Dp :: nil) (C :: Ap :: Oo :: B :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDpmtmp;try rewrite HT2 in HOoBCApDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Dp :: nil) (nil) 4 0 2 HOoBCApDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApDpM1. try clear HOoBCApDpM2. try clear HOoBCApDpM3. try clear HOoBCApDpm4. try clear HOoBCApDpm3. try clear HOoBCApDpm2. try clear HOoBCApDpm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBDpm3 : rk(Oo :: B :: Dp :: nil) >= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoBDDpeq : rk(Oo :: B :: D :: Dp :: nil) = 3) by (apply LOoBDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBDDpmtmp : rk(Oo :: B :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoBDDpeq HOoBDDpm3).
	try assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: B :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: D :: Dp :: nil) (Oo :: B :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: B :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBDDpmtmp;try rewrite HT2 in HOoBDDpmtmp.
	assert(HT := rule_2 (Oo :: B :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 3 2 2 HOoBDDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}


assert(HOoBDpM : rk(Oo :: B :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBDpeq HOoBDpM3).
assert(HOoBDpm : rk(Oo :: B :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBDpeq HOoBDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABDp *)
(* dans la couche 0 *)
Lemma LOoABDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABDDp requis par la preuve de (?)OoABDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDDp requis par la preuve de (?)OoABCCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCCpDDpm4 : rk(Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABDDpm2 : rk(Oo :: A :: B :: D :: Dp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: D :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: D :: Dp :: nil) (nil) 4 0 2 HOoABCApDDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABDDpm3 : rk(Oo :: A :: B :: D :: Dp :: nil) >= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpDDpmtmp : rk(Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCCpDDpeq HOoABCCpDDpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: D :: Dp :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDDpmtmp;try rewrite HT2 in HOoABCCpDDpmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCCpDDpmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}
try clear HOoABCCpDDpM1. try clear HOoABCCpDDpM2. try clear HOoABCCpDDpM3. try clear HOoABCCpDDpm4. try clear HOoABCCpDDpm3. try clear HOoABCCpDDpm2. try clear HOoABCCpDDpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABDDpm4 : rk(Oo :: A :: B :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: Dp :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}


assert(HOoABDDpM : rk(Oo :: A :: B :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDDpm : rk(Oo :: A :: B :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABDDpeq HOoABDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABDp requis par la preuve de (?)OoABDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpDp requis par la preuve de (?)OoABDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDp requis par la preuve de (?)OoABCCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCCpDpm4 : rk(Oo :: A :: B :: C :: Cp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABDp requis par la preuve de (?)OoABDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABDp requis par la preuve de (?)OoABDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABDpm2 : rk(Oo :: A :: B :: Dp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Dp :: nil) (nil) 4 0 2 HOoABCApDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABDpm3 : rk(Oo :: A :: B :: Dp :: nil) >= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpDpmtmp : rk(Oo :: A :: B :: C :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCCpDpeq HOoABCCpDpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: Dp :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: Dp :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDpmtmp;try rewrite HT2 in HOoABCCpDpmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCCpDpmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABDpm4 : rk(Oo :: A :: B :: Dp :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoABDDpeq : rk(Oo :: A :: B :: D :: Dp :: nil) = 4) by (apply LOoABDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDDpmtmp : rk(Oo :: A :: B :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABDDpeq HOoABDDpm4).
	try assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: A :: B :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: Dp :: nil) (Oo :: A :: B :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: A :: B :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDDpmtmp;try rewrite HT2 in HOoABDDpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 4 2 2 HOoABDDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}


assert(HOoABDpM : rk(Oo :: A :: B :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDpm : rk(Oo :: A :: B :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABDpeq HOoABDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCDp *)
(* dans la couche 0 *)
Lemma LOoCDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCDDp requis par la preuve de (?)OoCDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDDp requis par la preuve de (?)OoCDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoBCApDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDp requis par la preuve de (?)OoBCApDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCDDp requis par la preuve de (?)OoCDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCDDp requis par la preuve de (?)OoCDDp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoCDDpM3 : rk(Oo :: C :: D :: Dp :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: D :: Dp :: nil) (C :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: D :: Dp :: nil) ((C :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: D :: Dp :: nil) (nil) 1 2 0 HCMtmp HOoDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCDDpm2 : rk(Oo :: C :: D :: Dp :: nil) >= 2).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApDDpmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCApDDpeq HOoBCApDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: nil) (B :: Ap :: Oo :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: D :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpmtmp;try rewrite HT2 in HOoBCApDDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: D :: Dp :: nil) (nil) 4 0 2 HOoBCApDDpmtmp Hmtmp HBApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCDDpm3 : rk(Oo :: C :: D :: Dp :: nil) >= 3).
{
	try assert(HOoCDeq : rk(Oo :: C :: D :: nil) = 3) by (apply LOoCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCDmtmp : rk(Oo :: C :: D :: nil) >= 3) by (solve_hyps_min HOoCDeq HOoCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: D :: nil) (Oo :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: D :: nil) (Oo :: C :: D :: Dp :: nil) 3 3 HOoCDmtmp Hcomp Hincl);apply HT.
}


assert(HOoCDDpM : rk(Oo :: C :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCDDpm : rk(Oo :: C :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCDDpeq HOoCDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCDp requis par la preuve de (?)OoCDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoCDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCDp requis par la preuve de (?)OoCDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCDpm2 : rk(Oo :: C :: Dp :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApDpmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCDpm3 : rk(Oo :: C :: Dp :: nil) >= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoCDDpeq : rk(Oo :: C :: D :: Dp :: nil) = 3) by (apply LOoCDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCDDpmtmp : rk(Oo :: C :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoCDDpeq HOoCDDpm3).
	try assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: C :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: D :: Dp :: nil) (Oo :: C :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: C :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCDDpmtmp;try rewrite HT2 in HOoCDDpmtmp.
	assert(HT := rule_2 (Oo :: C :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 3 2 2 HOoCDDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}


assert(HOoCDpM : rk(Oo :: C :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCDpeq HOoCDpM3).
assert(HOoCDpm : rk(Oo :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCDpeq HOoCDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACDp *)
(* dans la couche 0 *)
Lemma LOoACDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACDDp requis par la preuve de (?)OoACDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDDp requis par la preuve de (?)OoABCBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpDDpm4 : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoA requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoACDDpm2 : rk(Oo :: A :: C :: D :: Dp :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 1) by (solve_hyps_min HOoAeq HOoAm1).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: C :: D :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: C :: D :: Dp :: nil) (Oo :: A :: nil) 4 1 3 HOoABCApDDpmtmp HOoAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACDDpm3 : rk(Oo :: A :: C :: D :: Dp :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpDDpmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCBpDDpeq HOoABCBpDDpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: D :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDDpmtmp;try rewrite HT2 in HOoABCBpDDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCBpDDpmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoABCBpDDpM1. try clear HOoABCBpDDpM2. try clear HOoABCBpDDpM3. try clear HOoABCBpDDpm4. try clear HOoABCBpDDpm3. try clear HOoABCBpDDpm2. try clear HOoABCBpDDpm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACDDpm4 : rk(Oo :: A :: C :: D :: Dp :: nil) >= 4).
{
	try assert(HOoACDeq : rk(Oo :: A :: C :: D :: nil) = 4) by (apply LOoACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: D :: Dp :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}


assert(HOoACDDpM : rk(Oo :: A :: C :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACDDpm : rk(Oo :: A :: C :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoACDDpeq HOoACDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACDp requis par la preuve de (?)OoACDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDp requis par la preuve de (?)OoACDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDp requis par la preuve de (?)OoABCBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpDpm4 : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACDp requis par la preuve de (?)OoACDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoACDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoA requis par la preuve de (?)OoACDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACDp requis par la preuve de (?)OoACDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoACDpm2 : rk(Oo :: A :: C :: Dp :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 1) by (solve_hyps_min HOoAeq HOoAm1).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: C :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: C :: Dp :: nil) (Oo :: A :: nil) 4 1 3 HOoABCApDpmtmp HOoAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACDpm3 : rk(Oo :: A :: C :: Dp :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpDpmtmp : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCBpDpeq HOoABCBpDpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDpmtmp;try rewrite HT2 in HOoABCBpDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCBpDpmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACDpm4 : rk(Oo :: A :: C :: Dp :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoACDDpeq : rk(Oo :: A :: C :: D :: Dp :: nil) = 4) by (apply LOoACDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDDpmtmp : rk(Oo :: A :: C :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoACDDpeq HOoACDDpm4).
	try assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: A :: C :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: Dp :: nil) (Oo :: A :: C :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: A :: C :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDDpmtmp;try rewrite HT2 in HOoACDDpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 4 2 2 HOoACDDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}


assert(HOoACDpM : rk(Oo :: A :: C :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACDpm : rk(Oo :: A :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HOoACDpeq HOoACDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCDp *)
(* dans la couche 0 *)
Lemma LOoBCDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCDDp requis par la preuve de (?)OoBCDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoBCDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCDDp requis par la preuve de (?)OoBCDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDDpm3 : rk(Oo :: B :: C :: D :: Dp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCApDDpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCDDpm4 : rk(Oo :: B :: C :: D :: Dp :: nil) >= 4).
{
	try assert(HOoBCDeq : rk(Oo :: B :: C :: D :: nil) = 4) by (apply LOoBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: D :: Dp :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCDDpM : rk(Oo :: B :: C :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCDDpm : rk(Oo :: B :: C :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCDDpeq HOoBCDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCDp requis par la preuve de (?)OoBCDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoBCDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCDp requis par la preuve de (?)OoBCDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDpm3 : rk(Oo :: B :: C :: Dp :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCApDpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBCDpm4 : rk(Oo :: B :: C :: Dp :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoBCDDpeq : rk(Oo :: B :: C :: D :: Dp :: nil) = 4) by (apply LOoBCDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCDDpmtmp : rk(Oo :: B :: C :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCDDpeq HOoBCDDpm4).
	try assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: B :: C :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: D :: Dp :: nil) (Oo :: B :: C :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: B :: C :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCDDpmtmp;try rewrite HT2 in HOoBCDDpmtmp.
	assert(HT := rule_2 (Oo :: B :: C :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 4 2 2 HOoBCDDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}
try clear HOoDpM1. try clear HOoDpM2. try clear HOoDpM3. try clear HOoDpm4. try clear HOoDpm3. try clear HOoDpm2. try clear HOoDpm1. 

assert(HOoBCDpM : rk(Oo :: B :: C :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCDpm : rk(Oo :: B :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCDpeq HOoBCDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDp requis par la preuve de (?)OoABCDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCDpm4 : rk(Oo :: A :: B :: C :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCDpM : rk(Oo :: A :: B :: C :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDpm : rk(Oo :: A :: B :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCDpeq HOoABCDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApDp requis par la preuve de (?)ApDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Dp ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HApDpm2 : rk(Ap :: Dp :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	try assert(HApBpDpeq : rk(Ap :: Bp :: Dp :: nil) = 3) by (apply LApBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpDpmtmp : rk(Ap :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HApBpDpeq HApBpDpm3).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Ap :: Bp :: nil) (Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Dp :: nil) (Ap :: Bp :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Ap :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpDpmtmp;try rewrite HT2 in HApBpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Ap :: Dp :: nil) (Ap :: nil) 3 1 2 HApBpDpmtmp HApmtmp HApBpMtmp Hincl); apply HT.
}


assert(HApDpM : rk(Ap :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApDpeq HApDpM2).
assert(HApDpm : rk(Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HApDpeq HApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApDp requis par la preuve de (?)OoApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDp requis par la preuve de (?)OoApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDp requis par la preuve de (?)OoABApDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDp requis par la preuve de (?)OoABApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDpm2 : rk(Oo :: A :: B :: Ap :: Dp :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDpm3 : rk(Oo :: A :: B :: Ap :: Dp :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApDp requis par la preuve de (?)OoApDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Dp ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApDpm2 : rk(Oo :: Ap :: Dp :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDpmtmp : rk(Oo :: A :: B :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoABApDpeq HOoABApDpm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDpmtmp;try rewrite HT2 in HOoABApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Dp :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApDpmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApDpM1. try clear HOoABApDpM2. try clear HOoABApDpM3. try clear HOoABApDpm4. try clear HOoABApDpm3. try clear HOoABApDpm2. try clear HOoABApDpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HOoApDpm3 : rk(Oo :: Ap :: Dp :: nil) >= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HOoApBpDpeq : rk(Oo :: Ap :: Bp :: Dp :: nil) = 4) by (apply LOoApBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApBpDpmtmp : rk(Oo :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoApBpDpeq HOoApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (Oo :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Dp :: nil) (Bp :: Oo :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Oo :: Ap :: Dp :: nil) ((Bp :: nil) ++ (Oo :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpDpmtmp;try rewrite HT2 in HOoApBpDpmtmp.
	assert(HT := rule_4 (Bp :: nil) (Oo :: Ap :: Dp :: nil) (nil) 4 0 1 HOoApBpDpmtmp Hmtmp HBpMtmp Hincl); apply HT.
}


assert(HOoApDpM : rk(Oo :: Ap :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApDpeq HOoApDpM3).
assert(HOoApDpm : rk(Oo :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HOoApDpeq HOoApDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApDp *)
(* dans la couche 0 *)
Lemma LOoABCApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApDpM : rk(Oo :: A :: B :: C :: Ap :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDpm : rk(Oo :: A :: B :: C :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApDp requis par la preuve de (?)OoAApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApDp requis par la preuve de (?)OoAApDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApDp requis par la preuve de (?)OoAApDp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoAApDpM3 : rk(Oo :: A :: Ap :: Dp :: nil) <= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HDpeq : rk(Dp :: nil) = 1) by (apply LDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Dp :: nil) (Oo :: A :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Dp :: nil) (nil) 2 1 0 HOoAApMtmp HDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDpm2 : rk(Oo :: A :: Ap :: Dp :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Dp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: Dp ::   de rang : 4 et 4 *)
assert(HOoAApDpm3 : rk(Oo :: A :: Ap :: Dp :: nil) >= 3).
{
	try assert(HOoABCDpeq : rk(Oo :: A :: B :: C :: Dp :: nil) = 4) by (apply LOoABCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCDpMtmp : rk(Oo :: A :: B :: C :: Dp :: nil) <= 4) by (solve_hyps_max HOoABCDpeq HOoABCDpM4).
	try assert(HOoABCApDpeq : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) = 4) by (apply LOoABCApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	try assert(HOoADpeq : rk(Oo :: A :: Dp :: nil) = 3) by (apply LOoADp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoADpmtmp : rk(Oo :: A :: Dp :: nil) >= 3) by (solve_hyps_min HOoADpeq HOoADpm3).
	assert(Hincl : incl (Oo :: A :: Dp :: nil) (list_inter (Oo :: A :: B :: C :: Dp :: nil) (Oo :: A :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: B :: C :: Dp :: Oo :: A :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Dp :: Oo :: A :: Ap :: Dp :: nil) ((Oo :: A :: B :: C :: Dp :: nil) ++ (Oo :: A :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Dp :: nil) (Oo :: A :: Ap :: Dp :: nil) (Oo :: A :: Dp :: nil) 4 3 4 HOoABCApDpmtmp HOoADpmtmp HOoABCDpMtmp Hincl); apply HT.
}


assert(HOoAApDpM : rk(Oo :: A :: Ap :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDpm : rk(Oo :: A :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HOoAApDpeq HOoAApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDp requis par la preuve de (?)OoBCApDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpm4 : rk(Oo :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApDpeq : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) = 4) by (apply LOoABCApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApDpM : rk(Oo :: B :: C :: Ap :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDpm : rk(Oo :: B :: C :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCApDpeq HOoBCApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpDp requis par la preuve de (?)BpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Dp ::  de rang :  3 et 3 	 AiB : Bp ::  de rang :  1 et 1 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBpDpm2 : rk(Bp :: Dp :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	try assert(HApBpDpeq : rk(Ap :: Bp :: Dp :: nil) = 3) by (apply LApBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpDpmtmp : rk(Ap :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HApBpDpeq HApBpDpm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: nil) (Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Dp :: nil) (Ap :: Bp :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Bp :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpDpmtmp;try rewrite HT2 in HApBpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Bp :: Dp :: nil) (Bp :: nil) 3 1 2 HApBpDpmtmp HBpmtmp HApBpMtmp Hincl); apply HT.
}
try clear HApBpDpM1. try clear HApBpDpM2. try clear HApBpDpM3. try clear HApBpDpm4. try clear HApBpDpm3. try clear HApBpDpm2. try clear HApBpDpm1. 

assert(HBpDpM : rk(Bp :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpDpeq HBpDpM2).
assert(HBpDpm : rk(Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HBpDpeq HBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpDp requis par la preuve de (?)OoBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpDp requis par la preuve de (?)OoBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpDp requis par la preuve de (?)OoBBpDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpDp requis par la preuve de (?)OoBBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoBCApBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpDp requis par la preuve de (?)OoBCApBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpDpm4 : rk(Oo :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpDp requis par la preuve de (?)OoBBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpDpm2 : rk(Oo :: B :: Bp :: Dp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpDpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCApBpDpeq HOoBCApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Dp :: nil) (C :: Ap :: Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpDpmtmp;try rewrite HT2 in HOoBCApBpDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: Dp :: nil) (nil) 4 0 2 HOoBCApBpDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApBpDpM1. try clear HOoBCApBpDpM2. try clear HOoBCApBpDpM3. try clear HOoBCApBpDpm4. try clear HOoBCApBpDpm3. try clear HOoBCApBpDpm2. try clear HOoBCApBpDpm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBBpDpM3 : rk(Oo :: B :: Bp :: Dp :: nil) <= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HDpeq : rk(Dp :: nil) = 1) by (apply LDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (Dp :: nil) (nil) 2 1 0 HOoBBpMtmp HDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpDp requis par la preuve de (?)OoBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Dp ::  de rang :  2 et 3 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpDpm2 : rk(Oo :: Bp :: Dp :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpDpmtmp : rk(Oo :: B :: Bp :: Dp :: nil) >= 2) by (solve_hyps_min HOoBBpDpeq HOoBBpDpm2).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Oo :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Bp :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpDpmtmp;try rewrite HT2 in HOoBBpDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Bp :: Dp :: nil) (Oo :: Bp :: nil) 2 2 2 HOoBBpDpmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpDpm3 : rk(Oo :: Bp :: Dp :: nil) >= 3).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	try assert(HOoApBpDpeq : rk(Oo :: Ap :: Bp :: Dp :: nil) = 4) by (apply LOoApBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApBpDpmtmp : rk(Oo :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoApBpDpeq HOoApBpDpm4).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: nil) (Oo :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Dp :: nil) (Ap :: Bp :: Oo :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Oo :: Bp :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Oo :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpDpmtmp;try rewrite HT2 in HOoApBpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Oo :: Bp :: Dp :: nil) (Bp :: nil) 4 1 2 HOoApBpDpmtmp HBpmtmp HApBpMtmp Hincl); apply HT.
}
try clear HOoApBpDpM1. try clear HOoApBpDpM2. try clear HOoApBpDpM3. try clear HOoApBpDpm4. try clear HOoApBpDpm3. try clear HOoApBpDpm2. try clear HOoApBpDpm1. 

assert(HOoBpDpM : rk(Oo :: Bp :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpDpeq HOoBpDpM3).
assert(HOoBpDpm : rk(Oo :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBpDpeq HOoBpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpDp *)
(* dans constructLemma(), requis par LOoABBpDp *)
(* dans la couche 0 *)
Lemma LOoABCBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDp requis par la preuve de (?)OoABCBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpDpm4 : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCBpDpM : rk(Oo :: A :: B :: C :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDpm : rk(Oo :: A :: B :: C :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCBpDpeq HOoABCBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDpm2 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) (nil) 4 0 2 HOoABCApBpDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDpm3 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: A :: B :: Dp ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: Dp ::   de rang : 4 et 4 *)
assert(HOoABBpDpm4 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoABCDpeq : rk(Oo :: A :: B :: C :: Dp :: nil) = 4) by (apply LOoABCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCDpMtmp : rk(Oo :: A :: B :: C :: Dp :: nil) <= 4) by (solve_hyps_max HOoABCDpeq HOoABCDpM4).
	try assert(HOoABCBpDpeq : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) = 4) by (apply LOoABCBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCBpDpmtmp : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCBpDpeq HOoABCBpDpm4).
	try assert(HOoABDpeq : rk(Oo :: A :: B :: Dp :: nil) = 4) by (apply LOoABDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDpmtmp : rk(Oo :: A :: B :: Dp :: nil) >= 4) by (solve_hyps_min HOoABDpeq HOoABDpm4).
	assert(Hincl : incl (Oo :: A :: B :: Dp :: nil) (list_inter (Oo :: A :: B :: C :: Dp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Dp :: nil) (Oo :: A :: B :: C :: Dp :: Oo :: A :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Dp :: Oo :: A :: B :: Bp :: Dp :: nil) ((Oo :: A :: B :: C :: Dp :: nil) ++ (Oo :: A :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDpmtmp;try rewrite HT2 in HOoABCBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Dp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) (Oo :: A :: B :: Dp :: nil) 4 4 4 HOoABCBpDpmtmp HOoABDpmtmp HOoABCDpMtmp Hincl); apply HT.
}


assert(HOoABBpDpM : rk(Oo :: A :: B :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpDpm : rk(Oo :: A :: B :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABBpDpeq HOoABBpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpDp *)
(* dans la couche 0 *)
Lemma LOoBBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpDp requis par la preuve de (?)OoBBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpDp requis par la preuve de (?)OoBBpDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpDp requis par la preuve de (?)OoBBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoBCApBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpDp requis par la preuve de (?)OoBCApBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpDpm4 : rk(Oo :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpDp requis par la preuve de (?)OoBBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpDpm2 : rk(Oo :: B :: Bp :: Dp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpDpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCApBpDpeq HOoBCApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Dp :: nil) (C :: Ap :: Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpDpmtmp;try rewrite HT2 in HOoBCApBpDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: Dp :: nil) (nil) 4 0 2 HOoBCApBpDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApBpDpM1. try clear HOoBCApBpDpM2. try clear HOoBCApBpDpM3. try clear HOoBCApBpDpm4. try clear HOoBCApBpDpm3. try clear HOoBCApBpDpm2. try clear HOoBCApBpDpm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBBpDpM3 : rk(Oo :: B :: Bp :: Dp :: nil) <= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(HDpeq : rk(Dp :: nil) = 1) by (apply LDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (Dp :: nil) (nil) 2 1 0 HOoBBpMtmp HDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: B :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: Dp ::   de rang : 4 et 4 *)
assert(HOoBBpDpm3 : rk(Oo :: B :: Bp :: Dp :: nil) >= 3).
{
	try assert(HOoABCDpeq : rk(Oo :: A :: B :: C :: Dp :: nil) = 4) by (apply LOoABCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCDpMtmp : rk(Oo :: A :: B :: C :: Dp :: nil) <= 4) by (solve_hyps_max HOoABCDpeq HOoABCDpM4).
	try assert(HOoABCBpDpeq : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) = 4) by (apply LOoABCBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCBpDpmtmp : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCBpDpeq HOoABCBpDpm4).
	try assert(HOoBDpeq : rk(Oo :: B :: Dp :: nil) = 3) by (apply LOoBDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBDpmtmp : rk(Oo :: B :: Dp :: nil) >= 3) by (solve_hyps_min HOoBDpeq HOoBDpm3).
	assert(Hincl : incl (Oo :: B :: Dp :: nil) (list_inter (Oo :: A :: B :: C :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Dp :: nil) (Oo :: A :: B :: C :: Dp :: Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Dp :: Oo :: B :: Bp :: Dp :: nil) ((Oo :: A :: B :: C :: Dp :: nil) ++ (Oo :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDpmtmp;try rewrite HT2 in HOoABCBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil) (Oo :: B :: Dp :: nil) 4 3 4 HOoABCBpDpmtmp HOoBDpmtmp HOoABCDpMtmp Hincl); apply HT.
}


assert(HOoBBpDpM : rk(Oo :: B :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpDpm : rk(Oo :: B :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBBpDpeq HOoBBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpDp requis par la preuve de (?)OoABpDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDpm2 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) (nil) 4 0 2 HOoABCApBpDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDpm3 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpDp requis par la preuve de (?)OoABpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: Dp ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpDpm3 : rk(Oo :: A :: Bp :: Dp :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDpmtmp : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoABBpDpeq HOoABBpDpm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: Bp :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDpmtmp;try rewrite HT2 in HOoABBpDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: Dp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABBpDpmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpDpm4 : rk(Oo :: A :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	try assert(HOoABBpDpeq : rk(Oo :: A :: B :: Bp :: Dp :: nil) = 4) by (apply LOoABBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABBpDpmtmp : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABBpDpeq HOoABBpDpm4).
	try assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: A :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: Dp :: nil) (Oo :: A :: Bp :: Dp :: Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: Dp :: Oo :: B :: Bp :: Dp :: nil) ((Oo :: A :: Bp :: Dp :: nil) ++ (Oo :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDpmtmp;try rewrite HT2 in HOoABBpDpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoABBpDpmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl);apply HT.
}


assert(HOoABpDpM : rk(Oo :: A :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpDpm : rk(Oo :: A :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABpDpeq HOoABpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpDp *)
(* dans la couche 0 *)
Lemma LOoABCApBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpDpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpDp requis par la preuve de (?)OoBCApBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpDpm4 : rk(Oo :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpDpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) = 4) by (apply LOoABCApBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApBpDpM : rk(Oo :: B :: C :: Ap :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpDpm : rk(Oo :: B :: C :: Ap :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCApBpDpeq HOoBCApBpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpDp *)
(* dans la couche 0 *)
Lemma LApBpCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HApBpCpDpM : rk(Ap :: Bp :: Cp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpDpm : rk(Ap :: Bp :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HApBpCpDpeq HApBpCpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpDp requis par la preuve de (?)CpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Cp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCpDpm2 : rk(Cp :: Dp :: nil) >= 2).
{
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	try assert(HApBpCpDpeq : rk(Ap :: Bp :: Cp :: Dp :: nil) = 4) by (apply LApBpCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpCpDpmtmp : rk(Ap :: Bp :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HApBpCpDpeq HApBpCpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: nil) (Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) (Ap :: Bp :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpCpDpmtmp;try rewrite HT2 in HApBpCpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Cp :: Dp :: nil) (nil) 4 0 2 HApBpCpDpmtmp Hmtmp HApBpMtmp Hincl); apply HT.
}
try clear HApBpCpDpM1. try clear HApBpCpDpM2. try clear HApBpCpDpM3. try clear HApBpCpDpm4. try clear HApBpCpDpm3. try clear HApBpCpDpm2. try clear HApBpCpDpm1. 

assert(HCpDpM : rk(Cp :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpDpeq HCpDpM2).
assert(HCpDpm : rk(Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HCpDpeq HCpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCpDp *)
(* dans la couche 0 *)
Lemma LOoApCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HOoApCpDpM : rk(Oo :: Ap :: Cp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpDpm : rk(Oo :: Ap :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoApCpDpeq HOoApCpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Cp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCpDp requis par la preuve de (?)OoCpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCpDp requis par la preuve de (?)OoCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCpDpm2 : rk(Oo :: Cp :: Dp :: nil) >= 2).
{
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Cp :: nil) (Oo :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Cp :: nil) (Oo :: Cp :: Dp :: nil) 2 2 HOoCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoCpDpm3 : rk(Oo :: Cp :: Dp :: nil) >= 3).
{
	try assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpMtmp : rk(Ap :: Cp :: nil) <= 2) by (solve_hyps_max HApCpeq HApCpM2).
	try assert(HOoApCpDpeq : rk(Oo :: Ap :: Cp :: Dp :: nil) = 4) by (apply LOoApCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApCpDpmtmp : rk(Oo :: Ap :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HOoApCpDpeq HOoApCpDpm4).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Ap :: Cp :: nil) (Oo :: Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: Dp :: nil) (Ap :: Cp :: Oo :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: Oo :: Cp :: Dp :: nil) ((Ap :: Cp :: nil) ++ (Oo :: Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApCpDpmtmp;try rewrite HT2 in HOoApCpDpmtmp.
	assert(HT := rule_4 (Ap :: Cp :: nil) (Oo :: Cp :: Dp :: nil) (Cp :: nil) 4 1 2 HOoApCpDpmtmp HCpmtmp HApCpMtmp Hincl); apply HT.
}
try clear HApCpM1. try clear HApCpM2. try clear HApCpM3. try clear HApCpm4. try clear HApCpm3. try clear HApCpm2. try clear HApCpm1. try clear HOoApCpDpM1. try clear HOoApCpDpM2. try clear HOoApCpDpM3. try clear HOoApCpDpm4. try clear HOoApCpDpm3. try clear HOoApCpDpm2. try clear HOoApCpDpm1. 

assert(HOoCpDpM : rk(Oo :: Cp :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCpDpeq HOoCpDpM3).
assert(HOoCpDpm : rk(Oo :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCpDpeq HOoCpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCCpDp *)
(* dans la couche 0 *)
Lemma LOoABCCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDp requis par la preuve de (?)OoABCCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCCpDpm4 : rk(Oo :: A :: B :: C :: Cp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCCpDpM : rk(Oo :: A :: B :: C :: Cp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpDpm : rk(Oo :: A :: B :: C :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCCpDpeq HOoABCCpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Cp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCCpDp requis par la preuve de (?)OoCCpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCCpDp requis par la preuve de (?)OoCCpDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpDp requis par la preuve de (?)OoCCpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDp requis par la preuve de (?)OoABCApCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCCpDp requis par la preuve de (?)OoCCpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCCpDpm2 : rk(Oo :: C :: Cp :: Dp :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpDpeq HOoABCApCpDpm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDpmtmp;try rewrite HT2 in HOoABCApCpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApCpDpmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApCpDpM1. try clear HOoABCApCpDpM2. try clear HOoABCApCpDpM3. try clear HOoABCApCpDpm4. try clear HOoABCApCpDpm3. try clear HOoABCApCpDpm2. try clear HOoABCApCpDpm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoCCpDpM3 : rk(Oo :: C :: Cp :: Dp :: nil) <= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	try assert(HDpeq : rk(Dp :: nil) = 1) by (apply LDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: C :: Cp :: nil) (Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Cp :: Dp :: nil) (Oo :: C :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Dp :: nil) ((Oo :: C :: Cp :: nil) ++ (Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (Dp :: nil) (nil) 2 1 0 HOoCCpMtmp HDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: C :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: Dp ::   de rang : 4 et 4 *)
assert(HOoCCpDpm3 : rk(Oo :: C :: Cp :: Dp :: nil) >= 3).
{
	try assert(HOoABCDpeq : rk(Oo :: A :: B :: C :: Dp :: nil) = 4) by (apply LOoABCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCDpMtmp : rk(Oo :: A :: B :: C :: Dp :: nil) <= 4) by (solve_hyps_max HOoABCDpeq HOoABCDpM4).
	try assert(HOoABCCpDpeq : rk(Oo :: A :: B :: C :: Cp :: Dp :: nil) = 4) by (apply LOoABCCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCCpDpmtmp : rk(Oo :: A :: B :: C :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCCpDpeq HOoABCCpDpm4).
	try assert(HOoCDpeq : rk(Oo :: C :: Dp :: nil) = 3) by (apply LOoCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCDpmtmp : rk(Oo :: C :: Dp :: nil) >= 3) by (solve_hyps_min HOoCDpeq HOoCDpm3).
	assert(Hincl : incl (Oo :: C :: Dp :: nil) (list_inter (Oo :: A :: B :: C :: Dp :: nil) (Oo :: C :: Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: Dp :: nil) (Oo :: A :: B :: C :: Dp :: Oo :: C :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Dp :: Oo :: C :: Cp :: Dp :: nil) ((Oo :: A :: B :: C :: Dp :: nil) ++ (Oo :: C :: Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDpmtmp;try rewrite HT2 in HOoABCCpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Dp :: nil) (Oo :: C :: Cp :: Dp :: nil) (Oo :: C :: Dp :: nil) 4 3 4 HOoABCCpDpmtmp HOoCDpmtmp HOoABCDpMtmp Hincl); apply HT.
}
try clear HOoABCDpM1. try clear HOoABCDpM2. try clear HOoABCDpM3. try clear HOoABCDpm4. try clear HOoABCDpm3. try clear HOoABCDpm2. try clear HOoABCDpm1. 

assert(HOoCCpDpM : rk(Oo :: C :: Cp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCCpDpm : rk(Oo :: C :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCCpDpeq HOoCCpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDp requis par la preuve de (?)OoABCApCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApCpDpM : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpDpm : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpDpeq HOoABCApCpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDDp *)
(* dans la couche 0 *)
Lemma LABDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HABDDpM : rk(A :: B :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDDpm : rk(A :: B :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HABDDpeq HABDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DDp requis par la preuve de (?)DDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: D :: Dp ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: B :: D ::   de rang : 3 et 3 *)
assert(HDDpm2 : rk(D :: Dp :: nil) >= 2).
{
	try assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 3) by (solve_hyps_max HABDeq HABDM3).
	try assert(HABDDpeq : rk(A :: B :: D :: Dp :: nil) = 4) by (apply LABDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDDpmtmp : rk(A :: B :: D :: Dp :: nil) >= 4) by (solve_hyps_min HABDDpeq HABDDpm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: B :: D :: nil) (D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: Dp :: nil) (A :: B :: D :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: D :: Dp :: nil) ((A :: B :: D :: nil) ++ (D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDDpmtmp;try rewrite HT2 in HABDDpmtmp.
	assert(HT := rule_4 (A :: B :: D :: nil) (D :: Dp :: nil) (D :: nil) 4 1 3 HABDDpmtmp HDmtmp HABDMtmp Hincl); apply HT.
}
try clear HABDDpM1. try clear HABDDpM2. try clear HABDDpM3. try clear HABDDpm4. try clear HABDDpm3. try clear HABDDpm2. try clear HABDDpm1. 

assert(HDDpM : rk(D :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDDpeq HDDpM2).
assert(HDDpm : rk(D :: Dp ::  nil) >= 1) by (solve_hyps_min HDDpeq HDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApDDp *)
(* dans la couche 0 *)
Lemma LOoABCApDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApDDpM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDp requis par la preuve de (?)OoBCApDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApDDpeq : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) = 4) by (apply LOoABCApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApDDpM : rk(Oo :: B :: C :: Ap :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDDpm : rk(Oo :: B :: C :: Ap :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCApDDpeq HOoBCApDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDDp requis par la preuve de (?)OoABCBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpDDpm4 : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCBpDDpM : rk(Oo :: A :: B :: C :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDDpm : rk(Oo :: A :: B :: C :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCBpDDpeq HOoABCBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABCApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpDDpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpeq HOoABCApBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDDp requis par la preuve de (?)OoABCCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCCpDDpm4 : rk(Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCCpDDpM : rk(Oo :: A :: B :: C :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpDDpm : rk(Oo :: A :: B :: C :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCCpDDpeq HOoABCCpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ad ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HadM : rk(ad ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Hadeq HadM1).
assert(Hadm : rk(ad ::  nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAad *)
(* dans constructLemma(), requis par LAApDpad *)
(* dans la couche 0 *)
Lemma LOoAApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApDpad requis par la preuve de (?)OoAApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApDpad requis par la preuve de (?)OoAApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApDpad requis par la preuve de (?)OoAApDpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApDpad requis par la preuve de (?)OoAApDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HOoAApDpadM3 : rk(Oo :: A :: Ap :: Dp :: ad :: nil) <= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Dp :: ad :: nil) (Oo :: A :: Ap :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Ap :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Ap :: Dp :: ad :: nil) (Ap :: nil) 2 2 1 HOoAApMtmp HApDpadMtmp HApmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDpadm2 : rk(Oo :: A :: Ap :: Dp :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Dp :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDpadm3 : rk(Oo :: A :: Ap :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoADpeq : rk(Oo :: A :: Dp :: nil) = 3) by (apply LOoADp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoADpmtmp : rk(Oo :: A :: Dp :: nil) >= 3) by (solve_hyps_min HOoADpeq HOoADpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Dp :: nil) (Oo :: A :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Dp :: nil) (Oo :: A :: Ap :: Dp :: ad :: nil) 3 3 HOoADpmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApDpadM : rk(Oo :: A :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDpadm : rk(Oo :: A :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApDpadeq HOoAApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDpad requis par la preuve de (?)AApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDpad requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpad requis par la preuve de (?)OoABCApDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDpad requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDpad requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDpadm3 : rk(A :: B :: C :: Ap :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDpadeq HOoABCApDpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadmtmp;try rewrite HT2 in HOoABCApDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDpadm4 : rk(A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDpadeq HOoABCApDpadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadmtmp;try rewrite HT2 in HOoABCApDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDpadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApDpadM1. try clear HOoABCApDpadM2. try clear HOoABCApDpadM3. try clear HOoABCApDpadm4. try clear HOoABCApDpadm3. try clear HOoABCApDpadm2. try clear HOoABCApDpadm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ApDpad requis par la preuve de (?)AApDpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HAApDpadM3 : rk(A :: Ap :: Dp :: ad :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Dp :: ad :: nil) (A :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Dp :: ad :: nil) ((A :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HAMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApDpadm2 : rk(A :: Ap :: Dp :: ad :: nil) >= 2).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApDpadmtmp : rk(A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HABCApDpadeq HABCApDpadm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Dp :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Dp :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDpadmtmp;try rewrite HT2 in HABCApDpadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil) (Ap :: nil) 4 1 3 HABCApDpadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}
try clear HABCApDpadM1. try clear HABCApDpadM2. try clear HABCApDpadM3. try clear HABCApDpadm4. try clear HABCApDpadm3. try clear HABCApDpadm2. try clear HABCApDpadm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Dp :: ad ::  de rang :  3 et 3 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HAApDpadm3 : rk(A :: Ap :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoAApDpadeq : rk(Oo :: A :: Ap :: Dp :: ad :: nil) = 3) by (apply LOoAApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpadmtmp : rk(Oo :: A :: Ap :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoAApDpadeq HOoAApDpadm3).
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Dp :: ad :: nil) (Oo :: A :: Ap :: A :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: Ap :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApDpadmtmp;try rewrite HT2 in HOoAApDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil) (A :: Ap :: nil) 3 2 2 HOoAApDpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HAApDpadM : rk(A :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDpadm : rk(A :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HAApDpadeq HAApDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAad *)
(* dans la couche 0 *)
Lemma LApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HApDpadM : rk(Ap :: Dp :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApDpadeq HApDpadM3).
assert(HApDpadm : rk(Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HApDpadeq HApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aad requis par la preuve de (?)Aad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAadm2 : rk(A :: ad :: nil) >= 2).
{
	try assert(HApDpadeq : rk(Ap :: Dp :: ad :: nil) = 2) by (apply LApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	try assert(HAApDpadeq : rk(A :: Ap :: Dp :: ad :: nil) = 3) by (apply LAApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApDpadmtmp : rk(A :: Ap :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HAApDpadeq HAApDpadm3).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (A :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Dp :: ad :: nil) (A :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ad :: Ap :: Dp :: ad :: nil) ((A :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDpadmtmp;try rewrite HT2 in HAApDpadmtmp.
	assert(HT := rule_2 (A :: ad :: nil) (Ap :: Dp :: ad :: nil) (ad :: nil) 3 1 2 HAApDpadmtmp Hadmtmp HApDpadMtmp Hincl);apply HT.
}


assert(HAadM : rk(A :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAadeq HAadM2).
assert(HAadm : rk(A :: ad ::  nil) >= 1) by (solve_hyps_min HAadeq HAadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAad *)
(* dans la couche 0 *)
Lemma LOoADad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoADad requis par la preuve de (?)OoADad pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoADad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoABBpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABCApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoABBpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDadm2 : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: D :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil) (nil) 4 0 2 HOoABCApBpDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDadm3 : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoADad requis par la preuve de (?)OoADad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour ADad requis par la preuve de (?)OoADad pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoADad requis par la preuve de (?)OoADad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HOoADadM3 : rk(Oo :: A :: D :: ad :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: ad :: nil) (Oo :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: ad :: nil) ((Oo :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HOoMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: D :: ad ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoADadm2 : rk(Oo :: A :: D :: ad :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDadmtmp : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoABBpDadeq HOoABBpDadm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: D :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDadmtmp;try rewrite HT2 in HOoABBpDadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: D :: ad :: nil) (Oo :: nil) 3 1 2 HOoABBpDadmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoADadm3 : rk(Oo :: A :: D :: ad :: nil) >= 3).
{
	try assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: D :: ad :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}


assert(HOoADadM : rk(Oo :: A :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoADadm : rk(Oo :: A :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoADadeq HOoADadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAad *)
(* dans la couche 0 *)
Lemma LADad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HADadM : rk(A :: D :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HADadeq HADadM3).
assert(HADadm : rk(A :: D :: ad ::  nil) >= 1) by (solve_hyps_min HADadeq HADadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAad requis par la preuve de (?)OoAad pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoAad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpadm2 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (nil) 4 0 2 HOoABCApBpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpadm3 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAad requis par la preuve de (?)OoAad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: ad ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoAadm2 : rk(Oo :: A :: ad :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpadmtmp : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HOoABBpadeq HOoABBpadm3).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpadmtmp;try rewrite HT2 in HOoABBpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: ad :: nil) (Oo :: nil) 3 1 2 HOoABBpadmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoAadm3 : rk(Oo :: A :: ad :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HOoADadeq : rk(Oo :: A :: D :: ad :: nil) = 3) by (apply LOoADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoADadmtmp : rk(Oo :: A :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoADadeq HOoADadm3).
	try assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (Oo :: A :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: ad :: nil) (Oo :: A :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: ad :: A :: D :: ad :: nil) ((Oo :: A :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoADadmtmp;try rewrite HT2 in HOoADadmtmp.
	assert(HT := rule_2 (Oo :: A :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HOoADadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}


assert(HOoAadM : rk(Oo :: A :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAadeq HOoAadM3).
assert(HOoAadm : rk(Oo :: A :: ad ::  nil) >= 1) by (solve_hyps_min HOoAadeq HOoAadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBad *)
(* dans la couche 0 *)
Lemma LOoABDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABCCpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCCpDadm4 : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABDadm2 : rk(Oo :: A :: B :: D :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (C :: Ap :: Oo :: A :: B :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: D :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: D :: ad :: nil) (nil) 4 0 2 HOoABCApDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: D :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABDadm3 : rk(Oo :: A :: B :: D :: ad :: nil) >= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpDadmtmp : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpDadeq HOoABCCpDadm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: D :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDadmtmp;try rewrite HT2 in HOoABCCpDadmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCCpDadmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}
try clear HOoABCCpDadM1. try clear HOoABCCpDadM2. try clear HOoABCCpDadM3. try clear HOoABCCpDadm4. try clear HOoABCCpDadm3. try clear HOoABCCpDadm2. try clear HOoABCCpDadm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABDadm4 : rk(Oo :: A :: B :: D :: ad :: nil) >= 4).
{
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: ad :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}


assert(HOoABDadM : rk(Oo :: A :: B :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDadm : rk(Oo :: A :: B :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABDadeq HOoABDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBad requis par la preuve de (?)OoBad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApad requis par la preuve de (?)OoBad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoBCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApad requis par la preuve de (?)OoBCApad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApadm4 : rk(Oo :: B :: C :: Ap :: ad :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: ad :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApadmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBad requis par la preuve de (?)OoBad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBadm2 : rk(Oo :: B :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApadmtmp : rk(Oo :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApadeq HOoBCApadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: ad :: nil) (C :: Ap :: Oo :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApadmtmp;try rewrite HT2 in HOoBCApadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: ad :: nil) (nil) 4 0 2 HOoBCApadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApadM1. try clear HOoBCApadM2. try clear HOoBCApadM3. try clear HOoBCApadm4. try clear HOoBCApadm3. try clear HOoBCApadm2. try clear HOoBCApadm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBadm3 : rk(Oo :: B :: ad :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HOoABDadeq : rk(Oo :: A :: B :: D :: ad :: nil) = 4) by (apply LOoABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDadmtmp : rk(Oo :: A :: B :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABDadeq HOoABDadm4).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Oo :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: ad :: nil) (Oo :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: ad :: A :: D :: ad :: nil) ((Oo :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDadmtmp;try rewrite HT2 in HOoABDadmtmp.
	assert(HT := rule_2 (Oo :: B :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 4 1 2 HOoABDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}


assert(HOoBadM : rk(Oo :: B :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBadeq HOoBadM3).
assert(HOoBadm : rk(Oo :: B :: ad ::  nil) >= 1) by (solve_hyps_min HOoBadeq HOoBadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABad *)
(* dans la couche 0 *)
Lemma LABDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDad requis par la preuve de (?)ABDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDadm3 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDadm4 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDad requis par la preuve de (?)ABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDad requis par la preuve de (?)ABDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABDadM3 : rk(A :: B :: D :: ad :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: ad :: nil) (B :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: D :: ad :: nil) ((B :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HBMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABDadm2 : rk(A :: B :: D :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApDadmtmp : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApDadeq HABCApDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: ad :: nil) (C :: Ap :: A :: B :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDadmtmp;try rewrite HT2 in HABCApDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: ad :: nil) (nil) 4 0 2 HABCApDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDadm3 : rk(A :: B :: D :: ad :: nil) >= 3).
{
	try assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: ad :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}


assert(HABDadM : rk(A :: B :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDadm : rk(A :: B :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABDadeq HABDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABad requis par la preuve de (?)ABad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApadm3 : rk(A :: B :: C :: Ap :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApadm4 : rk(A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABad requis par la preuve de (?)ABad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABadm2 : rk(A :: B :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApadmtmp : rk(A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HABCApadeq HABCApadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ad :: nil) (C :: Ap :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApadmtmp;try rewrite HT2 in HABCApadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ad :: nil) (nil) 4 0 2 HABCApadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApadM1. try clear HABCApadM2. try clear HABCApadM3. try clear HABCApadm4. try clear HABCApadm3. try clear HABCApadm2. try clear HABCApadm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABadm3 : rk(A :: B :: ad :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HABDadeq : rk(A :: B :: D :: ad :: nil) = 3) by (apply LABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDadmtmp : rk(A :: B :: D :: ad :: nil) >= 3) by (solve_hyps_min HABDadeq HABDadm3).
	try assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: ad :: nil) (A :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ad :: A :: D :: ad :: nil) ((A :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDadmtmp;try rewrite HT2 in HABDadmtmp.
	assert(HT := rule_2 (A :: B :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HABDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}


assert(HABadM : rk(A :: B :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABadeq HABadM3).
assert(HABadm : rk(A :: B :: ad ::  nil) >= 1) by (solve_hyps_min HABadeq HABadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABCCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCCpadm4 : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABadm2 : rk(Oo :: A :: B :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (C :: Ap :: Oo :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: ad :: nil) (nil) 4 0 2 HOoABCApadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABadm3 : rk(Oo :: A :: B :: ad :: nil) >= 3).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpadmtmp : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ad :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpadmtmp;try rewrite HT2 in HOoABCCpadmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCCpadmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}
try clear HOoABCCpadM1. try clear HOoABCCpadM2. try clear HOoABCCpadM3. try clear HOoABCCpadm4. try clear HOoABCCpadm3. try clear HOoABCCpadm2. try clear HOoABCCpadm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABadm4 : rk(Oo :: A :: B :: ad :: nil) >= 4).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HOoABDadeq : rk(Oo :: A :: B :: D :: ad :: nil) = 4) by (apply LOoABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDadmtmp : rk(Oo :: A :: B :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABDadeq HOoABDadm4).
	try assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (Oo :: A :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: ad :: nil) (Oo :: A :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ad :: A :: D :: ad :: nil) ((Oo :: A :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDadmtmp;try rewrite HT2 in HOoABDadmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HOoABDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}


assert(HOoABadM : rk(Oo :: A :: B :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABadm : rk(Oo :: A :: B :: ad ::  nil) >= 1) by (solve_hyps_min HOoABadeq HOoABadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACad *)
(* dans la couche 0 *)
Lemma LACDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACDad requis par la preuve de (?)ACDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)ACDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDad requis par la preuve de (?)ACDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDad requis par la preuve de (?)ACDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACDadM3 : rk(A :: C :: D :: ad :: nil) <= 3).
{
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: ad :: nil) (C :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: D :: ad :: nil) ((C :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HCMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACDadm2 : rk(A :: C :: D :: ad :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: C :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: ad :: nil) (A :: nil) 4 1 3 HOoABCApDadmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDadm3 : rk(A :: C :: D :: ad :: nil) >= 3).
{
	try assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: D :: ad :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}


assert(HACDadM : rk(A :: C :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACDadm : rk(A :: C :: D :: ad ::  nil) >= 1) by (solve_hyps_min HACDadeq HACDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACad requis par la preuve de (?)ACad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)ACad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACad requis par la preuve de (?)ACad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACadm2 : rk(A :: C :: ad :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: A :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ad :: nil) (A :: nil) 4 1 3 HOoABCApadmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACadm3 : rk(A :: C :: ad :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HACDadeq : rk(A :: C :: D :: ad :: nil) = 3) by (apply LACDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACDadmtmp : rk(A :: C :: D :: ad :: nil) >= 3) by (solve_hyps_min HACDadeq HACDadm3).
	try assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: C :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: ad :: nil) (A :: C :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ad :: A :: D :: ad :: nil) ((A :: C :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDadmtmp;try rewrite HT2 in HACDadmtmp.
	assert(HT := rule_2 (A :: C :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HACDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}


assert(HACadM : rk(A :: C :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACadeq HACadM3).
assert(HACadm : rk(A :: C :: ad ::  nil) >= 1) by (solve_hyps_min HACadeq HACadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCad *)
(* dans la couche 0 *)
Lemma LABCDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCDad requis par la preuve de (?)ABCDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)ABCDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCDad requis par la preuve de (?)ABCDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCDadm3 : rk(A :: B :: C :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: D :: ad :: nil) (A :: nil) 4 1 2 HOoABCApDadmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCDadm4 : rk(A :: B :: C :: D :: ad :: nil) >= 4).
{
	try assert(HABCDeq : rk(A :: B :: C :: D :: nil) = 4) by (apply LABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HABCDeq HABCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (A :: B :: C :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: nil) (A :: B :: C :: D :: ad :: nil) 4 4 HABCDmtmp Hcomp Hincl);apply HT.
}


assert(HABCDadM : rk(A :: B :: C :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCDadm : rk(A :: B :: C :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCDadeq HABCDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCad requis par la preuve de (?)ABCad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)ABCad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCad requis par la preuve de (?)ABCad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCadm3 : rk(A :: B :: C :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ad :: nil) (A :: nil) 4 1 2 HOoABCApadmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABCadm4 : rk(A :: B :: C :: ad :: nil) >= 4).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HABCDadeq : rk(A :: B :: C :: D :: ad :: nil) = 4) by (apply LABCDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCDadmtmp : rk(A :: B :: C :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCDadeq HABCDadm4).
	try assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: B :: C :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: ad :: nil) (A :: B :: C :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: ad :: A :: D :: ad :: nil) ((A :: B :: C :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDadmtmp;try rewrite HT2 in HABCDadmtmp.
	assert(HT := rule_2 (A :: B :: C :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HABCDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}


assert(HABCadM : rk(A :: B :: C :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCadm : rk(A :: B :: C :: ad ::  nil) >= 1) by (solve_hyps_min HABCadeq HABCadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCad requis par la preuve de (?)OoABCad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCadm4 : rk(Oo :: A :: B :: C :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCadM : rk(Oo :: A :: B :: C :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCadm : rk(Oo :: A :: B :: C :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCadeq HOoABCadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApad *)
(* dans constructLemma(), requis par LAApDad *)
(* dans la couche 0 *)
Lemma LOoAApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoAApDadM3 : rk(Oo :: A :: Ap :: D :: ad :: nil) <= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HOoAApMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDadm2 : rk(Oo :: A :: Ap :: D :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: D :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDadm3 : rk(Oo :: A :: Ap :: D :: ad :: nil) >= 3).
{
	try assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: ad :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApDadM : rk(Oo :: A :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDadm : rk(Oo :: A :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApDadeq HOoAApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApDad requis par la preuve de (?)AApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDad requis par la preuve de (?)AApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDadm3 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDadm4 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApDad requis par la preuve de (?)AApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDad requis par la preuve de (?)AApDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAApDadM3 : rk(A :: Ap :: D :: ad :: nil) <= 3).
{
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: ad :: nil) (Ap :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: D :: ad :: nil) ((Ap :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HApMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApDadm2 : rk(A :: Ap :: D :: ad :: nil) >= 2).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApDadmtmp : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApDadeq HABCApDadm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: ad :: nil) (B :: C :: Ap :: A :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: D :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDadmtmp;try rewrite HT2 in HABCApDadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: D :: ad :: nil) (Ap :: nil) 4 1 3 HABCApDadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: D :: ad ::  de rang :  3 et 3 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HAApDadm3 : rk(A :: Ap :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoAApDadeq : rk(Oo :: A :: Ap :: D :: ad :: nil) = 3) by (apply LOoAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDadmtmp : rk(Oo :: A :: Ap :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoAApDadeq HOoAApDadm3).
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: Ap :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApDadmtmp;try rewrite HT2 in HOoAApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: Ap :: D :: ad :: nil) (A :: Ap :: nil) 3 2 2 HOoAApDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HAApDadM : rk(A :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDadm : rk(A :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HAApDadeq HAApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Apad requis par la preuve de (?)Apad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApadm2 : rk(Ap :: ad :: nil) >= 2).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HAApDadeq : rk(A :: Ap :: D :: ad :: nil) = 3) by (apply LAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApDadmtmp : rk(A :: Ap :: D :: ad :: nil) >= 3) by (solve_hyps_min HAApDadeq HAApDadm3).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Ap :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: ad :: nil) (Ap :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ad :: A :: D :: ad :: nil) ((Ap :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDadmtmp;try rewrite HT2 in HAApDadmtmp.
	assert(HT := rule_2 (Ap :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HAApDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}


assert(HApadM : rk(Ap :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApadeq HApadM2).
assert(HApadm : rk(Ap :: ad ::  nil) >= 1) by (solve_hyps_min HApadeq HApadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApad *)
(* dans la couche 0 *)
Lemma LOoApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApDpad requis par la preuve de (?)OoApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApDpad requis par la preuve de (?)OoApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApDpad requis par la preuve de (?)OoApDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoApDpadM3 : rk(Oo :: Ap :: Dp :: ad :: nil) <= 3).
{
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	try assert(HApDpadeq : rk(Ap :: Dp :: ad :: nil) = 2) by (apply LApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Dp :: ad :: nil) (Oo :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Dp :: ad :: nil) ((Oo :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HOoMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApDpadm2 : rk(Oo :: Ap :: Dp :: ad :: nil) >= 2).
{
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Dp :: ad :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApDpadm3 : rk(Oo :: Ap :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (Oo :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: Dp :: nil) (Oo :: Ap :: Dp :: ad :: nil) 3 3 HOoApDpmtmp Hcomp Hincl);apply HT.
}


assert(HOoApDpadM : rk(Oo :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApDpadm : rk(Oo :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoApDpadeq HOoApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApad requis par la preuve de (?)OoApad pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApadm2 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApadm3 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApad requis par la preuve de (?)OoApad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ad ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApadm2 : rk(Oo :: Ap :: ad :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApadmtmp : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HOoABApadeq HOoABApadm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApadmtmp;try rewrite HT2 in HOoABApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ad :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApadmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApadM1. try clear HOoABApadM2. try clear HOoABApadM3. try clear HOoABApadm4. try clear HOoABApadm3. try clear HOoABApadm2. try clear HOoABApadm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApadm3 : rk(Oo :: Ap :: ad :: nil) >= 3).
{
	try assert(HApDpadeq : rk(Ap :: Dp :: ad :: nil) = 2) by (apply LApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	try assert(HOoApDpadeq : rk(Oo :: Ap :: Dp :: ad :: nil) = 3) by (apply LOoApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpadmtmp : rk(Oo :: Ap :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoApDpadeq HOoApDpadm3).
	try assert(HApadeq : rk(Ap :: ad :: nil) = 2) by (apply LApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApadmtmp : rk(Ap :: ad :: nil) >= 2) by (solve_hyps_min HApadeq HApadm2).
	assert(Hincl : incl (Ap :: ad :: nil) (list_inter (Oo :: Ap :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Dp :: ad :: nil) (Oo :: Ap :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: ad :: Ap :: Dp :: ad :: nil) ((Oo :: Ap :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApDpadmtmp;try rewrite HT2 in HOoApDpadmtmp.
	assert(HT := rule_2 (Oo :: Ap :: ad :: nil) (Ap :: Dp :: ad :: nil) (Ap :: ad :: nil) 3 2 2 HOoApDpadmtmp HApadmtmp HApDpadMtmp Hincl);apply HT.
}
try clear HApadM1. try clear HApadM2. try clear HApadM3. try clear HApadm4. try clear HApadm3. try clear HApadm2. try clear HApadm1. 

assert(HOoApadM : rk(Oo :: Ap :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApadeq HOoApadM3).
assert(HOoApadm : rk(Oo :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HOoApadeq HOoApadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApad *)
(* dans la couche 0 *)
Lemma LOoABCApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApadM : rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApadm : rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApadeq HOoABCApadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApad requis par la preuve de (?)OoAApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApad requis par la preuve de (?)OoAApad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApad requis par la preuve de (?)OoAApad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoAApadM3 : rk(Oo :: A :: Ap :: ad :: nil) <= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: ad :: nil) (Oo :: A :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (ad :: nil) (nil) 2 1 0 HOoAApMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApadm2 : rk(Oo :: A :: Ap :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoAApadm3 : rk(Oo :: A :: Ap :: ad :: nil) >= 3).
{
	try assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	try assert(HOoABCApadeq : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) = 4) by (apply LOoABCApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	try assert(HOoAadeq : rk(Oo :: A :: ad :: nil) = 3) by (apply LOoAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAadmtmp : rk(Oo :: A :: ad :: nil) >= 3) by (solve_hyps_min HOoAadeq HOoAadm3).
	assert(Hincl : incl (Oo :: A :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: A :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: A :: Ap :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: A :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: Ap :: ad :: nil) (Oo :: A :: ad :: nil) 4 3 4 HOoABCApadmtmp HOoAadmtmp HOoABCadMtmp Hincl); apply HT.
}


assert(HOoAApadM : rk(Oo :: A :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApadm : rk(Oo :: A :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApadeq HOoAApadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApad requis par la preuve de (?)OoBCApad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApadm4 : rk(Oo :: B :: C :: Ap :: ad :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApadeq : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) = 4) by (apply LOoABCApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: ad :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApadmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApadM : rk(Oo :: B :: C :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApadm : rk(Oo :: B :: C :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HOoBCApadeq HOoBCApadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApadm3 : rk(A :: B :: C :: Ap :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApadeq : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) = 4) by (apply LOoABCApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApadm4 : rk(A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApadeq : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) = 4) by (apply LOoABCApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HABCApadM : rk(A :: B :: C :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApadm : rk(A :: B :: C :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HABCApadeq HABCApadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpad *)
(* dans constructLemma(), requis par LABpDad *)
(* dans la couche 0 *)
Lemma LOoABpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDDpad requis par la preuve de (?)OoABBpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpad requis par la preuve de (?)OoABBpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpad requis par la preuve de (?)OoABCApBpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDDpad requis par la preuve de (?)OoABBpDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDDpadm2 : rk(Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpadeq HOoABCApBpDDpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpadmtmp;try rewrite HT2 in HOoABCApBpDDpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) (nil) 4 0 2 HOoABCApBpDDpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoABCApBpDDpadM1. try clear HOoABCApBpDDpadM2. try clear HOoABCApBpDDpadM3. try clear HOoABCApBpDDpadm4. try clear HOoABCApBpDDpadm3. try clear HOoABCApBpDDpadm2. try clear HOoABCApBpDDpadm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDDpadm3 : rk(Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: D :: Dp :: ad ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpDDpadm3 : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDDpadmtmp : rk(Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoABBpDDpadeq HOoABBpDDpadm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: Bp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: Bp :: D :: Dp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: Bp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDDpadmtmp;try rewrite HT2 in HOoABBpDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABBpDDpadmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoABBpDDpadM1. try clear HOoABBpDDpadM2. try clear HOoABBpDDpadM3. try clear HOoABBpDDpadm4. try clear HOoABBpDDpadm3. try clear HOoABBpDDpadm2. try clear HOoABBpDDpadm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpDDpadm4 : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	try assert(HOoABpDpeq : rk(Oo :: A :: Bp :: Dp :: nil) = 4) by (apply LOoABpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpDpmtmp : rk(Oo :: A :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABpDpeq HOoABpDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: Dp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: Dp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABpDpmtmp Hcomp Hincl);apply HT.
}


assert(HOoABpDDpadM : rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpDDpadm : rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpDDpadeq HOoABpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpDad requis par la preuve de (?)ABpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpDad requis par la preuve de (?)ABpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpDad requis par la preuve de (?)ABpDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABpDadM3 : rk(A :: Bp :: D :: ad :: nil) <= 3).
{
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: D :: ad :: nil) (Bp :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: D :: ad :: nil) ((Bp :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HBpMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpDadm2 : rk(A :: Bp :: D :: ad :: nil) >= 2).
{
	try assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: D :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}
try clear HABpM1. try clear HABpM2. try clear HABpM3. try clear HABpm4. try clear HABpm3. try clear HABpm2. try clear HABpm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HABpDadm3 : rk(A :: Bp :: D :: ad :: nil) >= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoABpDDpadeq : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) = 4) by (apply LOoABpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpDDpadmtmp : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpDDpadeq HOoABpDDpadm4).
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: Dp :: nil) (A :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: A :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: A :: Bp :: D :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (A :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpDDpadmtmp;try rewrite HT2 in HOoABpDDpadmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (A :: Bp :: D :: ad :: nil) (D :: nil) 4 1 2 HOoABpDDpadmtmp HDmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HABpDadM : rk(A :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpDadm : rk(A :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABpDadeq HABpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bpad requis par la preuve de (?)Bpad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBpadm2 : rk(Bp :: ad :: nil) >= 2).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HABpDadeq : rk(A :: Bp :: D :: ad :: nil) = 3) by (apply LABpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABpDadmtmp : rk(A :: Bp :: D :: ad :: nil) >= 3) by (solve_hyps_min HABpDadeq HABpDadm3).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Bp :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: D :: ad :: nil) (Bp :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: ad :: A :: D :: ad :: nil) ((Bp :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpDadmtmp;try rewrite HT2 in HABpDadmtmp.
	assert(HT := rule_2 (Bp :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HABpDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}


assert(HBpadM : rk(Bp :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpadeq HBpadM2).
assert(HBpadm : rk(Bp :: ad ::  nil) >= 1) by (solve_hyps_min HBpadeq HBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpad *)
(* dans la couche 0 *)
Lemma LOoABpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpDad requis par la preuve de (?)OoABpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoABpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoABBpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABCApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoABBpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDadm2 : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: D :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil) (nil) 4 0 2 HOoABCApBpDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDadm3 : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpDad requis par la preuve de (?)OoABpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: D :: ad ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpDadm3 : rk(Oo :: A :: Bp :: D :: ad :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDadmtmp : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoABBpDadeq HOoABBpDadm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: Bp :: D :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDadmtmp;try rewrite HT2 in HOoABBpDadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: D :: ad :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABBpDadmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: D ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HOoABpDadm4 : rk(Oo :: A :: Bp :: D :: ad :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoABpDDpadeq : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) = 4) by (apply LOoABpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpDDpadmtmp : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpDDpadeq HOoABpDDpadm4).
	try assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDmtmp : rk(Oo :: D :: nil) >= 2) by (solve_hyps_min HOoDeq HOoDm2).
	assert(Hincl : incl (Oo :: D :: nil) (list_inter (Oo :: D :: Dp :: nil) (Oo :: A :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: Oo :: A :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Oo :: A :: Bp :: D :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (Oo :: A :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpDDpadmtmp;try rewrite HT2 in HOoABpDDpadmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Oo :: A :: Bp :: D :: ad :: nil) (Oo :: D :: nil) 4 2 2 HOoABpDDpadmtmp HOoDmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HOoABpDadM : rk(Oo :: A :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpDadm : rk(Oo :: A :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpDadeq HOoABpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpad requis par la preuve de (?)OoBpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpad requis par la preuve de (?)OoBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoBCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpad requis par la preuve de (?)OoBCApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpadm4 : rk(Oo :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpadmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpadm2 : rk(Oo :: B :: Bp :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpadmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApBpadeq HOoBCApBpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ad :: nil) (C :: Ap :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpadmtmp;try rewrite HT2 in HOoBCApBpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil) (nil) 4 0 2 HOoBCApBpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApBpadM1. try clear HOoBCApBpadM2. try clear HOoBCApBpadM3. try clear HOoBCApBpadm4. try clear HOoBCApBpadm3. try clear HOoBCApBpadm2. try clear HOoBCApBpadm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBBpadM3 : rk(Oo :: B :: Bp :: ad :: nil) <= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (ad :: nil) (nil) 2 1 0 HOoBBpMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpad requis par la preuve de (?)OoBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: ad ::  de rang :  2 et 3 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpadm2 : rk(Oo :: Bp :: ad :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpadmtmp : rk(Oo :: B :: Bp :: ad :: nil) >= 2) by (solve_hyps_min HOoBBpadeq HOoBBpadm2).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: Oo :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Bp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpadmtmp;try rewrite HT2 in HOoBBpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Bp :: ad :: nil) (Oo :: Bp :: nil) 2 2 2 HOoBBpadmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpadm3 : rk(Oo :: Bp :: ad :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HOoABpDadeq : rk(Oo :: A :: Bp :: D :: ad :: nil) = 4) by (apply LOoABpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpDadmtmp : rk(Oo :: A :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABpDadeq HOoABpDadm4).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Oo :: Bp :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: D :: ad :: nil) (Oo :: Bp :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: ad :: A :: D :: ad :: nil) ((Oo :: Bp :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpDadmtmp;try rewrite HT2 in HOoABpDadmtmp.
	assert(HT := rule_2 (Oo :: Bp :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 4 1 2 HOoABpDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}


assert(HOoBpadM : rk(Oo :: Bp :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpadeq HOoBpadM3).
assert(HOoBpadm : rk(Oo :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBpadeq HOoBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpad *)
(* dans constructLemma(), requis par LOoABBpad *)
(* dans la couche 0 *)
Lemma LOoABCBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpad requis par la preuve de (?)OoABCBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCBpadm4 : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCBpadM : rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpadm : rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpadm2 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (nil) 4 0 2 HOoABCApBpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpadm3 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: B :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoABBpadm4 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	try assert(HOoABCBpadeq : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) = 4) by (apply LOoABCBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCBpadmtmp : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm4).
	try assert(HOoABadeq : rk(Oo :: A :: B :: ad :: nil) = 4) by (apply LOoABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABadmtmp : rk(Oo :: A :: B :: ad :: nil) >= 4) by (solve_hyps_min HOoABadeq HOoABadm4).
	assert(Hincl : incl (Oo :: A :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Bp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpadmtmp;try rewrite HT2 in HOoABCBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: A :: B :: ad :: nil) 4 4 4 HOoABCBpadmtmp HOoABadmtmp HOoABCadMtmp Hincl); apply HT.
}


assert(HOoABBpadM : rk(Oo :: A :: B :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpadm : rk(Oo :: A :: B :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABBpadeq HOoABBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpad *)
(* dans la couche 0 *)
Lemma LOoBBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoBCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpad requis par la preuve de (?)OoBCApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpadm4 : rk(Oo :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpadmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpadm2 : rk(Oo :: B :: Bp :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpadmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApBpadeq HOoBCApBpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ad :: nil) (C :: Ap :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpadmtmp;try rewrite HT2 in HOoBCApBpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil) (nil) 4 0 2 HOoBCApBpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApBpadM1. try clear HOoBCApBpadM2. try clear HOoBCApBpadM3. try clear HOoBCApBpadm4. try clear HOoBCApBpadm3. try clear HOoBCApBpadm2. try clear HOoBCApBpadm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HOoBBpadM3 : rk(Oo :: B :: Bp :: ad :: nil) <= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (ad :: nil) (nil) 2 1 0 HOoBBpMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: B :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoBBpadm3 : rk(Oo :: B :: Bp :: ad :: nil) >= 3).
{
	try assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	try assert(HOoABCBpadeq : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) = 4) by (apply LOoABCBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCBpadmtmp : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm4).
	try assert(HOoBadeq : rk(Oo :: B :: ad :: nil) = 3) by (apply LOoBad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBadmtmp : rk(Oo :: B :: ad :: nil) >= 3) by (solve_hyps_min HOoBadeq HOoBadm3).
	assert(Hincl : incl (Oo :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: B :: Bp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpadmtmp;try rewrite HT2 in HOoABCBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: ad :: nil) 4 3 4 HOoABCBpadmtmp HOoBadmtmp HOoABCadMtmp Hincl); apply HT.
}
try clear HOoABCBpadM1. try clear HOoABCBpadM2. try clear HOoABCBpadM3. try clear HOoABCBpadm4. try clear HOoABCBpadm3. try clear HOoABCBpadm2. try clear HOoABCBpadm1. 

assert(HOoBBpadM : rk(Oo :: B :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpadm : rk(Oo :: B :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBBpadeq HOoBBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpad requis par la preuve de (?)OoABpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpadm2 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (nil) 4 0 2 HOoABCApBpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpadm3 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpad requis par la preuve de (?)OoABpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: ad ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpadm3 : rk(Oo :: A :: Bp :: ad :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpadmtmp : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HOoABBpadeq HOoABBpadm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: Bp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpadmtmp;try rewrite HT2 in HOoABBpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: ad :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABBpadmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpadm4 : rk(Oo :: A :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoBBpadeq : rk(Oo :: B :: Bp :: ad :: nil) = 3) by (apply LOoBBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpadMtmp : rk(Oo :: B :: Bp :: ad :: nil) <= 3) by (solve_hyps_max HOoBBpadeq HOoBBpadM3).
	try assert(HOoABBpadeq : rk(Oo :: A :: B :: Bp :: ad :: nil) = 4) by (apply LOoABBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABBpadmtmp : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABBpadeq HOoABBpadm4).
	try assert(HOoBpadeq : rk(Oo :: Bp :: ad :: nil) = 3) by (apply LOoBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpadmtmp : rk(Oo :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HOoBpadeq HOoBpadm3).
	assert(Hincl : incl (Oo :: Bp :: ad :: nil) (list_inter (Oo :: A :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: A :: Bp :: ad :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: ad :: Oo :: B :: Bp :: ad :: nil) ((Oo :: A :: Bp :: ad :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpadmtmp;try rewrite HT2 in HOoABBpadmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil) (Oo :: Bp :: ad :: nil) 4 3 3 HOoABBpadmtmp HOoBpadmtmp HOoBBpadMtmp Hincl);apply HT.
}


assert(HOoABpadM : rk(Oo :: A :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpadm : rk(Oo :: A :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpadeq HOoABpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApBpad *)
(* dans constructLemma(), requis par LAApBpDad *)
(* dans constructLemma(), requis par LOoAApBpDad *)
(* dans la couche 0 *)
Lemma LOoAApBpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpDDpad requis par la preuve de (?)OoAApBpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpDDpad requis par la preuve de (?)OoAApBpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpDDpad requis par la preuve de (?)OoAApBpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpDDpadm2 : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpDDpadm3 : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpDDpadm4 : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	try assert(HOoABpDpeq : rk(Oo :: A :: Bp :: Dp :: nil) = 4) by (apply LOoABpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpDpmtmp : rk(Oo :: A :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABpDpeq HOoABpDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: Dp :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: Dp :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABpDpmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpDDpadM : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpDDpadm : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpDDpadeq HOoAApBpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpDadm2 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpDadm3 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: D ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HOoAApBpDadm4 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoAApBpDDpadeq : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) = 4) by (apply LOoAApBpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApBpDDpadmtmp : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpDDpadeq HOoAApBpDDpadm4).
	try assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDmtmp : rk(Oo :: D :: nil) >= 2) by (solve_hyps_min HOoDeq HOoDm2).
	assert(Hincl : incl (Oo :: D :: nil) (list_inter (Oo :: D :: Dp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Oo :: A :: Ap :: Bp :: D :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (Oo :: A :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpDDpadmtmp;try rewrite HT2 in HOoAApBpDDpadmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) (Oo :: D :: nil) 4 2 2 HOoAApBpDDpadmtmp HOoDmtmp HOoDDpMtmp Hincl); apply HT.
}
try clear HOoDM1. try clear HOoDM2. try clear HOoDM3. try clear HOoDm4. try clear HOoDm3. try clear HOoDm2. try clear HOoDm1. 

assert(HOoAApBpDadM : rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpDadm : rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpDadeq HOoAApBpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpDad requis par la preuve de (?)AApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpabDad requis par la preuve de (?)AApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBpabDad requis par la preuve de (?)AApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDad requis par la preuve de (?)ABApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDad requis par la preuve de (?)OoABApBpabDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDad requis par la preuve de (?)OoABApBpabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBpabDad requis par la preuve de (?)ABApBpabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApBpabDadm3 : rk(A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabDadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpabDadeq HOoABApBpabDadm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDadmtmp;try rewrite HT2 in HOoABApBpabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApBpabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApBpabDadM1. try clear HOoABApBpabDadM2. try clear HOoABApBpabDadM3. try clear HOoABApBpabDadm4. try clear HOoABApBpabDadm3. try clear HOoABApBpabDadm2. try clear HOoABApBpabDadm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpabDad requis par la preuve de (?)AApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpabDad requis par la preuve de (?)AApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabDad requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDad requis par la preuve de (?)OoABCApBpabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpabDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpabDad requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpabDad requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabDadm3 : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDadeq HOoABCApBpabDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDadmtmp;try rewrite HT2 in HOoABCApBpabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpabDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpabDadm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDadeq HOoABCApBpabDadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDadmtmp;try rewrite HT2 in HOoABCApBpabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApBpabDadM1. try clear HOoABCApBpabDadM2. try clear HOoABCApBpabDadM3. try clear HOoABCApBpabDadm4. try clear HOoABCApBpabDadm3. try clear HOoABCApBpabDadm2. try clear HOoABCApBpabDadm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpabDad requis par la preuve de (?)AApBpabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApBpabDadm2 : rk(A :: Ap :: Bp :: ab :: D :: ad :: nil) >= 2).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApBpabDadmtmp : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApBpabDadeq HABCApBpabDadm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Bp :: ab :: D :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpabDadmtmp;try rewrite HT2 in HABCApBpabDadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: D :: ad :: nil) (Ap :: nil) 4 1 3 HABCApBpabDadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}
try clear HABCApBpabDadM1. try clear HABCApBpabDadM2. try clear HABCApBpabDadM3. try clear HABCApBpabDadm4. try clear HABCApBpabDadm3. try clear HABCApBpabDadm2. try clear HABCApBpabDadm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Bp :: ab :: D :: ad ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApBpabDadm3 : rk(A :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApBpabDadmtmp : rk(A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HABApBpabDadeq HABApBpabDadm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: B :: ab :: A :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Bp :: ab :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApBpabDadmtmp;try rewrite HT2 in HABApBpabDadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: ab :: nil) 3 2 2 HABApBpabDadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABApBpabDadM1. try clear HABApBpabDadM2. try clear HABApBpabDadM3. try clear HABApBpabDadm4. try clear HABApBpabDadm3. try clear HABApBpabDadm2. try clear HABApBpabDadm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpDad requis par la preuve de (?)AApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpDad requis par la preuve de (?)AApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABCApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpDad requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpDad requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpDadm3 : rk(A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpDadm4 : rk(A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpDad requis par la preuve de (?)AApBpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApBpDadm2 : rk(A :: Ap :: Bp :: D :: ad :: nil) >= 2).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApBpDadmtmp : rk(A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApBpDadeq HABCApBpDadm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Bp :: D :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpDadmtmp;try rewrite HT2 in HABCApBpDadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Bp :: D :: ad :: nil) (Ap :: nil) 4 1 3 HABCApBpDadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}
try clear HABCApBpDadM1. try clear HABCApBpDadM2. try clear HABCApBpDadM3. try clear HABCApBpDadm4. try clear HABCApBpDadm3. try clear HABCApBpDadm2. try clear HABCApBpDadm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: ab :: D :: ad ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Ap :: Bp :: ab ::   de rang : 2 et 2 *)
assert(HAApBpDadm3 : rk(A :: Ap :: Bp :: D :: ad :: nil) >= 3).
{
	try assert(HApBpabeq : rk(Ap :: Bp :: ab :: nil) = 2) by (apply LApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HAApBpabDadmtmp : rk(A :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HAApBpabDadeq HAApBpabDadm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (A :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: D :: ad :: nil) (Ap :: Bp :: ab :: A :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: A :: Ap :: Bp :: D :: ad :: nil) ((Ap :: Bp :: ab :: nil) ++ (A :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpabDadmtmp;try rewrite HT2 in HAApBpabDadmtmp.
	assert(HT := rule_4 (Ap :: Bp :: ab :: nil) (A :: Ap :: Bp :: D :: ad :: nil) (Ap :: Bp :: nil) 3 2 2 HAApBpabDadmtmp HApBpmtmp HApBpabMtmp Hincl); apply HT.
}
try clear HAApBpabDadM1. try clear HAApBpabDadM2. try clear HAApBpabDadM3. try clear HAApBpabDadm4. try clear HAApBpabDadm3. try clear HAApBpabDadm2. try clear HAApBpabDadm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HAApBpDadm4 : rk(A :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoAApBpDadeq : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LOoAApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApBpDadmtmp : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpDadeq HOoAApBpDadm4).
	try assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: D :: ad :: nil) (Oo :: A :: Ap :: A :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: Ap :: Bp :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpDadmtmp;try rewrite HT2 in HOoAApBpDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: Ap :: Bp :: D :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoAApBpDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HAApBpDadM : rk(A :: Ap :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpDadm : rk(A :: Ap :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HAApBpDadeq HAApBpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)ABApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBpabad requis par la preuve de (?)ABApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApBpabadm3 : rk(A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabadmtmp;try rewrite HT2 in HOoABApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApBpabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabad requis par la preuve de (?)OoABCApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpabadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabadm3 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpabadm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApBpabadm2 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApBpabadmtmp : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HABCApBpabadeq HABCApBpabadm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Bp :: ab :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpabadmtmp;try rewrite HT2 in HABCApBpabadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (Ap :: nil) 4 1 3 HABCApBpabadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}
try clear HABCApBpabadM1. try clear HABCApBpabadM2. try clear HABCApBpabadM3. try clear HABCApBpabadm4. try clear HABCApBpabadm3. try clear HABCApBpabadm2. try clear HABCApBpabadm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApBpabadm3 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApBpabadmtmp : rk(A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HABApBpabadeq HABApBpabadm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: ab :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Bp :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApBpabadmtmp;try rewrite HT2 in HABApBpabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (A :: ab :: nil) 3 2 2 HABApBpabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABApBpabadM1. try clear HABApBpabadM2. try clear HABApBpabadM3. try clear HABApBpabadm4. try clear HABApBpabadm3. try clear HABApBpabadm2. try clear HABApBpabadm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpad requis par la preuve de (?)AApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpad requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpad requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpadm3 : rk(A :: B :: C :: Ap :: Bp :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpadm4 : rk(A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApBpadm2 : rk(A :: Ap :: Bp :: ad :: nil) >= 2).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApBpadmtmp : rk(A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HABCApBpadeq HABCApBpadm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Bp :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpadmtmp;try rewrite HT2 in HABCApBpadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ad :: nil) (Ap :: nil) 4 1 3 HABCApBpadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}
try clear HABCApBpadM1. try clear HABCApBpadM2. try clear HABCApBpadM3. try clear HABCApBpadm4. try clear HABCApBpadm3. try clear HABCApBpadm2. try clear HABCApBpadm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Ap :: Bp :: ab ::   de rang : 2 et 2 *)
assert(HAApBpadm3 : rk(A :: Ap :: Bp :: ad :: nil) >= 3).
{
	try assert(HApBpabeq : rk(Ap :: Bp :: ab :: nil) = 2) by (apply LApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HAApBpabadmtmp : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAApBpabadeq HAApBpabadm3).
	try assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (A :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: ad :: nil) (Ap :: Bp :: ab :: A :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: A :: Ap :: Bp :: ad :: nil) ((Ap :: Bp :: ab :: nil) ++ (A :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpabadmtmp;try rewrite HT2 in HAApBpabadmtmp.
	assert(HT := rule_4 (Ap :: Bp :: ab :: nil) (A :: Ap :: Bp :: ad :: nil) (Ap :: Bp :: nil) 3 2 2 HAApBpabadmtmp HApBpmtmp HApBpabMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApBpadm4 : rk(A :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HAApBpDadeq : rk(A :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LAApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApBpDadmtmp : rk(A :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HAApBpDadeq HAApBpDadm4).
	try assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: Ap :: Bp :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: D :: ad :: nil) (A :: Ap :: Bp :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: ad :: A :: D :: ad :: nil) ((A :: Ap :: Bp :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpDadmtmp;try rewrite HT2 in HAApBpDadmtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HAApBpDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}
try clear HAadM1. try clear HAadM2. try clear HAadM3. try clear HAadm4. try clear HAadm3. try clear HAadm2. try clear HAadm1. 

assert(HAApBpadM : rk(A :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpadm : rk(A :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HAApBpadeq HAApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpad requis par la preuve de (?)OoAApBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpad requis par la preuve de (?)OoAApBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpad requis par la preuve de (?)OoAApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpadm2 : rk(Oo :: A :: Ap :: Bp :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpadm3 : rk(Oo :: A :: Ap :: Bp :: ad :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpadm4 : rk(Oo :: A :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABpadeq : rk(Oo :: A :: Bp :: ad :: nil) = 4) by (apply LOoABpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpadmtmp : rk(Oo :: A :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpadeq HOoABpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil) 4 4 HOoABpadmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpadM : rk(Oo :: A :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpadm : rk(Oo :: A :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpadeq HOoAApBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpad *)
(* dans la couche 0 *)
Lemma LOoABCApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpad requis par la preuve de (?)OoBCApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpadm4 : rk(Oo :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) = 4) by (apply LOoABCApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpadmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApBpadM : rk(Oo :: B :: C :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpadm : rk(Oo :: B :: C :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBCApBpadeq HOoBCApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpad requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpad requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpadm3 : rk(A :: B :: C :: Ap :: Bp :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) = 4) by (apply LOoABCApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpadm4 : rk(A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApBpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) = 4) by (apply LOoABCApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HABCApBpadM : rk(A :: B :: C :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpadm : rk(A :: B :: C :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HABCApBpadeq HABCApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABCCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCCpadm4 : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCCpadM : rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpadm : rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labad *)
(* dans constructLemma(), requis par LAabDad *)
(* dans la couche 0 *)
Lemma LABabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDad requis par la preuve de (?)OoABCApabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDadM1. try clear HOoABCApabDadM2. try clear HOoABCApabDadM3. try clear HOoABCApabDadm4. try clear HOoABCApabDadm3. try clear HOoABCApabDadm2. try clear HOoABCApabDadm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadm2 : rk(A :: B :: ab :: D :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApabDadeq HABCApabDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadmtmp;try rewrite HT2 in HABCApabDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil) (nil) 4 0 2 HABCApabDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabDadM1. try clear HABCApabDadM2. try clear HABCApabDadM3. try clear HABCApabDadm4. try clear HABCApabDadm3. try clear HABCApabDadm2. try clear HABCApabDadm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABabDadM3 : rk(A :: B :: ab :: D :: ad :: nil) <= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: ab :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HABabMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadm3 : rk(A :: B :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}


assert(HABabDadM : rk(A :: B :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDadm : rk(A :: B :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABabDadeq HABabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AabDad requis par la preuve de (?)AabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AabDad requis par la preuve de (?)AabDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDad requis par la preuve de (?)AabDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAabDadM3 : rk(A :: ab :: D :: ad :: nil) <= 3).
{
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HabMtmp : rk(ab :: nil) <= 1) by (solve_hyps_max Habeq HabM1).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (ab :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: nil) (ab :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: A :: D :: ad :: nil) ((ab :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HabMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDadm2 : rk(A :: ab :: D :: ad :: nil) >= 2).
{
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: nil) (A :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: ab :: nil) (A :: ab :: D :: ad :: nil) 2 2 HAabmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad ::  de rang :  3 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDadm3 : rk(A :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HABabDadeq : rk(A :: B :: ab :: D :: ad :: nil) = 3) by (apply LABabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabDadmtmp : rk(A :: B :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HABabDadeq HABabDadm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: A :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadmtmp;try rewrite HT2 in HABabDadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: ad :: nil) (A :: ab :: nil) 3 2 2 HABabDadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}


assert(HAabDadM : rk(A :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabDadm : rk(A :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HAabDadeq HAabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour abad requis par la preuve de (?)abad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(Habadm2 : rk(ab :: ad :: nil) >= 2).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HAabDadeq : rk(A :: ab :: D :: ad :: nil) = 3) by (apply LAabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabDadmtmp : rk(A :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HAabDadeq HAabDadm3).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (ab :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: nil) (ab :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ad :: A :: D :: ad :: nil) ((ab :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAabDadmtmp;try rewrite HT2 in HAabDadmtmp.
	assert(HT := rule_2 (ab :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HAabDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}


assert(HabadM : rk(ab :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max Habadeq HabadM2).
assert(Habadm : rk(ab :: ad ::  nil) >= 1) by (solve_hyps_min Habadeq Habadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabad *)
(* dans constructLemma(), requis par LAApBpabad *)
(* dans la couche 0 *)
Lemma LOoAApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpabad requis par la preuve de (?)OoAApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpabad requis par la preuve de (?)OoAApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpabad requis par la preuve de (?)OoAApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpabadm2 : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpabadm3 : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpabadm4 : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABpadeq : rk(Oo :: A :: Bp :: ad :: nil) = 4) by (apply LOoABpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABpadmtmp : rk(Oo :: A :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpadeq HOoABpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) 4 4 HOoABpadmtmp Hcomp Hincl);apply HT.
}


assert(HOoAApBpabadM : rk(Oo :: A :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpabadm : rk(Oo :: A :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpabadeq HOoAApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)ABApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBpabad requis par la preuve de (?)ABApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApBpabadm3 : rk(A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabadmtmp;try rewrite HT2 in HOoABApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApBpabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabad requis par la preuve de (?)OoABCApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpabadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabadm3 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpabadm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApBpabadm2 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	try assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApBpabadmtmp : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HABCApBpabadeq HABCApBpabadm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Bp :: ab :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpabadmtmp;try rewrite HT2 in HABCApBpabadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (Ap :: nil) 4 1 3 HABCApBpabadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}
try clear HABCApBpabadM1. try clear HABCApBpabadM2. try clear HABCApBpabadM3. try clear HABCApBpabadm4. try clear HABCApBpabadm3. try clear HABCApBpabadm2. try clear HABCApBpabadm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApBpabadm3 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApBpabadmtmp : rk(A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HABApBpabadeq HABApBpabadm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: ab :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Bp :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApBpabadmtmp;try rewrite HT2 in HABApBpabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (A :: ab :: nil) 3 2 2 HABApBpabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABApBpabadM1. try clear HABApBpabadM2. try clear HABApBpabadM3. try clear HABApBpabadm4. try clear HABApBpabadm3. try clear HABApBpabadm2. try clear HABApBpabadm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: Ap :: Bp :: ad ::   de rang : 4 et 4 *)
assert(HAApBpabadm4 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	try assert(HOoAApBpadeq : rk(Oo :: A :: Ap :: Bp :: ad :: nil) = 4) by (apply LOoAApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApBpadMtmp : rk(Oo :: A :: Ap :: Bp :: ad :: nil) <= 4) by (solve_hyps_max HOoAApBpadeq HOoAApBpadM4).
	try assert(HOoAApBpabadeq : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoAApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApBpabadmtmp : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpabadeq HOoAApBpabadm4).
	try assert(HAApBpadeq : rk(A :: Ap :: Bp :: ad :: nil) = 4) by (apply LAApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApBpadmtmp : rk(A :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HAApBpadeq HAApBpadm4).
	assert(Hincl : incl (A :: Ap :: Bp :: ad :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ad :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: Bp :: ad :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ad :: A :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: Bp :: ad :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpabadmtmp;try rewrite HT2 in HOoAApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ad :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (A :: Ap :: Bp :: ad :: nil) 4 4 4 HOoAApBpabadmtmp HAApBpadmtmp HOoAApBpadMtmp Hincl); apply HT.
}


assert(HAApBpabadM : rk(A :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpabadm : rk(A :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HAApBpabadeq HAApBpabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabad *)
(* dans constructLemma(), requis par LApBpabad *)
(* dans constructLemma(), requis par LOoBApBpabad *)
(* dans constructLemma(), requis par LOoABApBpabad *)
(* dans la couche 0 *)
Lemma LOoABCApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabad requis par la preuve de (?)OoABCApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpabadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpabadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: B :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoABApBpabadm4 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	try assert(HOoABCApBpabadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoABCApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	try assert(HOoABadeq : rk(Oo :: A :: B :: ad :: nil) = 4) by (apply LOoABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABadmtmp : rk(Oo :: A :: B :: ad :: nil) >= 4) by (solve_hyps_min HOoABadeq HOoABadm4).
	assert(Hincl : incl (Oo :: A :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: ad :: nil) 4 4 4 HOoABCApBpabadmtmp HOoABadmtmp HOoABCadMtmp Hincl); apply HT.
}


assert(HOoABApBpabadM : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpabadm : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpabad requis par la preuve de (?)OoBApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoBApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpabad requis par la preuve de (?)OoBApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpabadm3 : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabadmtmp;try rewrite HT2 in HOoABApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpabadmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ad ::   de rang : 3 et 3 *)
assert(HOoBApBpabadm4 : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	try assert(HOoAApadeq : rk(Oo :: A :: Ap :: ad :: nil) = 3) by (apply LOoAApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApadMtmp : rk(Oo :: A :: Ap :: ad :: nil) <= 3) by (solve_hyps_max HOoAApadeq HOoAApadM3).
	try assert(HOoABApBpabadeq : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoABApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApBpabadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm4).
	try assert(HOoApadeq : rk(Oo :: Ap :: ad :: nil) = 3) by (apply LOoApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApadmtmp : rk(Oo :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HOoApadeq HOoApadm3).
	assert(Hincl : incl (Oo :: Ap :: ad :: nil) (list_inter (Oo :: A :: Ap :: ad :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: ad :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ad :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: ad :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabadmtmp;try rewrite HT2 in HOoABApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ad :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: Ap :: ad :: nil) 4 3 3 HOoABApBpabadmtmp HOoApadmtmp HOoAApadMtmp Hincl); apply HT.
}


assert(HOoBApBpabadM : rk(Oo :: B :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpabadm : rk(Oo :: B :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoBApBpabadeq HOoBApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: ab :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpabad requis par la preuve de (?)ApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpabad requis par la preuve de (?)ApBpabad pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpabad requis par la preuve de (?)ApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoBApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpabad requis par la preuve de (?)OoBApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpabadm3 : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabadmtmp;try rewrite HT2 in HOoABApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpabadmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpabad requis par la preuve de (?)ApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HApBpabadm2 : rk(Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBApBpabadmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoBApBpabadeq HOoBApBpabadm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: B :: Bp :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabadmtmp;try rewrite HT2 in HOoBApBpabadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: ad :: nil) (Bp :: nil) 3 1 2 HOoBApBpabadmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApBpabadM3 : rk(Ap :: Bp :: ab :: ad :: nil) <= 3).
{
	try assert(HApBpabeq : rk(Ap :: Bp :: ab :: nil) = 2) by (apply LApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: ab :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: ab :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: ad :: nil) ((Ap :: Bp :: ab :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (ad :: nil) (nil) 2 1 0 HApBpabMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Bp :: ad ::  de rang :  2 et 2 	 A : Oo :: B :: Bp :: ad ::   de rang : 3 et 3 *)
assert(HApBpabadm3 : rk(Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoBBpadeq : rk(Oo :: B :: Bp :: ad :: nil) = 3) by (apply LOoBBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpadMtmp : rk(Oo :: B :: Bp :: ad :: nil) <= 3) by (solve_hyps_max HOoBBpadeq HOoBBpadM3).
	try assert(HOoBApBpabadeq : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoBApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApBpabadmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoBApBpabadeq HOoBApBpabadm4).
	try assert(HBpadeq : rk(Bp :: ad :: nil) = 2) by (apply LBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpadmtmp : rk(Bp :: ad :: nil) >= 2) by (solve_hyps_min HBpadeq HBpadm2).
	assert(Hincl : incl (Bp :: ad :: nil) (list_inter (Oo :: B :: Bp :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: B :: Bp :: ad :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: ad :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: B :: Bp :: ad :: nil) ++ (Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabadmtmp;try rewrite HT2 in HOoBApBpabadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil) (Bp :: ad :: nil) 4 2 3 HOoBApBpabadmtmp HBpadmtmp HOoBBpadMtmp Hincl); apply HT.
}
try clear HBpadM1. try clear HBpadM2. try clear HBpadM3. try clear HBpadm4. try clear HBpadm3. try clear HBpadm2. try clear HBpadm1. try clear HOoBApBpabadM1. try clear HOoBApBpabadM2. try clear HOoBApBpabadM3. try clear HOoBApBpabadm4. try clear HOoBApBpabadm3. try clear HOoBApBpabadm2. try clear HOoBApBpabadm1. 

assert(HApBpabadM : rk(Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpabadm : rk(Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HApBpabadeq HApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Aabad requis par la preuve de (?)Aabad pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabad requis par la preuve de (?)Aabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabad requis par la preuve de (?)OoABCApabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabadm3 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabadm4 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabadM1. try clear HOoABCApabadM2. try clear HOoABCApabadM3. try clear HOoABCApabadm4. try clear HOoABCApabadm3. try clear HOoABCApabadm2. try clear HOoABCApabadm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabadm2 : rk(A :: B :: ab :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabadmtmp : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HABCApabadeq HABCApabadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ad :: nil) (C :: Ap :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabadmtmp;try rewrite HT2 in HABCApabadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: ad :: nil) (nil) 4 0 2 HABCApabadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabadM1. try clear HABCApabadM2. try clear HABCApabadM3. try clear HABCApabadm4. try clear HABCApabadm3. try clear HABCApabadm2. try clear HABCApabadm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABabadM3 : rk(A :: B :: ab :: ad :: nil) <= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: ab :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (ad :: nil) (nil) 2 1 0 HABabMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Aabad requis par la preuve de (?)Aabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: ad ::  de rang :  2 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabadm2 : rk(A :: ab :: ad :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabadmtmp : rk(A :: B :: ab :: ad :: nil) >= 2) by (solve_hyps_min HABabadeq HABabadm2).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: A :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabadmtmp;try rewrite HT2 in HABabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: ad :: nil) (A :: ab :: nil) 2 2 2 HABabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAabadm3 : rk(A :: ab :: ad :: nil) >= 3).
{
	try assert(HApBpabadeq : rk(Ap :: Bp :: ab :: ad :: nil) = 3) by (apply LApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabadMtmp : rk(Ap :: Bp :: ab :: ad :: nil) <= 3) by (solve_hyps_max HApBpabadeq HApBpabadM3).
	try assert(HAApBpabadeq : rk(A :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LAApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApBpabadmtmp : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HAApBpabadeq HAApBpabadm4).
	try assert(Habadeq : rk(ab :: ad :: nil) = 2) by (apply Labad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habadmtmp : rk(ab :: ad :: nil) >= 2) by (solve_hyps_min Habadeq Habadm2).
	assert(Hincl : incl (ab :: ad :: nil) (list_inter (A :: ab :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: ad :: nil) (A :: ab :: ad :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: ad :: Ap :: Bp :: ab :: ad :: nil) ((A :: ab :: ad :: nil) ++ (Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpabadmtmp;try rewrite HT2 in HAApBpabadmtmp.
	assert(HT := rule_2 (A :: ab :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil) (ab :: ad :: nil) 4 2 3 HAApBpabadmtmp Habadmtmp HApBpabadMtmp Hincl);apply HT.
}


assert(HAabadM : rk(A :: ab :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAabadeq HAabadM3).
assert(HAabadm : rk(A :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HAabadeq HAabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABabad *)
(* dans la couche 0 *)
Lemma LOoABCabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabad requis par la preuve de (?)OoABCabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCabadm4 : rk(Oo :: A :: B :: C :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCabadM : rk(Oo :: A :: B :: C :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCabadm : rk(Oo :: A :: B :: C :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCabadeq HOoABCabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabad requis par la preuve de (?)OoABCApabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabadm3 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabadm4 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabadM1. try clear HOoABCApabadM2. try clear HOoABCApabadM3. try clear HOoABCApabadm4. try clear HOoABCApabadm3. try clear HOoABCApabadm2. try clear HOoABCApabadm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabadm2 : rk(A :: B :: ab :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabadmtmp : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HABCApabadeq HABCApabadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ad :: nil) (C :: Ap :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabadmtmp;try rewrite HT2 in HABCApabadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: ad :: nil) (nil) 4 0 2 HABCApabadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabadM1. try clear HABCApabadM2. try clear HABCApabadM3. try clear HABCApabadm4. try clear HABCApabadm3. try clear HABCApabadm2. try clear HABCApabadm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HABabadM3 : rk(A :: B :: ab :: ad :: nil) <= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: ab :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (ad :: nil) (nil) 2 1 0 HABabMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HABabadm3 : rk(A :: B :: ab :: ad :: nil) >= 3).
{
	try assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	try assert(HOoABCabadeq : rk(Oo :: A :: B :: C :: ab :: ad :: nil) = 4) by (apply LOoABCabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCabadmtmp : rk(Oo :: A :: B :: C :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCabadeq HOoABCabadm4).
	try assert(HABadeq : rk(A :: B :: ad :: nil) = 3) by (apply LABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABadmtmp : rk(A :: B :: ad :: nil) >= 3) by (solve_hyps_min HABadeq HABadm3).
	assert(Hincl : incl (A :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: ad :: nil) (Oo :: A :: B :: C :: ad :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: A :: B :: ab :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabadmtmp;try rewrite HT2 in HOoABCabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (A :: B :: ab :: ad :: nil) (A :: B :: ad :: nil) 4 3 4 HOoABCabadmtmp HABadmtmp HOoABCadMtmp Hincl); apply HT.
}
try clear HOoABCabadM1. try clear HOoABCabadM2. try clear HOoABCabadM3. try clear HOoABCabadm4. try clear HOoABCabadm3. try clear HOoABCabadm2. try clear HOoABCabadm1. 

assert(HABabadM : rk(A :: B :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabadm : rk(A :: B :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HABabadeq HABabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabad *)
(* dans la couche 0 *)
Lemma LOoABCApabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabad requis par la preuve de (?)OoABCApabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApabadM : rk(Oo :: A :: B :: C :: Ap :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabadm : rk(Oo :: A :: B :: C :: Ap :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabadm3 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApabadeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) = 4) by (apply LOoABCApabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabadm4 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApabadeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) = 4) by (apply LOoABCApabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabadM1. try clear HOoABCApabadM2. try clear HOoABCApabadM3. try clear HOoABCApabadm4. try clear HOoABCApabadm3. try clear HOoABCApabadm2. try clear HOoABCApabadm1. 

assert(HABCApabadM : rk(A :: B :: C :: Ap :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabadm : rk(A :: B :: C :: Ap :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HABCApabadeq HABCApabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabadm3 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpabadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoABCApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpabadm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApBpabadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoABCApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApBpabadM1. try clear HOoABCApBpabadM2. try clear HOoABCApBpabadM3. try clear HOoABCApBpabadm4. try clear HOoABCApBpabadm3. try clear HOoABCApBpabadm2. try clear HOoABCApBpabadm1. 

assert(HABCApBpabadM : rk(A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpabadm : rk(A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HABCApBpabadeq HABCApBpabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacad *)
(* dans constructLemma(), requis par LAacDad *)
(* dans la couche 0 *)
Lemma LACacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)OoABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadm2 : rk(A :: C :: ac :: D :: ad :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacDadeq HOoABCApacDadm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadmtmp;try rewrite HT2 in HOoABCApacDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil) (A :: nil) 4 1 3 HOoABCApacDadmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDadM1. try clear HOoABCApacDadM2. try clear HOoABCApacDadM3. try clear HOoABCApacDadm4. try clear HOoABCApacDadm3. try clear HOoABCApacDadm2. try clear HOoABCApacDadm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACacDadM3 : rk(A :: C :: ac :: D :: ad :: nil) <= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: ac :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HACacMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadm3 : rk(A :: C :: ac :: D :: ad :: nil) >= 3).
{
	try assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}


assert(HACacDadM : rk(A :: C :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDadm : rk(A :: C :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HACacDadeq HACacDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AacDad requis par la preuve de (?)AacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AacDad requis par la preuve de (?)AacDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDad requis par la preuve de (?)AacDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HAacDadM3 : rk(A :: ac :: D :: ad :: nil) <= 3).
{
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HacMtmp : rk(ac :: nil) <= 1) by (solve_hyps_max Haceq HacM1).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (ac :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: nil) (ac :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ac :: A :: D :: ad :: nil) ((ac :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ac :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HacMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDadm2 : rk(A :: ac :: D :: ad :: nil) >= 2).
{
	try assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: nil) (A :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: ac :: nil) (A :: ac :: D :: ad :: nil) 2 2 HAacmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad ::  de rang :  3 et 3 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDadm3 : rk(A :: ac :: D :: ad :: nil) >= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	try assert(HACacDadeq : rk(A :: C :: ac :: D :: ad :: nil) = 3) by (apply LACacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacDadmtmp : rk(A :: C :: ac :: D :: ad :: nil) >= 3) by (solve_hyps_min HACacDadeq HACacDadm3).
	try assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: A :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadmtmp;try rewrite HT2 in HACacDadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: ad :: nil) (A :: ac :: nil) 3 2 2 HACacDadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}


assert(HAacDadM : rk(A :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacDadm : rk(A :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HAacDadeq HAacDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour acad requis par la preuve de (?)acad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(Hacadm2 : rk(ac :: ad :: nil) >= 2).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HAacDadeq : rk(A :: ac :: D :: ad :: nil) = 3) by (apply LAacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAacDadmtmp : rk(A :: ac :: D :: ad :: nil) >= 3) by (solve_hyps_min HAacDadeq HAacDadm3).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (ac :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: nil) (ac :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ac :: ad :: A :: D :: ad :: nil) ((ac :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAacDadmtmp;try rewrite HT2 in HAacDadmtmp.
	assert(HT := rule_2 (ac :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HAacDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}


assert(HacadM : rk(ac :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max Hacadeq HacadM2).
assert(Hacadm : rk(ac :: ad ::  nil) >= 1) by (solve_hyps_min Hacadeq Hacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACacad *)
(* dans la couche 0 *)
Lemma LOoABCacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCacad requis par la preuve de (?)OoABCacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCacadm4 : rk(Oo :: A :: B :: C :: ac :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCacadM : rk(Oo :: A :: B :: C :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCacadm : rk(Oo :: A :: B :: C :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCacadeq HOoABCacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacad requis par la preuve de (?)ACacad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)OoABCApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacadm2 : rk(A :: C :: ac :: ad :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacadeq HOoABCApacadm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacadmtmp;try rewrite HT2 in HOoABCApacadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: ad :: nil) (A :: nil) 4 1 3 HOoABCApacadmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacadM1. try clear HOoABCApacadM2. try clear HOoABCApacadM3. try clear HOoABCApacadm4. try clear HOoABCApacadm3. try clear HOoABCApacadm2. try clear HOoABCApacadm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HACacadM3 : rk(A :: C :: ac :: ad :: nil) <= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: ac :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: ad :: nil) (A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ad :: nil) ((A :: C :: ac :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (ad :: nil) (nil) 2 1 0 HACacMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: C :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HACacadm3 : rk(A :: C :: ac :: ad :: nil) >= 3).
{
	try assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	try assert(HOoABCacadeq : rk(Oo :: A :: B :: C :: ac :: ad :: nil) = 4) by (apply LOoABCacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCacadmtmp : rk(Oo :: A :: B :: C :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCacadeq HOoABCacadm4).
	try assert(HACadeq : rk(A :: C :: ad :: nil) = 3) by (apply LACad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACadmtmp : rk(A :: C :: ad :: nil) >= 3) by (solve_hyps_min HACadeq HACadm3).
	assert(Hincl : incl (A :: C :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (A :: C :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ac :: ad :: nil) (Oo :: A :: B :: C :: ad :: A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: A :: C :: ac :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (A :: C :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCacadmtmp;try rewrite HT2 in HOoABCacadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (A :: C :: ac :: ad :: nil) (A :: C :: ad :: nil) 4 3 4 HOoABCacadmtmp HACadmtmp HOoABCadMtmp Hincl); apply HT.
}
try clear HOoABCadM1. try clear HOoABCadM2. try clear HOoABCadM3. try clear HOoABCadm4. try clear HOoABCadm3. try clear HOoABCadm2. try clear HOoABCadm1. try clear HOoABCacadM1. try clear HOoABCacadM2. try clear HOoABCacadM3. try clear HOoABCacadm4. try clear HOoABCacadm3. try clear HOoABCacadm2. try clear HOoABCacadm1. 

assert(HACacadM : rk(A :: C :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacadm : rk(A :: C :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HACacadeq HACacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)OoABCApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApacadM : rk(Oo :: A :: B :: C :: Ap :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacadm : rk(Oo :: A :: B :: C :: Ap :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApacadeq HOoABCApacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDad *)
(* dans constructLemma(), requis par LApDDpad *)
(* dans la couche 0 *)
Lemma LOoApDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: D :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApDDpad requis par la preuve de (?)OoApDDpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApDDpad requis par la preuve de (?)OoApDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpad requis par la preuve de (?)OoApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpad requis par la preuve de (?)OoABApDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpad requis par la preuve de (?)OoABApDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApDDpad requis par la preuve de (?)OoApDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApDDpadm2 : rk(Oo :: Ap :: D :: Dp :: ad :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpadmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoABApDDpadeq HOoABApDDpadm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: D :: Dp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadmtmp;try rewrite HT2 in HOoABApDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApDDpadmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApDDpadM1. try clear HOoABApDDpadM2. try clear HOoABApDDpadM3. try clear HOoABApDDpadm4. try clear HOoABApDDpadm3. try clear HOoABApDDpadm2. try clear HOoABApDDpadm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApDDpadm3 : rk(Oo :: Ap :: D :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: Dp :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil) 3 3 HOoApDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoApDDpadM3 : rk(Oo :: Ap :: D :: Dp :: ad :: nil) <= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HApDpadeq : rk(Ap :: Dp :: ad :: nil) = 2) by (apply LApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	try assert(HDpeq : rk(Dp :: nil) = 1) by (apply LDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Ap :: Dp :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (Ap :: Dp :: ad :: nil) (Dp :: nil) 2 2 1 HOoDDpMtmp HApDpadMtmp HDpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoApDDpadM : rk(Oo :: Ap :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApDDpadm : rk(Oo :: Ap :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoApDDpadeq HOoApDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: D :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApDDpadM3 : rk(Ap :: D :: Dp :: ad :: nil) <= 3).
{
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	try assert(HApDpadeq : rk(Ap :: Dp :: ad :: nil) = 2) by (apply LApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: D :: Dp :: ad :: nil) (D :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: Dp :: ad :: nil) ((D :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HDMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDDpadm2 : rk(Ap :: D :: Dp :: ad :: nil) >= 2).
{
	try assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: D :: Dp :: ad ::  de rang :  3 et 3 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HApDDpadm3 : rk(Ap :: D :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoApDDpadeq : rk(Oo :: Ap :: D :: Dp :: ad :: nil) = 3) by (apply LOoApDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDDpadmtmp : rk(Oo :: Ap :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoApDDpadeq HOoApDDpadm3).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Ap :: D :: Dp :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApDDpadmtmp;try rewrite HT2 in HOoApDDpadmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil) (D :: Dp :: nil) 3 2 2 HOoApDDpadmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HApDDpadM : rk(Ap :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDDpadm : rk(Ap :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HApDDpadeq HApDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dad requis par la preuve de (?)Dad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HDadm2 : rk(D :: ad :: nil) >= 2).
{
	try assert(HApDpadeq : rk(Ap :: Dp :: ad :: nil) = 2) by (apply LApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	try assert(HApDDpadeq : rk(Ap :: D :: Dp :: ad :: nil) = 3) by (apply LApDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDDpadmtmp : rk(Ap :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HApDDpadeq HApDDpadm3).
	try assert(Hadeq : rk(ad :: nil) = 1) by (apply Lad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (D :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: D :: Dp :: ad :: nil) (D :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: ad :: Ap :: Dp :: ad :: nil) ((D :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApDDpadmtmp;try rewrite HT2 in HApDDpadmtmp.
	assert(HT := rule_2 (D :: ad :: nil) (Ap :: Dp :: ad :: nil) (ad :: nil) 3 1 2 HApDDpadmtmp Hadmtmp HApDpadMtmp Hincl);apply HT.
}


assert(HDadM : rk(D :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDadeq HDadM2).
assert(HDadm : rk(D :: ad ::  nil) >= 1) by (solve_hyps_min HDadeq HDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApDad *)
(* dans la couche 0 *)
Lemma LOoABCApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApDadM : rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDadm : rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDadm3 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApDadeq : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) = 4) by (apply LOoABCApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDadm4 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApDadeq : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) = 4) by (apply LOoABCApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HABCApDadM : rk(A :: B :: C :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDadm : rk(A :: B :: C :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCApDadeq HABCApDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApBpDad *)
(* dans la couche 0 *)
Lemma LOoABCApBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABCApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpDadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpDad requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpDad requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpDadm3 : rk(A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpDadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LOoABCApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpDadm4 : rk(A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApBpDadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LOoABCApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


assert(HABCApBpDadM : rk(A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpDadm : rk(A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCApBpDadeq HABCApBpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABCCpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCCpDadm4 : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCCpDadM : rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpDadm : rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCCpDadeq HOoABCCpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDad requis par la preuve de (?)BabDad pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDad requis par la preuve de (?)BabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDad requis par la preuve de (?)BabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDad requis par la preuve de (?)OoABCApabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDadM1. try clear HOoABCApabDadM2. try clear HOoABCApabDadM3. try clear HOoABCApabDadm4. try clear HOoABCApabDadm3. try clear HOoABCApabDadm2. try clear HOoABCApabDadm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadm2 : rk(A :: B :: ab :: D :: ad :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApabDadeq HABCApabDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadmtmp;try rewrite HT2 in HABCApabDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil) (nil) 4 0 2 HABCApabDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabDadM1. try clear HABCApabDadM2. try clear HABCApabDadM3. try clear HABCApabDadm4. try clear HABCApabDadm3. try clear HABCApabDadm2. try clear HABCApabDadm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABabDadM3 : rk(A :: B :: ab :: D :: ad :: nil) <= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: ab :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HABabMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDad requis par la preuve de (?)BabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad ::  de rang :  2 et 3 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadm2 : rk(B :: ab :: D :: ad :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadmtmp : rk(A :: B :: ab :: D :: ad :: nil) >= 2) by (solve_hyps_min HABabDadeq HABabDadm2).
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadmtmp;try rewrite HT2 in HABabDadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: nil) (B :: ab :: nil) 2 2 2 HABabDadmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadm3 : rk(B :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HABabDadeq : rk(A :: B :: ab :: D :: ad :: nil) = 3) by (apply LABabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabDadmtmp : rk(A :: B :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HABabDadeq HABabDadm3).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadmtmp;try rewrite HT2 in HABabDadmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: nil) (D :: ad :: nil) 3 2 2 HABabDadmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBabDadM3 : rk(B :: ab :: D :: ad :: nil) <= 3).
{
	try assert(HABabDadeq : rk(A :: B :: ab :: D :: ad :: nil) = 3) by (apply LABabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabDadMtmp : rk(A :: B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HABabDadeq HABabDadM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: ab :: D :: ad :: nil) (A :: B :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: ab :: D :: ad :: nil) (A :: B :: ab :: D :: ad :: nil) 3 3 HABabDadMtmp Hcomp Hincl);apply HT.
}
try clear HABabDadM1. try clear HABabDadM2. try clear HABabDadM3. try clear HABabDadm4. try clear HABabDadm3. try clear HABabDadm2. try clear HABabDadm1. 

assert(HBabDadM : rk(B :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBabDadm : rk(B :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HBabDadeq HBabDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabDad *)
(* dans la couche 0 *)
Lemma LOoABCApabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDad requis par la preuve de (?)OoABCApabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApabDadM : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabDadm : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApabDadeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) = 4) by (apply LOoABCApabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApabDadeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) = 4) by (apply LOoABCApabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDadM1. try clear HOoABCApabDadM2. try clear HOoABCApabDadM3. try clear HOoABCApabDadm4. try clear HOoABCApabDadm3. try clear HOoABCApabDadm2. try clear HOoABCApabDadm1. 

assert(HABCApabDadM : rk(A :: B :: C :: Ap :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabDadm : rk(A :: B :: C :: Ap :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCApabDadeq HABCApabDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApBpabDad *)
(* dans la couche 0 *)
Lemma LOoABCApBpabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDad requis par la preuve de (?)OoABCApBpabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpabDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpabDadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabDadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabDadeq HOoABCApBpabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpabDad requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpabDad requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabDadm3 : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpabDadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) = 4) by (apply LOoABCApBpabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDadeq HOoABCApBpabDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDadmtmp;try rewrite HT2 in HOoABCApBpabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpabDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpabDadm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApBpabDadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) = 4) by (apply LOoABCApBpabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDadeq HOoABCApBpabDadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDadmtmp;try rewrite HT2 in HOoABCApBpabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApBpabDadM1. try clear HOoABCApBpabDadM2. try clear HOoABCApBpabDadM3. try clear HOoABCApBpabDadm4. try clear HOoABCApBpabDadm3. try clear HOoABCApBpabDadm2. try clear HOoABCApBpabDadm1. 

assert(HABCApBpabDadM : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpabDadm : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCApBpabDadeq HABCApBpabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ac :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDad requis par la preuve de (?)CacDad pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDad requis par la preuve de (?)CacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDad requis par la preuve de (?)CacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)OoABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadm2 : rk(A :: C :: ac :: D :: ad :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacDadeq HOoABCApacDadm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadmtmp;try rewrite HT2 in HOoABCApacDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil) (A :: nil) 4 1 3 HOoABCApacDadmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDadM1. try clear HOoABCApacDadM2. try clear HOoABCApacDadM3. try clear HOoABCApacDadm4. try clear HOoABCApacDadm3. try clear HOoABCApacDadm2. try clear HOoABCApacDadm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACacDadM3 : rk(A :: C :: ac :: D :: ad :: nil) <= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: ac :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HACacMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDad requis par la preuve de (?)CacDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad ::  de rang :  2 et 3 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadm2 : rk(C :: ac :: D :: ad :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadmtmp : rk(A :: C :: ac :: D :: ad :: nil) >= 2) by (solve_hyps_min HACacDadeq HACacDadm2).
	try assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadmtmp;try rewrite HT2 in HACacDadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: nil) (C :: ac :: nil) 2 2 2 HACacDadmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadm3 : rk(C :: ac :: D :: ad :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HACacDadeq : rk(A :: C :: ac :: D :: ad :: nil) = 3) by (apply LACacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacDadmtmp : rk(A :: C :: ac :: D :: ad :: nil) >= 3) by (solve_hyps_min HACacDadeq HACacDadm3).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadmtmp;try rewrite HT2 in HACacDadmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: nil) (D :: ad :: nil) 3 2 2 HACacDadmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCacDadM3 : rk(C :: ac :: D :: ad :: nil) <= 3).
{
	try assert(HACacDadeq : rk(A :: C :: ac :: D :: ad :: nil) = 3) by (apply LACacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacDadMtmp : rk(A :: C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HACacDadeq HACacDadM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: ac :: D :: ad :: nil) (A :: C :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: ac :: D :: ad :: nil) (A :: C :: ac :: D :: ad :: nil) 3 3 HACacDadMtmp Hcomp Hincl);apply HT.
}
try clear HACacDadM1. try clear HACacDadM2. try clear HACacDadM3. try clear HACacDadm4. try clear HACacDadm3. try clear HACacDadm2. try clear HACacDadm1. 

assert(HCacDadM : rk(C :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCacDadm : rk(C :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HCacDadeq HCacDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)OoABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApacDadM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDadm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApacDadeq HOoABCApacDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApDpad *)
(* dans la couche 0 *)
Lemma LOoABCApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpad requis par la preuve de (?)OoABCApDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApDpadM : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDpadm : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApDpadeq HOoABCApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDpad requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDpad requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDpadm3 : rk(A :: B :: C :: Ap :: Dp :: ad :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApDpadeq : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) = 4) by (apply LOoABCApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDpadeq HOoABCApDpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadmtmp;try rewrite HT2 in HOoABCApDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDpadm4 : rk(A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApDpadeq : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) = 4) by (apply LOoABCApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDpadeq HOoABCApDpadm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadmtmp;try rewrite HT2 in HOoABCApDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDpadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApDpadM1. try clear HOoABCApDpadM2. try clear HOoABCApDpadM3. try clear HOoABCApDpadm4. try clear HOoABCApDpadm3. try clear HOoABCApDpadm2. try clear HOoABCApDpadm1. 

assert(HABCApDpadM : rk(A :: B :: C :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDpadm : rk(A :: B :: C :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HABCApDpadeq HABCApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpad requis par la preuve de (?)OoABCApBpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpDDpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpadeq HOoABCApBpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(bd ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HbdM : rk(bd ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Hbdeq HbdM1).
assert(Hbdm : rk(bd ::  nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDbd *)
(* dans constructLemma(), requis par LBpDDpbd *)
(* dans constructLemma(), requis par LOoBpDDpbd *)
(* dans la couche 0 *)
Lemma LBpDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HBpDpbdM : rk(Bp :: Dp :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpDpbdeq HBpDpbdM3).
assert(HBpDpbdm : rk(Bp :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBpDpbdeq HBpDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: D :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBpDDpbd requis par la preuve de (?)OoBpDDpbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBpDDpbd requis par la preuve de (?)OoBpDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpDDpbd requis par la preuve de (?)OoBpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpDDpbd requis par la preuve de (?)OoBBpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbd requis par la preuve de (?)OoBCApBpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbd requis par la preuve de (?)OoABCApBpDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpDDpbd requis par la preuve de (?)OoBCApBpDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpDDpbdm4 : rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdeq HOoABCApBpDDpbdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdmtmp;try rewrite HT2 in HOoABCApBpDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpDDpbdmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApBpDDpbdM1. try clear HOoABCApBpDDpbdM2. try clear HOoABCApBpDDpbdM3. try clear HOoABCApBpDDpbdm4. try clear HOoABCApBpDDpbdm3. try clear HOoABCApBpDDpbdm2. try clear HOoABCApBpDDpbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpDDpbd requis par la preuve de (?)OoBBpDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpDDpbdm2 : rk(Oo :: B :: Bp :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpDDpbdmtmp : rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApBpDDpbdeq HOoBCApBpDDpbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) (C :: Ap :: Oo :: B :: Bp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: D :: Dp :: bd :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpDDpbdmtmp;try rewrite HT2 in HOoBCApBpDDpbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: D :: Dp :: bd :: nil) (nil) 4 0 2 HOoBCApBpDDpbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApBpDDpbdM1. try clear HOoBCApBpDDpbdM2. try clear HOoBCApBpDDpbdM3. try clear HOoBCApBpDDpbdm4. try clear HOoBCApBpDDpbdm3. try clear HOoBCApBpDDpbdm2. try clear HOoBCApBpDDpbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpDDpbd requis par la preuve de (?)OoBpDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: D :: Dp :: bd ::  de rang :  2 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpDDpbdm2 : rk(Oo :: Bp :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpDDpbdmtmp : rk(Oo :: B :: Bp :: D :: Dp :: bd :: nil) >= 2) by (solve_hyps_min HOoBBpDDpbdeq HOoBBpDDpbdm2).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Bp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: D :: Dp :: bd :: nil) (Oo :: B :: Bp :: Oo :: Bp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Bp :: D :: Dp :: bd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Bp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpDDpbdmtmp;try rewrite HT2 in HOoBBpDDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Bp :: D :: Dp :: bd :: nil) (Oo :: Bp :: nil) 2 2 2 HOoBBpDDpbdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBBpDDpbdM1. try clear HOoBBpDDpbdM2. try clear HOoBBpDDpbdM3. try clear HOoBBpDDpbdm4. try clear HOoBBpDDpbdm3. try clear HOoBBpDDpbdm2. try clear HOoBBpDDpbdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpDDpbdm3 : rk(Oo :: Bp :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (Oo :: Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: Dp :: nil) (Oo :: Bp :: D :: Dp :: bd :: nil) 3 3 HOoBpDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoBpDDpbdM3 : rk(Oo :: Bp :: D :: Dp :: bd :: nil) <= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HBpDpbdeq : rk(Bp :: Dp :: bd :: nil) = 2) by (apply LBpDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	try assert(HDpeq : rk(Dp :: nil) = 1) by (apply LDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Bp :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (Bp :: Dp :: bd :: nil) (Dp :: nil) 2 2 1 HOoDDpMtmp HBpDpbdMtmp HDpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoBpDDpbdM : rk(Oo :: Bp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBpDDpbdm : rk(Oo :: Bp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBpDDpbdeq HOoBpDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: D :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBpDDpbdM3 : rk(Bp :: D :: Dp :: bd :: nil) <= 3).
{
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	try assert(HBpDpbdeq : rk(Bp :: Dp :: bd :: nil) = 2) by (apply LBpDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: D :: Dp :: bd :: nil) (D :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: Dp :: bd :: nil) ((D :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Bp :: Dp :: bd :: nil) (nil) 1 2 0 HDMtmp HBpDpbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpDDpbdm2 : rk(Bp :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil) 2 2 HBpDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Bp :: D :: Dp :: bd ::  de rang :  3 et 3 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBpDDpbdm3 : rk(Bp :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoBpDDpbdeq : rk(Oo :: Bp :: D :: Dp :: bd :: nil) = 3) by (apply LOoBpDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpDDpbdmtmp : rk(Oo :: Bp :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoBpDDpbdeq HOoBpDDpbdm3).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: Bp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Bp :: D :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (Bp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBpDDpbdmtmp;try rewrite HT2 in HOoBpDDpbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil) (D :: Dp :: nil) 3 2 2 HOoBpDDpbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HBpDDpbdM : rk(Bp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpDDpbdm : rk(Bp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBpDDpbdeq HBpDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dbd requis par la preuve de (?)Dbd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HDbdm2 : rk(D :: bd :: nil) >= 2).
{
	try assert(HBpDpbdeq : rk(Bp :: Dp :: bd :: nil) = 2) by (apply LBpDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	try assert(HBpDDpbdeq : rk(Bp :: D :: Dp :: bd :: nil) = 3) by (apply LBpDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDDpbdmtmp : rk(Bp :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HBpDDpbdeq HBpDDpbdm3).
	try assert(Hbdeq : rk(bd :: nil) = 1) by (apply Lbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (D :: bd :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: D :: Dp :: bd :: nil) (D :: bd :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: bd :: Bp :: Dp :: bd :: nil) ((D :: bd :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpDDpbdmtmp;try rewrite HT2 in HBpDDpbdmtmp.
	assert(HT := rule_2 (D :: bd :: nil) (Bp :: Dp :: bd :: nil) (bd :: nil) 3 1 2 HBpDDpbdmtmp Hbdmtmp HBpDpbdMtmp Hincl);apply HT.
}


assert(HDbdM : rk(D :: bd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDbdeq HDbdM2).
assert(HDbdm : rk(D :: bd ::  nil) >= 1) by (solve_hyps_min HDbdeq HDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LADbd *)
(* dans la couche 0 *)
Lemma LABDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDbd requis par la preuve de (?)ABDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)OoABCApDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDbd requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDbd requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDbdm3 : rk(A :: B :: C :: Ap :: D :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDbdm4 : rk(A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApDbdM1. try clear HOoABCApDbdM2. try clear HOoABCApDbdM3. try clear HOoABCApDbdm4. try clear HOoABCApDbdm3. try clear HOoABCApDbdm2. try clear HOoABCApDbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour BDbd requis par la preuve de (?)ABDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HABDbdM3 : rk(A :: B :: D :: bd :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: bd :: nil) (A :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: bd :: nil) ((A :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: D :: bd :: nil) (nil) 1 2 0 HAMtmp HBDbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABDbdm2 : rk(A :: B :: D :: bd :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApDbdmtmp : rk(A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HABCApDbdeq HABCApDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: bd :: nil) (C :: Ap :: A :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDbdmtmp;try rewrite HT2 in HABCApDbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: bd :: nil) (nil) 4 0 2 HABCApDbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApDbdM1. try clear HABCApDbdM2. try clear HABCApDbdM3. try clear HABCApDbdm4. try clear HABCApDbdm3. try clear HABCApDbdm2. try clear HABCApDbdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDbdm3 : rk(A :: B :: D :: bd :: nil) >= 3).
{
	try assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}


assert(HABDbdM : rk(A :: B :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDbdm : rk(A :: B :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABDbdeq HABDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LADbd *)
(* dans la couche 0 *)
Lemma LBDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HBDbdM : rk(B :: D :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBDbdeq HBDbdM3).
assert(HBDbdm : rk(B :: D :: bd ::  nil) >= 1) by (solve_hyps_min HBDbdeq HBDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADbd requis par la preuve de (?)ADbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCDbd requis par la preuve de (?)ADbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDbd requis par la preuve de (?)OoABCDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCDbdm4 : rk(Oo :: A :: B :: C :: D :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADbd requis par la preuve de (?)ADbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: D ::   de rang : 4 et 4 *)
assert(HADbdm2 : rk(A :: D :: bd :: nil) >= 2).
{
	try assert(HOoABCDeq : rk(Oo :: A :: B :: C :: D :: nil) = 4) by (apply LOoABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCDMtmp : rk(Oo :: A :: B :: C :: D :: nil) <= 4) by (solve_hyps_max HOoABCDeq HOoABCDM4).
	assert(HOoABCDbdmtmp : rk(Oo :: A :: B :: C :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCDbdeq HOoABCDbdm4).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (Oo :: A :: B :: C :: D :: nil) (A :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: D :: bd :: nil) (Oo :: A :: B :: C :: D :: A :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: D :: A :: D :: bd :: nil) ((Oo :: A :: B :: C :: D :: nil) ++ (A :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCDbdmtmp;try rewrite HT2 in HOoABCDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: D :: nil) (A :: D :: bd :: nil) (A :: D :: nil) 4 2 4 HOoABCDbdmtmp HADmtmp HOoABCDMtmp Hincl); apply HT.
}
try clear HOoABCDbdM1. try clear HOoABCDbdM2. try clear HOoABCDbdM3. try clear HOoABCDbdm4. try clear HOoABCDbdm3. try clear HOoABCDbdm2. try clear HOoABCDbdm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HADbdm3 : rk(A :: D :: bd :: nil) >= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HABDbdeq : rk(A :: B :: D :: bd :: nil) = 3) by (apply LABDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDbdmtmp : rk(A :: B :: D :: bd :: nil) >= 3) by (solve_hyps_min HABDbdeq HABDbdm3).
	try assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (A :: D :: bd :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: bd :: nil) (A :: D :: bd :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: bd :: B :: D :: bd :: nil) ((A :: D :: bd :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDbdmtmp;try rewrite HT2 in HABDbdmtmp.
	assert(HT := rule_2 (A :: D :: bd :: nil) (B :: D :: bd :: nil) (D :: bd :: nil) 3 2 2 HABDbdmtmp HDbdmtmp HBDbdMtmp Hincl);apply HT.
}


assert(HADbdM : rk(A :: D :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HADbdeq HADbdM3).
assert(HADbdm : rk(A :: D :: bd ::  nil) >= 1) by (solve_hyps_min HADbdeq HADbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDbd requis par la preuve de (?)OoABCDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCDbdm4 : rk(Oo :: A :: B :: C :: D :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCDbdM : rk(Oo :: A :: B :: C :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDbdm : rk(Oo :: A :: B :: C :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCDbdeq HOoABCDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApDbd *)
(* dans la couche 0 *)
Lemma LOoABCApDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)OoABCApDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApDbdM : rk(Oo :: A :: B :: C :: Ap :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDbdm : rk(Oo :: A :: B :: C :: Ap :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDbd requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDbd requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDbdm3 : rk(A :: B :: C :: Ap :: D :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApDbdeq : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) = 4) by (apply LOoABCApDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDbdm4 : rk(A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApDbdeq : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) = 4) by (apply LOoABCApDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApDbdM1. try clear HOoABCApDbdM2. try clear HOoABCApDbdM3. try clear HOoABCApDbdm4. try clear HOoABCApDbdm3. try clear HOoABCApDbdm2. try clear HOoABCApDbdm1. 

assert(HABCApDbdM : rk(A :: B :: C :: Ap :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDbdm : rk(A :: B :: C :: Ap :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABCApDbdeq HABCApDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabDbd *)
(* dans la couche 0 *)
Lemma LABabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDbd requis par la preuve de (?)OoABCApabDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDbdM1. try clear HOoABCApabDbdM2. try clear HOoABCApabDbdM3. try clear HOoABCApabDbdm4. try clear HOoABCApabDbdm3. try clear HOoABCApabDbdm2. try clear HOoABCApabDbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDbdm2 : rk(A :: B :: ab :: D :: bd :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDbdeq HABCApabDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDbdmtmp;try rewrite HT2 in HABCApabDbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil) (nil) 4 0 2 HABCApabDbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabDbdM1. try clear HABCApabDbdM2. try clear HABCApabDbdM3. try clear HABCApabDbdm4. try clear HABCApabDbdm3. try clear HABCApabDbdm2. try clear HABCApabDbdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABabDbdM3 : rk(A :: B :: ab :: D :: bd :: nil) <= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HABabMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDbdm3 : rk(A :: B :: ab :: D :: bd :: nil) >= 3).
{
	try assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}


assert(HABabDbdM : rk(A :: B :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDbdm : rk(A :: B :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABabDbdeq HABabDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDbd requis par la preuve de (?)AabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDbd requis par la preuve de (?)OoABCApabDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDbdM1. try clear HOoABCApabDbdM2. try clear HOoABCApabDbdM3. try clear HOoABCApabDbdm4. try clear HOoABCApabDbdm3. try clear HOoABCApabDbdm2. try clear HOoABCApabDbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDbdm2 : rk(A :: B :: ab :: D :: bd :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDbdeq HABCApabDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDbdmtmp;try rewrite HT2 in HABCApabDbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil) (nil) 4 0 2 HABCApabDbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabDbdM1. try clear HABCApabDbdM2. try clear HABCApabDbdM3. try clear HABCApabDbdm4. try clear HABCApabDbdm3. try clear HABCApabDbdm2. try clear HABCApabDbdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABabDbdM3 : rk(A :: B :: ab :: D :: bd :: nil) <= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HABabMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: bd ::  de rang :  2 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDbdm2 : rk(A :: ab :: D :: bd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDbdmtmp : rk(A :: B :: ab :: D :: bd :: nil) >= 2) by (solve_hyps_min HABabDbdeq HABabDbdm2).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDbdmtmp;try rewrite HT2 in HABabDbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDbdm3 : rk(A :: ab :: D :: bd :: nil) >= 3).
{
	try assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: bd :: nil) (A :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: bd :: nil) (A :: ab :: D :: bd :: nil) 3 3 HADbdmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDbdM3 : rk(A :: ab :: D :: bd :: nil) <= 3).
{
	try assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: D :: bd :: nil) (A :: B :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ab :: D :: bd :: nil) (A :: B :: ab :: D :: bd :: nil) 3 3 HABabDbdMtmp Hcomp Hincl);apply HT.
}


assert(HAabDbdM : rk(A :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabDbdm : rk(A :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HAabDbdeq HAabDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabDbd *)
(* dans la couche 0 *)
Lemma LOoABCApabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDbd requis par la preuve de (?)OoABCApabDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApabDbdM : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabDbdm : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApabDbdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) = 4) by (apply LOoABCApabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApabDbdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) = 4) by (apply LOoABCApabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDbdM1. try clear HOoABCApabDbdM2. try clear HOoABCApabDbdM3. try clear HOoABCApabDbdm4. try clear HOoABCApabDbdm3. try clear HOoABCApabDbdm2. try clear HOoABCApabDbdm1. 

assert(HABCApabDbdM : rk(A :: B :: C :: Ap :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabDbdm : rk(A :: B :: C :: Ap :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABCApabDbdeq HABCApabDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCbcDbd *)
(* dans la couche 0 *)
Lemma LBCbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdm2 : rk(B :: C :: bc :: D :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdmtmp;try rewrite HT2 in HOoABCApbcDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil) (nil) 4 0 2 HOoABCApbcDbdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApbcDbdM1. try clear HOoABCApbcDbdM2. try clear HOoABCApbcDbdM3. try clear HOoABCApbcDbdm4. try clear HOoABCApbcDbdm3. try clear HOoABCApbcDbdm2. try clear HOoABCApbcDbdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCbcDbdM3 : rk(B :: C :: bc :: D :: bd :: nil) <= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: bc :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HBCbcMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdm3 : rk(B :: C :: bc :: D :: bd :: nil) >= 3).
{
	try assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}


assert(HBCbcDbdM : rk(B :: C :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDbdm : rk(B :: C :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdm2 : rk(B :: C :: bc :: D :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdmtmp;try rewrite HT2 in HOoABCApbcDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil) (nil) 4 0 2 HOoABCApbcDbdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApbcDbdM1. try clear HOoABCApbcDbdM2. try clear HOoABCApbcDbdM3. try clear HOoABCApbcDbdm4. try clear HOoABCApbcDbdm3. try clear HOoABCApbcDbdm2. try clear HOoABCApbcDbdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCbcDbdM3 : rk(B :: C :: bc :: D :: bd :: nil) <= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: bc :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HBCbcMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd ::  de rang :  2 et 3 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdm2 : rk(C :: bc :: D :: bd :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdmtmp : rk(B :: C :: bc :: D :: bd :: nil) >= 2) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm2).
	try assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdmtmp;try rewrite HT2 in HBCbcDbdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdm3 : rk(C :: bc :: D :: bd :: nil) >= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBCbcDbdeq : rk(B :: C :: bc :: D :: bd :: nil) = 3) by (apply LBCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcDbdmtmp : rk(B :: C :: bc :: D :: bd :: nil) >= 3) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm3).
	try assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdmtmp;try rewrite HT2 in HBCbcDbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCbcDbdM3 : rk(C :: bc :: D :: bd :: nil) <= 3).
{
	try assert(HBCbcDbdeq : rk(B :: C :: bc :: D :: bd :: nil) = 3) by (apply LBCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcDbdMtmp : rk(B :: C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HBCbcDbdeq HBCbcDbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: bc :: D :: bd :: nil) (B :: C :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: bc :: D :: bd :: nil) (B :: C :: bc :: D :: bd :: nil) 3 3 HBCbcDbdMtmp Hcomp Hincl);apply HT.
}
try clear HBCbcDbdM1. try clear HBCbcDbdM2. try clear HBCbcDbdM3. try clear HBCbcDbdm4. try clear HBCbcDbdm3. try clear HBCbcDbdm2. try clear HBCbcDbdm1. 

assert(HCbcDbdM : rk(C :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCbcDbdm : rk(C :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HCbcDbdeq HCbcDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApbcDbdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDbdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApDpbd *)
(* dans constructLemma(), requis par LBApDDpbd *)
(* dans constructLemma(), requis par LOoBApDDpbd *)
(* dans la couche 0 *)
Lemma LOoABApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpbdm4 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApDDpbdM : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApDDpbdm : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApDDpbd requis par la preuve de (?)OoBApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoBApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApDDpbd requis par la preuve de (?)OoBApDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApDDpbdm3 : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpbdmtmp;try rewrite HT2 in HOoABApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApDDpbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApDDpbdm4 : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoABApDDpbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApDDpbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpbdmtmp;try rewrite HT2 in HOoABApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApDDpbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


assert(HOoBApDDpbdM : rk(Oo :: B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApDDpbdm : rk(Oo :: B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApDDpbdeq HOoBApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApDDpbdm2 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpbdmtmp;try rewrite HT2 in HOoABApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: D :: Dp :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApDDpbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap :: Dp ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HBApDDpbdm3 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoABApDDpbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApDDpbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm4).
	try assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hincl : incl (Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Dp :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpbdmtmp;try rewrite HT2 in HOoABApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil) (Ap :: Dp :: nil) 4 2 3 HOoABApDDpbdmtmp HApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApDDpbdm4 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoBApDDpbdeq : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoBApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApDDpbdmtmp : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApDDpbdeq HOoBApDDpbdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApDDpbdmtmp;try rewrite HT2 in HOoBApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApDDpbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HBApDDpbdM : rk(B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApDDpbdm : rk(B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBApDDpbdeq HBApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpbd requis par la preuve de (?)ApDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDpbd requis par la preuve de (?)ApDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpbdm2 : rk(Ap :: Dp :: bd :: nil) >= 2).
{
	try assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: bd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApDpbdm3 : rk(Ap :: Dp :: bd :: nil) >= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBApDDpbdeq : rk(B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LBApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApDDpbdmtmp : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HBApDDpbdeq HBApDDpbdm4).
	try assert(Hbdeq : rk(bd :: nil) = 1) by (apply Lbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: D :: Dp :: bd :: nil) (B :: D :: bd :: Ap :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: Dp :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApDDpbdmtmp;try rewrite HT2 in HBApDDpbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: Dp :: bd :: nil) (bd :: nil) 4 1 2 HBApDDpbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}


assert(HApDpbdM : rk(Ap :: Dp :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApDpbdeq HApDpbdM3).
assert(HApDpbdm : rk(Ap :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApDpbdeq HApDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApabDpbd *)
(* dans constructLemma(), requis par LApBpabDpbd *)
(* dans constructLemma(), requis par LOoBApBpabDpbd *)
(* dans la couche 0 *)
Lemma LOoABApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm4 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoABDpeq : rk(Oo :: A :: B :: Dp :: nil) = 4) by (apply LOoABDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDpmtmp : rk(Oo :: A :: B :: Dp :: nil) >= 4) by (solve_hyps_min HOoABDpeq HOoABDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Dp :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Dp :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 4 4 HOoABDpmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApBpabDpbdM : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpabDpbdm : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApBpabDpbdeq HOoABApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpabDpbd requis par la preuve de (?)OoBApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoBApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpabDpbd requis par la preuve de (?)OoBApBpabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpabDpbdm3 : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabDpbdmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApBpabDpbdeq HOoABApBpabDpbdm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDpbdmtmp;try rewrite HT2 in HOoABApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpabDpbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApBpabDpbdm4 : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoABApBpabDpbdeq : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) = 4) by (apply LOoABApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApBpabDpbdmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApBpabDpbdeq HOoABApBpabDpbdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDpbdmtmp;try rewrite HT2 in HOoABApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApBpabDpbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}
try clear HOoABApBpabDpbdM1. try clear HOoABApBpabDpbdM2. try clear HOoABApBpabDpbdM3. try clear HOoABApBpabDpbdm4. try clear HOoABApBpabDpbdm3. try clear HOoABApBpabDpbdm2. try clear HOoABApBpabDpbdm1. 

assert(HOoBApBpabDpbdM : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpabDpbdm : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApBpabDpbdeq HOoBApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoBApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpabDpbd requis par la preuve de (?)OoBApBpabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpabDpbdm3 : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabDpbdmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApBpabDpbdeq HOoABApBpabDpbdm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDpbdmtmp;try rewrite HT2 in HOoABApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpabDpbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApBpabDpbdM1. try clear HOoABApBpabDpbdM2. try clear HOoABApBpabDpbdM3. try clear HOoABApBpabDpbdm4. try clear HOoABApBpabDpbdm3. try clear HOoABApBpabDpbdm2. try clear HOoABApBpabDpbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HApBpabDpbdm2 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBApBpabDpbdmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoBApBpabDpbdeq HOoBApBpabDpbdm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: B :: Bp :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: B :: Bp :: nil) ++ (Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabDpbdmtmp;try rewrite HT2 in HOoBApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) (Bp :: nil) 3 1 2 HOoBApBpabDpbdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApBpabDpbdM3 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) <= 3).
{
	try assert(HApBpabeq : rk(Ap :: Bp :: ab :: nil) = 2) by (apply LApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	try assert(HBpDpbdeq : rk(Bp :: Dp :: bd :: nil) = 2) by (apply LBpDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: Bp :: Dp :: bd :: nil) ((Ap :: Bp :: ab :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (Bp :: Dp :: bd :: nil) (Bp :: nil) 2 2 1 HApBpabMtmp HBpDpbdMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Bp :: Dp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HApBpabDpbdm3 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	try assert(HOoBApBpabDpbdeq : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) = 4) by (apply LOoBApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApBpabDpbdmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApBpabDpbdeq HOoBApBpabDpbdm4).
	try assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hincl : incl (Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: B :: Bp :: Dp :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabDpbdmtmp;try rewrite HT2 in HOoBApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) (Bp :: Dp :: nil) 4 2 3 HOoBApBpabDpbdmtmp HBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}
try clear HOoBApBpabDpbdM1. try clear HOoBApBpabDpbdM2. try clear HOoBApBpabDpbdM3. try clear HOoBApBpabDpbdm4. try clear HOoBApBpabDpbdm3. try clear HOoBApBpabDpbdm2. try clear HOoBApBpabDpbdm1. 

assert(HApBpabDpbdM : rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpabDpbdm : rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApBpabDpbdeq HApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApabDDpbdm3 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApabDDpbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApabDDpbdm4 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApabDDpbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDDpbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDDpbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApabDDpbdm2 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApabDDpbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApabDDpbdM1. try clear HOoABApabDDpbdM2. try clear HOoABApabDDpbdM3. try clear HOoABApabDDpbdm4. try clear HOoABApabDDpbdm3. try clear HOoABApabDDpbdm2. try clear HOoABApabDDpbdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpbdm3 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpbdeq HABApabDDpbdm3).
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpbdmtmp;try rewrite HT2 in HABApabDDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABApabDDpbdM1. try clear HABApabDDpbdM2. try clear HABApabDDpbdM3. try clear HABApabDDpbdm4. try clear HABApabDDpbdm3. try clear HABApabDDpbdm2. try clear HABApabDDpbdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApabDDpbdm4 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBApabDDpbdmtmp : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApabDDpbdeq HOoBApabDDpbdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApabDDpbdmtmp;try rewrite HT2 in HOoBApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApabDDpbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}
try clear HOoBApabDDpbdM1. try clear HOoBApabDDpbdM2. try clear HOoBApabDDpbdM3. try clear HOoBApabDDpbdm4. try clear HOoBApabDDpbdm3. try clear HOoBApabDDpbdm2. try clear HOoBApabDDpbdm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDpbd requis par la preuve de (?)OoABApabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDpbd requis par la preuve de (?)OoABApabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDpbdm3 : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDpbdeq HOoABApabDpbdm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDpbdmtmp;try rewrite HT2 in HOoABApabDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDpbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApabDpbdM1. try clear HOoABApabDpbdM2. try clear HOoABApabDpbdM3. try clear HOoABApabDpbdm4. try clear HOoABApabDpbdm3. try clear HOoABApabDpbdm2. try clear HOoABApabDpbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDpbdm2 : rk(Ap :: ab :: Dp :: bd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HABApabDpbdeq HABApabDpbdm3).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: bd :: nil) (A :: B :: ab :: Ap :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpbdmtmp;try rewrite HT2 in HABApabDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: Dp :: bd :: nil) (ab :: nil) 3 1 2 HABApabDpbdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}
try clear HABApabDpbdM1. try clear HABApabDpbdM2. try clear HABApabDpbdM3. try clear HABApabDpbdm4. try clear HABApabDpbdm3. try clear HABApabDpbdm2. try clear HABApabDpbdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApabDpbdm3 : rk(Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApabDDpbdmtmp : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HBApabDDpbdeq HBApabDDpbdm4).
	try assert(Hbdeq : rk(bd :: nil) = 1) by (apply Lbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: D :: bd :: Ap :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: ab :: Dp :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApabDDpbdmtmp;try rewrite HT2 in HBApabDDpbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: ab :: Dp :: bd :: nil) (bd :: nil) 4 1 2 HBApabDDpbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}
try clear HBApabDDpbdM1. try clear HBApabDDpbdM2. try clear HBApabDDpbdM3. try clear HBApabDDpbdm4. try clear HBApabDDpbdm3. try clear HBApabDDpbdm2. try clear HBApabDDpbdm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApabDpbdM3 : rk(Ap :: ab :: Dp :: bd :: nil) <= 3).
{
	try assert(HApBpabDpbdeq : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) = 3) by (apply LApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApBpabDpbdMtmp : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) <= 3) by (solve_hyps_max HApBpabDpbdeq HApBpabDpbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HApBpabDpbdMtmp Hcomp Hincl);apply HT.
}


assert(HApabDpbdM : rk(Ap :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDpbdm : rk(Ap :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApabDpbdeq HApabDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpDDpbd *)
(* dans la couche 0 *)
Lemma LOoABCApBpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbd requis par la preuve de (?)OoABCApBpDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpDDpbdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpbdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpbdeq HOoABCApBpDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpDDpbd requis par la preuve de (?)OoBCApBpDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpDDpbdm4 : rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpDDpbdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) = 4) by (apply LOoABCApBpDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdeq HOoABCApBpDDpbdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdmtmp;try rewrite HT2 in HOoABCApBpDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpDDpbdmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApBpDDpbdM1. try clear HOoABCApBpDDpbdM2. try clear HOoABCApBpDDpbdM3. try clear HOoABCApBpDDpbdm4. try clear HOoABCApBpDDpbdm3. try clear HOoABCApBpDDpbdm2. try clear HOoABCApBpDDpbdm1. 

assert(HOoBCApBpDDpbdM : rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpDDpbdm : rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCApBpDDpbdeq HOoBCApBpDDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApabDDpbd *)
(* dans constructLemma(), requis par LOoBApabDDpbd *)
(* dans la couche 0 *)
Lemma LOoABApabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApabDDpbdM : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApabDDpbdm : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApabDDpbdm3 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApabDDpbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApabDDpbdm4 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoABApabDDpbdeq : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApabDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApabDDpbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


assert(HOoBApabDDpbdM : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApabDDpbdm : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApabDDpbdeq HOoBApabDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDDpbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDDpbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApabDDpbdm2 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApabDDpbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpbdm3 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpbdeq HABApabDDpbdm3).
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpbdmtmp;try rewrite HT2 in HABApabDDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABApabDDpbdM1. try clear HABApabDDpbdM2. try clear HABApabDDpbdM3. try clear HABApabDDpbdm4. try clear HABApabDDpbdm3. try clear HABApabDDpbdm2. try clear HABApabDDpbdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApabDDpbdm4 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoBApabDDpbdeq : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) = 4) by (apply LOoBApabDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApabDDpbdmtmp : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApabDDpbdeq HOoBApabDDpbdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApabDDpbdmtmp;try rewrite HT2 in HOoBApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApabDDpbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HBApabDDpbdM : rk(B :: Ap :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApabDDpbdm : rk(B :: Ap :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBApabDDpbdeq HBApabDDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LabDadbd *)
(* dans constructLemma(), requis par LAabDadbd *)
(* dans la couche 0 *)
Lemma LADadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCDadbd requis par la preuve de (?)ADadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDadbd requis par la preuve de (?)OoABCDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCDadbdm4 : rk(Oo :: A :: B :: C :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: D ::   de rang : 4 et 4 *)
assert(HADadbdm2 : rk(A :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HOoABCDeq : rk(Oo :: A :: B :: C :: D :: nil) = 4) by (apply LOoABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCDMtmp : rk(Oo :: A :: B :: C :: D :: nil) <= 4) by (solve_hyps_max HOoABCDeq HOoABCDM4).
	assert(HOoABCDadbdmtmp : rk(Oo :: A :: B :: C :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCDadbdeq HOoABCDadbdm4).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (Oo :: A :: B :: C :: D :: nil) (A :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: D :: ad :: bd :: nil) (Oo :: A :: B :: C :: D :: A :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: D :: A :: D :: ad :: bd :: nil) ((Oo :: A :: B :: C :: D :: nil) ++ (A :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCDadbdmtmp;try rewrite HT2 in HOoABCDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: D :: nil) (A :: D :: ad :: bd :: nil) (A :: D :: nil) 4 2 4 HOoABCDadbdmtmp HADmtmp HOoABCDMtmp Hincl); apply HT.
}
try clear HOoABCDadbdM1. try clear HOoABCDadbdM2. try clear HOoABCDadbdM3. try clear HOoABCDadbdm4. try clear HOoABCDadbdm3. try clear HOoABCDadbdm2. try clear HOoABCDadbdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HADadbdM3 : rk(A :: D :: ad :: bd :: nil) <= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(Hbdeq : rk(bd :: nil) = 1) by (apply Lbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HbdMtmp : rk(bd :: nil) <= 1) by (solve_hyps_max Hbdeq HbdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D :: ad :: nil) (bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: ad :: bd :: nil) (A :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (bd :: nil) (nil) 2 1 0 HADadMtmp HbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadbdm3 : rk(A :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: bd :: nil) (A :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: bd :: nil) (A :: D :: ad :: bd :: nil) 3 3 HADbdmtmp Hcomp Hincl);apply HT.
}


assert(HADadbdM : rk(A :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HADadbdm : rk(A :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HADadbdeq HADadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDadbdM1. try clear HOoABCApabDadbdM2. try clear HOoABCApabDadbdM3. try clear HOoABCApabDadbdm4. try clear HOoABCApabDadbdm3. try clear HOoABCApabDadbdm2. try clear HOoABCApabDadbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdmtmp;try rewrite HT2 in HABCApabDadbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (nil) 4 0 2 HABCApabDadbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabDadbdM1. try clear HABCApabDadbdM2. try clear HABCApabDadbdM3. try clear HABCApabDadbdm4. try clear HABCApabDadbdm3. try clear HABCApabDadbdm2. try clear HABCApabDadbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDadbdm2 : rk(A :: ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDadbdm3 : rk(A :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil) 3 3 HADbdmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAabDadbdM3 : rk(A :: ab :: D :: ad :: bd :: nil) <= 3).
{
	try assert(HAabDbdeq : rk(A :: ab :: D :: bd :: nil) = 3) by (apply LAabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabDbdMtmp : rk(A :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HAabDbdeq HAabDbdM3).
	try assert(HADadbdeq : rk(A :: D :: ad :: bd :: nil) = 3) by (apply LADadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadbdMtmp : rk(A :: D :: ad :: bd :: nil) <= 3) by (solve_hyps_max HADadbdeq HADadbdM3).
	try assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hincl : incl (A :: D :: bd :: nil) (list_inter (A :: ab :: D :: bd :: nil) (A :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: D :: bd :: A :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: D :: bd :: A :: D :: ad :: bd :: nil) ((A :: ab :: D :: bd :: nil) ++ (A :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: ab :: D :: bd :: nil) (A :: D :: ad :: bd :: nil) (A :: D :: bd :: nil) 3 3 3 HAabDbdMtmp HADadbdMtmp HADbdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HAabDadbdM : rk(A :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabDadbdm : rk(A :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HAabDadbdeq HAabDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abDadbd requis par la preuve de (?)abDadbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BabDadbd requis par la preuve de (?)abDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDadbdM1. try clear HOoABCApabDadbdM2. try clear HOoABCApabDadbdM3. try clear HOoABCApabDadbdm4. try clear HOoABCApabDadbdm3. try clear HOoABCApabDadbdm2. try clear HOoABCApabDadbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdmtmp;try rewrite HT2 in HABCApabDadbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (nil) 4 0 2 HABCApabDadbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabDadbdM1. try clear HABCApabDadbdM2. try clear HABCApabDadbdM3. try clear HABCApabDadbdm4. try clear HABCApabDadbdm3. try clear HABCApabDadbdm2. try clear HABCApabDadbdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadbdm2 : rk(B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: nil) 2 2 2 HABabDadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadbdm3 : rk(B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABabDadbdeq HABabDadbdm3).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil) (D :: ad :: nil) 3 2 2 HABabDadbdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBabDadbdM3 : rk(B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	try assert(HBabDadeq : rk(B :: ab :: D :: ad :: nil) = 3) by (apply LBabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabDadMtmp : rk(B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HBabDadeq HBabDadM3).
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: D :: ad :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: D :: ad :: B :: D :: bd :: nil) ((B :: ab :: D :: ad :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil) (B :: D :: nil) 3 2 2 HBabDadMtmp HBDbdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abDadbd requis par la preuve de (?)abDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDadbd requis par la preuve de (?)abDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDadbdm2 : rk(A :: ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABabDadbdM1. try clear HABabDadbdM2. try clear HABabDadbdM3. try clear HABabDadbdm4. try clear HABabDadbdm3. try clear HABabDadbdm2. try clear HABabDadbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abDadbd requis par la preuve de (?)abDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HabDadbdm2 : rk(ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAabDadbdmtmp : rk(A :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HAabDadbdeq HAabDadbdm2).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: ab :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAabDadbdmtmp;try rewrite HT2 in HAabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (ab :: D :: ad :: bd :: nil) (D :: ad :: nil) 2 2 2 HAabDadbdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HabDadbdm3 : rk(ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBabDadbdmtmp : rk(B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HBabDadbdeq HBabDadbdm3).
	try assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: D :: bd :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: ab :: D :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBabDadbdmtmp;try rewrite HT2 in HBabDadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (ab :: D :: ad :: bd :: nil) (D :: bd :: nil) 3 2 2 HBabDadbdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HabDadbdM3 : rk(ab :: D :: ad :: bd :: nil) <= 3).
{
	try assert(HAabDadbdeq : rk(A :: ab :: D :: ad :: bd :: nil) = 3) by (apply LAabDadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabDadbdMtmp : rk(A :: ab :: D :: ad :: bd :: nil) <= 3) by (solve_hyps_max HAabDadbdeq HAabDadbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (ab :: D :: ad :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (ab :: D :: ad :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil) 3 3 HAabDadbdMtmp Hcomp Hincl);apply HT.
}


assert(HabDadbdM : rk(ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HabDadbdm : rk(ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HabDadbdeq HabDadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LApabDpadbd *)
(* dans constructLemma(), requis par LApDpadbd *)
(* dans constructLemma(), requis par LBApDDpadbd *)
(* dans constructLemma(), requis par LOoBApDDpadbd *)
(* dans la couche 0 *)
Lemma LOoABApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadbdm4 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}


assert(HOoABApDDpadbdM : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApDDpadbdm : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApDDpadbd requis par la preuve de (?)OoBApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoBApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApDDpadbd requis par la preuve de (?)OoBApDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApDDpadbdm3 : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadbdmtmp;try rewrite HT2 in HOoABApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApDDpadbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApDDpadbdm4 : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoABApDDpadbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadbdmtmp;try rewrite HT2 in HOoABApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApDDpadbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


assert(HOoBApDDpadbdM : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApDDpadbdm : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApDDpadbdeq HOoBApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApDDpadbdm2 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadbdmtmp;try rewrite HT2 in HOoABApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApDDpadbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap :: Dp ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HBApDDpadbdm3 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoABApDDpadbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm4).
	try assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hincl : incl (Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadbdmtmp;try rewrite HT2 in HOoABApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) (Ap :: Dp :: nil) 4 2 3 HOoABApDDpadbdmtmp HApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApDDpadbdm4 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoBApDDpadbdeq : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoBApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApDDpadbdmtmp : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBApDDpadbdeq HOoBApDDpadbdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApDDpadbdmtmp;try rewrite HT2 in HOoBApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApDDpadbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HBApDDpadbdM : rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApDDpadbdm : rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HBApDDpadbdeq HBApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpadbdm2 : rk(Ap :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: ad :: bd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApDpadbdM3 : rk(Ap :: Dp :: ad :: bd :: nil) <= 3).
{
	try assert(HApDpadeq : rk(Ap :: Dp :: ad :: nil) = 2) by (apply LApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	try assert(Hbdeq : rk(bd :: nil) = 1) by (apply Lbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HbdMtmp : rk(bd :: nil) <= 1) by (solve_hyps_max Hbdeq HbdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Dp :: ad :: nil) (bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Dp :: ad :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Dp :: ad :: bd :: nil) ((Ap :: Dp :: ad :: nil) ++ (bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Dp :: ad :: nil) (bd :: nil) (nil) 2 1 0 HApDpadMtmp HbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApDpadbdm3 : rk(Ap :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBApDDpadbdeq : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LBApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApDDpadbdmtmp : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HBApDDpadbdeq HBApDDpadbdm4).
	try assert(Hbdeq : rk(bd :: nil) = 1) by (apply Lbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: D :: Dp :: ad :: bd :: nil) (B :: D :: bd :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: Dp :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApDDpadbdmtmp;try rewrite HT2 in HBApDDpadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil) (bd :: nil) 4 1 2 HBApDDpadbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}


assert(HApDpadbdM : rk(Ap :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDpadbdm : rk(Ap :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HApDpadbdeq HApDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: Dp :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}
try clear HOoABDM1. try clear HOoABDM2. try clear HOoABDM3. try clear HOoABDm4. try clear HOoABDm3. try clear HOoABDm2. try clear HOoABDm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApabDDpadbdm3 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApabDDpadbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApabDDpadbdm4 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApabDDpadbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDDpadbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDDpadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApabDDpadbdm2 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApabDDpadbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpadbdm3 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpadbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm3).
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpadbdmtmp;try rewrite HT2 in HABApabDDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApabDDpadbdm4 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBApabDDpadbdmtmp : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBApabDDpadbdeq HOoBApabDDpadbdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApabDDpadbdmtmp;try rewrite HT2 in HOoBApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApabDDpadbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}
try clear HOoBApabDDpadbdM1. try clear HOoBApabDDpadbdM2. try clear HOoBApabDDpadbdM3. try clear HOoBApabDDpadbdm4. try clear HOoBApabDDpadbdm3. try clear HOoBApabDDpadbdm2. try clear HOoBApabDDpadbdm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDpadbd requis par la preuve de (?)OoABApabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDpadbd requis par la preuve de (?)OoABApabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDpadbdm3 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDpadbdeq HOoABApabDpadbdm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDpadbdmtmp;try rewrite HT2 in HOoABApabDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDpadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApabDpadbdM1. try clear HOoABApabDpadbdM2. try clear HOoABApabDpadbdM3. try clear HOoABApabDpadbdm4. try clear HOoABApabDpadbdm3. try clear HOoABApabDpadbdm2. try clear HOoABApabDpadbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDpadbdm2 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpadbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDpadbdeq HABApabDpadbdm3).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: B :: ab :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpadbdmtmp;try rewrite HT2 in HABApabDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (ab :: nil) 3 1 2 HABApabDpadbdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}
try clear HABApabDpadbdM1. try clear HABApabDpadbdM2. try clear HABApabDpadbdM3. try clear HABApabDpadbdm4. try clear HABApabDpadbdm3. try clear HABApabDpadbdm2. try clear HABApabDpadbdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApabDpadbdm3 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApabDDpadbdmtmp : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HBApabDDpadbdeq HBApabDDpadbdm4).
	try assert(Hbdeq : rk(bd :: nil) = 1) by (apply Lbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: D :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApabDDpadbdmtmp;try rewrite HT2 in HBApabDDpadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (bd :: nil) 4 1 2 HBApabDDpadbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApabDpadbdM3 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) <= 3).
{
	try assert(HApabDpbdeq : rk(Ap :: ab :: Dp :: bd :: nil) = 3) by (apply LApabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApabDpbdMtmp : rk(Ap :: ab :: Dp :: bd :: nil) <= 3) by (solve_hyps_max HApabDpbdeq HApabDpbdM3).
	try assert(HApDpadbdeq : rk(Ap :: Dp :: ad :: bd :: nil) = 3) by (apply LApDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpadbdMtmp : rk(Ap :: Dp :: ad :: bd :: nil) <= 3) by (solve_hyps_max HApDpadbdeq HApDpadbdM3).
	try assert(HApDpbdeq : rk(Ap :: Dp :: bd :: nil) = 3) by (apply LApDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpbdmtmp : rk(Ap :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HApDpbdeq HApDpbdm3).
	assert(Hincl : incl (Ap :: Dp :: bd :: nil) (list_inter (Ap :: ab :: Dp :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ab :: Dp :: ad :: bd :: nil) (Ap :: ab :: Dp :: bd :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ab :: Dp :: bd :: Ap :: Dp :: ad :: bd :: nil) ((Ap :: ab :: Dp :: bd :: nil) ++ (Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: ab :: Dp :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil) (Ap :: Dp :: bd :: nil) 3 3 3 HApabDpbdMtmp HApDpadbdMtmp HApDpbdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HApabDpadbdM : rk(Ap :: ab :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDpadbdm : rk(Ap :: ab :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HApabDpadbdeq HApabDpadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LApabDDpadbd *)
(* dans constructLemma(), requis par LBApabDDpadbd *)
(* dans constructLemma(), requis par LOoBApabDDpadbd *)
(* dans la couche 0 *)
Lemma LOoABApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABDeq : rk(Oo :: A :: B :: D :: nil) = 4) by (apply LOoABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}
try clear HOoABDM1. try clear HOoABDM2. try clear HOoABDM3. try clear HOoABDm4. try clear HOoABDm3. try clear HOoABDm2. try clear HOoABDm1. 

assert(HOoABApabDDpadbdM : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApabDDpadbdm : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApabDDpadbdm3 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApabDDpadbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApabDDpadbdm4 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoABApabDDpadbdeq : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABApabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApabDDpadbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


assert(HOoBApabDDpadbdM : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApabDDpadbdm : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApabDDpadbdeq HOoBApabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDDpadbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDDpadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApabDDpadbdm2 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApabDDpadbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpadbdm3 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpadbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm3).
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpadbdmtmp;try rewrite HT2 in HABApabDDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApabDDpadbdm4 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoBApabDDpadbdeq : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoBApabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApabDDpadbdmtmp : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBApabDDpadbdeq HOoBApabDDpadbdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApabDDpadbdmtmp;try rewrite HT2 in HOoBApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApabDDpadbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HBApabDDpadbdM : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApabDDpadbdm : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HBApabDDpadbdeq HBApabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApabDDpadbd requis par la preuve de (?)ApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApabDDpadbd requis par la preuve de (?)ApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApabDDpadbd requis par la preuve de (?)OoApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApabDDpadbd requis par la preuve de (?)OoApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApabDDpadbdm2 : rk(Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApabDDpadbdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApabDDpadbdm3 : rk(Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoApabeq : rk(Oo :: Ap :: ab :: nil) = 3) by (apply LOoApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApabmtmp : rk(Oo :: Ap :: ab :: nil) >= 3) by (solve_hyps_min HOoApabeq HOoApabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: ab :: nil) (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: ab :: nil) (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoApabmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApabDDpadbd requis par la preuve de (?)ApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDDpadbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDDpadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDDpadbd requis par la preuve de (?)ApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDDpadbdm2 : rk(Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpadbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm3).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: ab :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpadbdmtmp;try rewrite HT2 in HABApabDDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil) (ab :: nil) 3 1 2 HABApabDDpadbdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HApabDDpadbdm3 : rk(Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoApabDDpadbdmtmp : rk(Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoApabDDpadbdeq HOoApabDDpadbdm3).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: D :: Dp :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApabDDpadbdmtmp;try rewrite HT2 in HOoApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil) (D :: Dp :: nil) 3 2 2 HOoApabDDpadbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}
try clear HOoApabDDpadbdM1. try clear HOoApabDDpadbdM2. try clear HOoApabDDpadbdM3. try clear HOoApabDDpadbdm4. try clear HOoApabDDpadbdm3. try clear HOoApabDDpadbdm2. try clear HOoApabDDpadbdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApabDDpadbdm4 : rk(Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBApabDDpadbdeq : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LBApabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApabDDpadbdmtmp : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HBApabDDpadbdeq HBApabDDpadbdm4).
	try assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: D :: bd :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApabDDpadbdmtmp;try rewrite HT2 in HBApabDDpadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil) (D :: bd :: nil) 4 2 2 HBApabDDpadbdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}


assert(HApabDDpadbdM : rk(Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDDpadbdm : rk(Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HApabDDpadbdeq HApabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ad :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abadbd requis par la preuve de (?)abadbd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BabDadbd requis par la preuve de (?)abadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDadbdM1. try clear HOoABCApabDadbdM2. try clear HOoABCApabDadbdM3. try clear HOoABCApabDadbdm4. try clear HOoABCApabDadbdm3. try clear HOoABCApabDadbdm2. try clear HOoABCApabDadbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdmtmp;try rewrite HT2 in HABCApabDadbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (nil) 4 0 2 HABCApabDadbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabDadbdM1. try clear HABCApabDadbdM2. try clear HABCApabDadbdM3. try clear HABCApabDadbdm4. try clear HABCApabDadbdm3. try clear HABCApabDadbdm2. try clear HABCApabDadbdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadbdm2 : rk(B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: nil) 2 2 2 HABabDadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadbdm3 : rk(B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABabDadbdeq HABabDadbdm3).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil) (D :: ad :: nil) 3 2 2 HABabDadbdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBabDadbdM3 : rk(B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	try assert(HBabDadeq : rk(B :: ab :: D :: ad :: nil) = 3) by (apply LBabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabDadMtmp : rk(B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HBabDadeq HBabDadM3).
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: D :: ad :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: D :: ad :: B :: D :: bd :: nil) ((B :: ab :: D :: ad :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil) (B :: D :: nil) 3 2 2 HBabDadMtmp HBDbdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour abadbd requis par la preuve de (?)abadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(Habadbdm2 : rk(ab :: ad :: bd :: nil) >= 2).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBabDadbdmtmp : rk(B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HBabDadbdeq HBabDadbdm3).
	try assert(Hbdeq : rk(bd :: nil) = 1) by (apply Lbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (ab :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: D :: bd :: ab :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: ab :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (ab :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBabDadbdmtmp;try rewrite HT2 in HBabDadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (ab :: ad :: bd :: nil) (bd :: nil) 3 1 2 HBabDadbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}


(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HabadbdM2 : rk(ab :: ad :: bd :: nil) <= 2).
{
	try assert(HabDadbdeq : rk(ab :: D :: ad :: bd :: nil) = 3) by (apply LabDadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HabDadbdMtmp : rk(ab :: D :: ad :: bd :: nil) <= 3) by (solve_hyps_max HabDadbdeq HabDadbdM3).
	try assert(HApabDpadbdeq : rk(Ap :: ab :: Dp :: ad :: bd :: nil) = 3) by (apply LApabDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApabDpadbdMtmp : rk(Ap :: ab :: Dp :: ad :: bd :: nil) <= 3) by (solve_hyps_max HApabDpadbdeq HApabDpadbdM3).
	try assert(HApabDDpadbdeq : rk(Ap :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LApabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApabDDpadbdmtmp : rk(Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HApabDDpadbdeq HApabDDpadbdm4).
	assert(Hincl : incl (ab :: ad :: bd :: nil) (list_inter (ab :: D :: ad :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ab :: D :: Dp :: ad :: bd :: nil) (ab :: D :: ad :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: D :: ad :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil) ((ab :: D :: ad :: bd :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApabDDpadbdmtmp;try rewrite HT2 in HApabDDpadbdmtmp.
	assert(HT := rule_3 (ab :: D :: ad :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (ab :: ad :: bd :: nil) 3 3 4 HabDadbdMtmp HApabDpadbdMtmp HApabDDpadbdmtmp Hincl);apply HT.
}


assert(HabadbdM : rk(ab :: ad :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Habadbdeq HabadbdM3).
assert(Habadbdm : rk(ab :: ad :: bd ::  nil) >= 1) by (solve_hyps_min Habadbdeq Habadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDadbd requis par la preuve de (?)OoABCDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCDadbdm4 : rk(Oo :: A :: B :: C :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCDadbdM : rk(Oo :: A :: B :: C :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDadbdm : rk(Oo :: A :: B :: C :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCDadbdeq HOoABCDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDadbdM1. try clear HOoABCApabDadbdM2. try clear HOoABCApabDadbdM3. try clear HOoABCApabDadbdm4. try clear HOoABCApabDadbdm3. try clear HOoABCApabDadbdm2. try clear HOoABCApabDadbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdmtmp;try rewrite HT2 in HABCApabDadbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (nil) 4 0 2 HABCApabDadbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabDadbdM1. try clear HABCApabDadbdM2. try clear HABCApabDadbdM3. try clear HABCApabDadbdm4. try clear HABCApabDadbdm3. try clear HABCApabDadbdm2. try clear HABCApabDadbdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadbdm2 : rk(B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: nil) 2 2 2 HABabDadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadbdm3 : rk(B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABabDadbdeq HABabDadbdm3).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil) (D :: ad :: nil) 3 2 2 HABabDadbdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBabDadbdM3 : rk(B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	try assert(HBabDadeq : rk(B :: ab :: D :: ad :: nil) = 3) by (apply LBabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabDadMtmp : rk(B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HBabDadeq HBabDadM3).
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: D :: ad :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: D :: ad :: B :: D :: bd :: nil) ((B :: ab :: D :: ad :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil) (B :: D :: nil) 3 2 2 HBabDadMtmp HBDbdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HBabDadbdM : rk(B :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBabDadbdm : rk(B :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HBabDadbdeq HBabDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDadbdM1. try clear HOoABCApabDadbdM2. try clear HOoABCApabDadbdM3. try clear HOoABCApabDadbdm4. try clear HOoABCApabDadbdm3. try clear HOoABCApabDadbdm2. try clear HOoABCApabDadbdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdmtmp;try rewrite HT2 in HABCApabDadbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (nil) 4 0 2 HABCApabDadbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HABCApabDadbdM1. try clear HABCApabDadbdM2. try clear HABCApabDadbdM3. try clear HABCApabDadbdm4. try clear HABCApabDadbdm3. try clear HABCApabDadbdm2. try clear HABCApabDadbdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HABabDadbdM : rk(A :: B :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDadbdm : rk(A :: B :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HABabDadbdeq HABabDadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabDadbd *)
(* dans la couche 0 *)
Lemma LOoABCApabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApabDadbdM : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabDadbdm : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApabDadbdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) = 4) by (apply LOoABCApabDadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApabDadbdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) = 4) by (apply LOoABCApabDadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	try assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabDadbdM1. try clear HOoABCApabDadbdM2. try clear HOoABCApabDadbdM3. try clear HOoABCApabDadbdm4. try clear HOoABCApabDadbdm3. try clear HOoABCApabDadbdm2. try clear HOoABCApabDadbdm1. 

assert(HABCApabDadbdM : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabDadbdm : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(cd ::  nil) = 1.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HcdM : rk(cd ::  nil) <= 1) (* dim : 3 *) by (solve_hyps_max Hcdeq HcdM1).
assert(Hcdm : rk(cd ::  nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDcd *)
(* dans constructLemma(), requis par LCpDDpcd *)
(* dans constructLemma(), requis par LOoCpDDpcd *)
(* dans la couche 0 *)
Lemma LCpDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HCpDpcdM : rk(Cp :: Dp :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCpDpcdeq HCpDpcdM3).
assert(HCpDpcdm : rk(Cp :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCpDpcdeq HCpDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Cp :: D :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCpDDpcd requis par la preuve de (?)OoCpDDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCpDDpcd requis par la preuve de (?)OoCpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCpDDpcd requis par la preuve de (?)OoCpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCpDDpcdm2 : rk(Oo :: Cp :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Cp :: nil) (Oo :: Cp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Cp :: nil) (Oo :: Cp :: D :: Dp :: cd :: nil) 2 2 HOoCpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCpDDpcdm3 : rk(Oo :: Cp :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoCpDpeq : rk(Oo :: Cp :: Dp :: nil) = 3) by (apply LOoCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCpDpmtmp : rk(Oo :: Cp :: Dp :: nil) >= 3) by (solve_hyps_min HOoCpDpeq HOoCpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Cp :: Dp :: nil) (Oo :: Cp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Cp :: Dp :: nil) (Oo :: Cp :: D :: Dp :: cd :: nil) 3 3 HOoCpDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HOoCpDDpcdM3 : rk(Oo :: Cp :: D :: Dp :: cd :: nil) <= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HCpDpcdeq : rk(Cp :: Dp :: cd :: nil) = 2) by (apply LCpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	try assert(HDpeq : rk(Dp :: nil) = 1) by (apply LDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Cp :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Cp :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (Cp :: Dp :: cd :: nil) (Dp :: nil) 2 2 1 HOoDDpMtmp HCpDpcdMtmp HDpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HOoCpDDpcdM : rk(Oo :: Cp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCpDDpcdm : rk(Oo :: Cp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCpDDpcdeq HOoCpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: D :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HCpDDpcdM3 : rk(Cp :: D :: Dp :: cd :: nil) <= 3).
{
	try assert(HDeq : rk(D :: nil) = 1) by (apply LD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	try assert(HCpDpcdeq : rk(Cp :: Dp :: cd :: nil) = 2) by (apply LCpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: D :: Dp :: cd :: nil) (D :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: Dp :: cd :: nil) ((D :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Cp :: Dp :: cd :: nil) (nil) 1 2 0 HDMtmp HCpDpcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCpDDpcdm2 : rk(Cp :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HCpDpeq : rk(Cp :: Dp :: nil) = 2) by (apply LCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpDpmtmp : rk(Cp :: Dp :: nil) >= 2) by (solve_hyps_min HCpDpeq HCpDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Cp :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Cp :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil) 2 2 HCpDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Cp :: D :: Dp :: cd ::  de rang :  3 et 3 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCpDDpcdm3 : rk(Cp :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoCpDDpcdeq : rk(Oo :: Cp :: D :: Dp :: cd :: nil) = 3) by (apply LOoCpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCpDDpcdmtmp : rk(Oo :: Cp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoCpDDpcdeq HOoCpDDpcdm3).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Cp :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: Cp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Cp :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (Cp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCpDDpcdmtmp;try rewrite HT2 in HOoCpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 3 2 2 HOoCpDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HCpDDpcdM : rk(Cp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCpDDpcdm : rk(Cp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCpDDpcdeq HCpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dcd requis par la preuve de (?)Dcd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HDcdm2 : rk(D :: cd :: nil) >= 2).
{
	try assert(HCpDpcdeq : rk(Cp :: Dp :: cd :: nil) = 2) by (apply LCpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	try assert(HCpDDpcdeq : rk(Cp :: D :: Dp :: cd :: nil) = 3) by (apply LCpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpDDpcdmtmp : rk(Cp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HCpDDpcdeq HCpDDpcdm3).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (D :: cd :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: D :: Dp :: cd :: nil) (D :: cd :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: cd :: Cp :: Dp :: cd :: nil) ((D :: cd :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCpDDpcdmtmp;try rewrite HT2 in HCpDDpcdmtmp.
	assert(HT := rule_2 (D :: cd :: nil) (Cp :: Dp :: cd :: nil) (cd :: nil) 3 1 2 HCpDDpcdmtmp Hcdmtmp HCpDpcdMtmp Hincl);apply HT.
}


assert(HDcdM : rk(D :: cd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDcdeq HDcdM2).
assert(HDcdm : rk(D :: cd ::  nil) >= 1) by (solve_hyps_min HDcdeq HDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LADcd *)
(* dans la couche 0 *)
Lemma LACDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)ACDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour CDcd requis par la preuve de (?)ACDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 5*)
assert(HACDcdM3 : rk(A :: C :: D :: cd :: nil) <= 3).
{
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: cd :: nil) (A :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: cd :: nil) ((A :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (C :: D :: cd :: nil) (nil) 1 2 0 HAMtmp HCDcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACDcdm2 : rk(A :: C :: D :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: D :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDcdmtmp;try rewrite HT2 in HOoABCApDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: cd :: nil) (A :: nil) 4 1 3 HOoABCApDcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDcdm3 : rk(A :: C :: D :: cd :: nil) >= 3).
{
	try assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: D :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}


assert(HACDcdM : rk(A :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACDcdm : rk(A :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HACDcdeq HACDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LADcd *)
(* dans la couche 0 *)
Lemma LCDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: D :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

assert(HCDcdM : rk(C :: D :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HCDcdeq HCDcdM3).
assert(HCDcdm : rk(C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HCDcdeq HCDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADcd requis par la preuve de (?)ADcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCDcd requis par la preuve de (?)ADcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDcd requis par la preuve de (?)OoABCDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCDcdm4 : rk(Oo :: A :: B :: C :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADcd requis par la preuve de (?)ADcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: D :: cd ::  de rang :  4 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: D ::   de rang : 4 et 4 *)
assert(HADcdm2 : rk(A :: D :: cd :: nil) >= 2).
{
	try assert(HOoABCDeq : rk(Oo :: A :: B :: C :: D :: nil) = 4) by (apply LOoABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCDMtmp : rk(Oo :: A :: B :: C :: D :: nil) <= 4) by (solve_hyps_max HOoABCDeq HOoABCDM4).
	assert(HOoABCDcdmtmp : rk(Oo :: A :: B :: C :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCDcdeq HOoABCDcdm4).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (Oo :: A :: B :: C :: D :: nil) (A :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: D :: cd :: nil) (Oo :: A :: B :: C :: D :: A :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: D :: A :: D :: cd :: nil) ((Oo :: A :: B :: C :: D :: nil) ++ (A :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCDcdmtmp;try rewrite HT2 in HOoABCDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: D :: nil) (A :: D :: cd :: nil) (A :: D :: nil) 4 2 4 HOoABCDcdmtmp HADmtmp HOoABCDMtmp Hincl); apply HT.
}
try clear HOoABCDcdM1. try clear HOoABCDcdM2. try clear HOoABCDcdM3. try clear HOoABCDcdm4. try clear HOoABCDcdm3. try clear HOoABCDcdm2. try clear HOoABCDcdm1. 

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HADcdm3 : rk(A :: D :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HACDcdeq : rk(A :: C :: D :: cd :: nil) = 3) by (apply LACDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACDcdmtmp : rk(A :: C :: D :: cd :: nil) >= 3) by (solve_hyps_min HACDcdeq HACDcdm3).
	try assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (A :: D :: cd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: cd :: nil) (A :: D :: cd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: cd :: C :: D :: cd :: nil) ((A :: D :: cd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDcdmtmp;try rewrite HT2 in HACDcdmtmp.
	assert(HT := rule_2 (A :: D :: cd :: nil) (C :: D :: cd :: nil) (D :: cd :: nil) 3 2 2 HACDcdmtmp HDcdmtmp HCDcdMtmp Hincl);apply HT.
}


assert(HADcdM : rk(A :: D :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HADcdeq HADcdM3).
assert(HADcdm : rk(A :: D :: cd ::  nil) >= 1) by (solve_hyps_min HADcdeq HADcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBDcd *)
(* dans la couche 0 *)
Lemma LBCDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)BCDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBCDcdM3 : rk(B :: C :: D :: cd :: nil) <= 3).
{
	try assert(HBeq : rk(B :: nil) = 1) by (apply LB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: cd :: nil) (B :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: D :: cd :: nil) ((B :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (C :: D :: cd :: nil) (nil) 1 2 0 HBMtmp HCDcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCDcdm2 : rk(B :: C :: D :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) (Oo :: A :: Ap :: B :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDcdmtmp;try rewrite HT2 in HOoABCApDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: D :: cd :: nil) (nil) 4 0 2 HOoABCApDcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCDcdm3 : rk(B :: C :: D :: cd :: nil) >= 3).
{
	try assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: D :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}


assert(HBCDcdM : rk(B :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCDcdm : rk(B :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBCDcdeq HBCDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDcd requis par la preuve de (?)BDcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BDcd requis par la preuve de (?)BDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDcdm2 : rk(B :: D :: cd :: nil) >= 2).
{
	try assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: nil) (B :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: nil) (B :: D :: cd :: nil) 2 2 HBDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBDcdm3 : rk(B :: D :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HBCDcdeq : rk(B :: C :: D :: cd :: nil) = 3) by (apply LBCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCDcdmtmp : rk(B :: C :: D :: cd :: nil) >= 3) by (solve_hyps_min HBCDcdeq HBCDcdm3).
	try assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (B :: D :: cd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: cd :: nil) (B :: D :: cd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: cd :: C :: D :: cd :: nil) ((B :: D :: cd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCDcdmtmp;try rewrite HT2 in HBCDcdmtmp.
	assert(HT := rule_2 (B :: D :: cd :: nil) (C :: D :: cd :: nil) (D :: cd :: nil) 3 2 2 HBCDcdmtmp HDcdmtmp HCDcdMtmp Hincl);apply HT.
}


assert(HBDcdM : rk(B :: D :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBDcdeq HBDcdM3).
assert(HBDcdm : rk(B :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBDcdeq HBDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDcd requis par la preuve de (?)OoABCDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCDcdm4 : rk(Oo :: A :: B :: C :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCDcdM : rk(Oo :: A :: B :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDcdm : rk(Oo :: A :: B :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCDcdeq HOoABCDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApDcdM : rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDcdm : rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAacDcd *)
(* dans la couche 0 *)
Lemma LACacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDcdm2 : rk(A :: C :: ac :: D :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDcdmtmp;try rewrite HT2 in HOoABCApacDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDcdM1. try clear HOoABCApacDcdM2. try clear HOoABCApacDcdM3. try clear HOoABCApacDcdm4. try clear HOoABCApacDcdm3. try clear HOoABCApacDcdm2. try clear HOoABCApacDcdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACacDcdM3 : rk(A :: C :: ac :: D :: cd :: nil) <= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: ac :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HACacMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDcdm3 : rk(A :: C :: ac :: D :: cd :: nil) >= 3).
{
	try assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}


assert(HACacDcdM : rk(A :: C :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDcdm : rk(A :: C :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HACacDcdeq HACacDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDcd requis par la preuve de (?)AacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDcdm2 : rk(A :: C :: ac :: D :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDcdmtmp;try rewrite HT2 in HOoABCApacDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDcdM1. try clear HOoABCApacDcdM2. try clear HOoABCApacDcdM3. try clear HOoABCApacDcdm4. try clear HOoABCApacDcdm3. try clear HOoABCApacDcdm2. try clear HOoABCApacDcdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACacDcdM3 : rk(A :: C :: ac :: D :: cd :: nil) <= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: ac :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HACacMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: cd ::  de rang :  2 et 3 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDcdm2 : rk(A :: ac :: D :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDcdmtmp : rk(A :: C :: ac :: D :: cd :: nil) >= 2) by (solve_hyps_min HACacDcdeq HACacDcdm2).
	try assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDcdmtmp;try rewrite HT2 in HACacDcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDcdm3 : rk(A :: ac :: D :: cd :: nil) >= 3).
{
	try assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: cd :: nil) (A :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: cd :: nil) (A :: ac :: D :: cd :: nil) 3 3 HADcdmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDcdM3 : rk(A :: ac :: D :: cd :: nil) <= 3).
{
	try assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: D :: cd :: nil) (A :: C :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ac :: D :: cd :: nil) (A :: C :: ac :: D :: cd :: nil) 3 3 HACacDcdMtmp Hcomp Hincl);apply HT.
}


assert(HAacDcdM : rk(A :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacDcdm : rk(A :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HAacDcdeq HAacDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApacDcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbcDcd *)
(* dans la couche 0 *)
Lemma LBCbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDcdm2 : rk(B :: C :: bc :: D :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDcdmtmp;try rewrite HT2 in HOoABCApbcDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil) (nil) 4 0 2 HOoABCApbcDcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApbcDcdM1. try clear HOoABCApbcDcdM2. try clear HOoABCApbcDcdM3. try clear HOoABCApbcDcdm4. try clear HOoABCApbcDcdm3. try clear HOoABCApbcDcdm2. try clear HOoABCApbcDcdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCbcDcdM3 : rk(B :: C :: bc :: D :: cd :: nil) <= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: bc :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HBCbcMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDcdm3 : rk(B :: C :: bc :: D :: cd :: nil) >= 3).
{
	try assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}


assert(HBCbcDcdM : rk(B :: C :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDcdm : rk(B :: C :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBCbcDcdeq HBCbcDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDcd requis par la preuve de (?)BbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDcdm2 : rk(B :: C :: bc :: D :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDcdmtmp;try rewrite HT2 in HOoABCApbcDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil) (nil) 4 0 2 HOoABCApbcDcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApbcDcdM1. try clear HOoABCApbcDcdM2. try clear HOoABCApbcDcdM3. try clear HOoABCApbcDcdm4. try clear HOoABCApbcDcdm3. try clear HOoABCApbcDcdm2. try clear HOoABCApbcDcdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCbcDcdM3 : rk(B :: C :: bc :: D :: cd :: nil) <= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCeq : rk(C :: nil) = 1) by (apply LC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: bc :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HBCbcMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: cd ::  de rang :  2 et 3 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDcdm2 : rk(B :: bc :: D :: cd :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDcdmtmp : rk(B :: C :: bc :: D :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDcdeq HBCbcDcdm2).
	try assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDcdmtmp;try rewrite HT2 in HBCbcDcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDcdm3 : rk(B :: bc :: D :: cd :: nil) >= 3).
{
	try assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: bc :: D :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDcdM3 : rk(B :: bc :: D :: cd :: nil) <= 3).
{
	try assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: bc :: D :: cd :: nil) (B :: C :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: bc :: D :: cd :: nil) (B :: C :: bc :: D :: cd :: nil) 3 3 HBCbcDcdMtmp Hcomp Hincl);apply HT.
}


assert(HBbcDcdM : rk(B :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBbcDcdm : rk(B :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBbcDcdeq HBbcDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApbcDcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApDpcd *)
(* dans constructLemma(), requis par LCApDDpcd *)
(* dans constructLemma(), requis par LOoCApDDpcd *)
(* dans la couche 0 *)
Lemma LOoACApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApDDpcdm2 : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApDDpcdm3 : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApDDpcdm4 : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoACDeq : rk(Oo :: A :: C :: D :: nil) = 4) by (apply LOoACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApDDpcdM : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApDDpcdm : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApDDpcdeq HOoACApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApDDpcdm3 : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApDDpcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApDDpcdm4 : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoACApDDpcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoACApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACApDDpcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpcdeq HOoACApDDpcdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpcdmtmp;try rewrite HT2 in HOoACApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApDDpcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


assert(HOoCApDDpcdM : rk(Oo :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApDDpcdm : rk(Oo :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApDDpcdeq HOoCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApDDpcdm2 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApDDpcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap :: Dp ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HCApDDpcdm3 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoACApDDpcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoACApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACApDDpcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpcdeq HOoACApDDpcdm4).
	try assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hincl : incl (Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Dp :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpcdmtmp;try rewrite HT2 in HOoACApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (Ap :: Dp :: nil) 4 2 3 HOoACApDDpcdmtmp HApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApDDpcdm4 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoCApDDpcdeq : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoCApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCApDDpcdmtmp : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCApDDpcdeq HOoCApDDpcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApDDpcdmtmp;try rewrite HT2 in HOoCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HCApDDpcdM : rk(C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApDDpcdm : rk(C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCApDDpcdeq HCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpcd requis par la preuve de (?)ApDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDpcd requis par la preuve de (?)ApDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpcdm2 : rk(Ap :: Dp :: cd :: nil) >= 2).
{
	try assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: cd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApDpcdm3 : rk(Ap :: Dp :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCApDDpcdeq : rk(C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LCApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApDDpcdmtmp : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCApDDpcdeq HCApDDpcdm4).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: D :: Dp :: cd :: nil) (C :: D :: cd :: Ap :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApDDpcdmtmp;try rewrite HT2 in HCApDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCApDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}


assert(HApDpcdM : rk(Ap :: Dp :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApDpcdeq HApDpcdM3).
assert(HApDpcdm : rk(Ap :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApDpcdeq HApDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpDpcd *)
(* dans constructLemma(), requis par LCBpDDpcd *)
(* dans constructLemma(), requis par LOoCBpDDpcd *)
(* dans la couche 0 *)
Lemma LOoBCBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpDDpcdm4 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoBCDeq : rk(Oo :: B :: C :: D :: nil) = 4) by (apply LOoBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCBpDDpcdM : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpDDpcdm : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpDDpcd requis par la preuve de (?)OoCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpDDpcd requis par la preuve de (?)OoCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpDDpcd requis par la preuve de (?)OoCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpDDpcdm2 : rk(Oo :: C :: Bp :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApBpDDpcdM1. try clear HOoABCApBpDDpcdM2. try clear HOoABCApBpDDpcdM3. try clear HOoABCApBpDDpcdm4. try clear HOoABCApBpDDpcdm3. try clear HOoABCApBpDDpcdm2. try clear HOoABCApBpDDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpDDpcdm3 : rk(Oo :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpDDpcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpDDpcdm4 : rk(Oo :: C :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	try assert(HOoBCBpDDpcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm4).
	try assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpDDpcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}


assert(HOoCBpDDpcdM : rk(Oo :: C :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpDDpcdm : rk(Oo :: C :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCBpDDpcdeq HOoCBpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpDDpcdm2 : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpDDpcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Bp :: Dp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HCBpDDpcdm3 : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	try assert(HOoBCBpDDpcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm4).
	try assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hincl : incl (Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Dp :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (C :: Bp :: D :: Dp :: cd :: nil) (Bp :: Dp :: nil) 4 2 3 HOoBCBpDDpcdmtmp HBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpDDpcdm4 : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoCBpDDpcdeq : rk(Oo :: C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LOoCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCBpDDpcdmtmp : rk(Oo :: C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpDDpcdeq HOoCBpDDpcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpDDpcdmtmp;try rewrite HT2 in HOoCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HCBpDDpcdM : rk(C :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpDDpcdm : rk(C :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCBpDDpcdeq HCBpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpDpcd requis par la preuve de (?)BpDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpDpcd requis par la preuve de (?)BpDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpDpcdm2 : rk(Bp :: Dp :: cd :: nil) >= 2).
{
	try assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: Dp :: nil) (Bp :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Dp :: nil) (Bp :: Dp :: cd :: nil) 2 2 HBpDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpDpcdm3 : rk(Bp :: Dp :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCBpDDpcdeq : rk(C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCBpDDpcdmtmp : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCBpDDpcdeq HCBpDDpcdm4).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: D :: Dp :: cd :: nil) (C :: D :: cd :: Bp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpDDpcdmtmp;try rewrite HT2 in HCBpDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCBpDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}


assert(HBpDpcdM : rk(Bp :: Dp :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpDpcdeq HBpDpcdM3).
assert(HBpDpcdm : rk(Bp :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBpDpcdeq HBpDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApacDpcd *)
(* dans constructLemma(), requis par LApCpacDpcd *)
(* dans constructLemma(), requis par LOoCApCpacDpcd *)
(* dans la couche 0 *)
Lemma LOoACApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApCpacDpcd requis par la preuve de (?)OoACApCpacDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoACApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoABCApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApCpacDpcd requis par la preuve de (?)OoACApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApCpacDpcd requis par la preuve de (?)OoACApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApCpacDpcdm2 : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApCpacDpcdm3 : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpcdeq HOoABCApCpacDpcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpcdmtmp;try rewrite HT2 in HOoABCApCpacDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApCpacDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApCpacDpcdm4 : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoACDpeq : rk(Oo :: A :: C :: Dp :: nil) = 4) by (apply LOoACDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDpmtmp : rk(Oo :: A :: C :: Dp :: nil) >= 4) by (solve_hyps_min HOoACDpeq HOoACDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: Dp :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: Dp :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HOoACDpmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApCpacDpcdM : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApCpacDpcdm : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApCpacDpcdeq HOoACApCpacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpacDpcd requis par la preuve de (?)OoCApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoCApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoABCApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpacDpcd requis par la preuve de (?)OoCApCpacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpacDpcdm3 : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpcdeq HOoABCApCpacDpcdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpcdmtmp;try rewrite HT2 in HOoABCApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpacDpcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApCpacDpcdm4 : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoACApCpacDpcdeq : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) = 4) by (apply LOoACApCpacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACApCpacDpcdmtmp : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApCpacDpcdeq HOoACApCpacDpcdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApCpacDpcdmtmp;try rewrite HT2 in HOoACApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApCpacDpcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


assert(HOoCApCpacDpcdM : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApCpacDpcdm : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApCpacDpcdeq HOoCApCpacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoCApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoABCApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpacDpcd requis par la preuve de (?)OoCApCpacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpacDpcdm3 : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpcdeq HOoABCApCpacDpcdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpcdmtmp;try rewrite HT2 in HOoABCApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpacDpcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApCpacDpcdm2 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpacDpcdmtmp : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoCApCpacDpcdeq HOoCApCpacDpcdm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: C :: Cp :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpacDpcdmtmp;try rewrite HT2 in HOoCApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) (Cp :: nil) 3 1 2 HOoCApCpacDpcdmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApCpacDpcdM3 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) <= 3).
{
	try assert(HApCpaceq : rk(Ap :: Cp :: ac :: nil) = 2) by (apply LApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	try assert(HCpDpcdeq : rk(Cp :: Dp :: cd :: nil) = 2) by (apply LCpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Ap :: Cp :: ac :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ac :: Cp :: Dp :: cd :: nil) ((Ap :: Cp :: ac :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ac :: nil) (Cp :: Dp :: cd :: nil) (Cp :: nil) 2 2 1 HApCpacMtmp HCpDpcdMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Cp :: Dp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp :: Dp ::   de rang : 3 et 3 *)
assert(HApCpacDpcdm3 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoCCpDpeq : rk(Oo :: C :: Cp :: Dp :: nil) = 3) by (apply LOoCCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpDpMtmp : rk(Oo :: C :: Cp :: Dp :: nil) <= 3) by (solve_hyps_max HOoCCpDpeq HOoCCpDpM3).
	try assert(HOoCApCpacDpcdeq : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) = 4) by (apply LOoCApCpacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCApCpacDpcdmtmp : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCApCpacDpcdeq HOoCApCpacDpcdm4).
	try assert(HCpDpeq : rk(Cp :: Dp :: nil) = 2) by (apply LCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpDpmtmp : rk(Cp :: Dp :: nil) >= 2) by (solve_hyps_min HCpDpeq HCpDpm2).
	assert(Hincl : incl (Cp :: Dp :: nil) (list_inter (Oo :: C :: Cp :: Dp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: C :: Cp :: Dp :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Dp :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: C :: Cp :: Dp :: nil) ++ (Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpacDpcdmtmp;try rewrite HT2 in HOoCApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: Dp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) (Cp :: Dp :: nil) 4 2 3 HOoCApCpacDpcdmtmp HCpDpmtmp HOoCCpDpMtmp Hincl); apply HT.
}
try clear HOoCApCpacDpcdM1. try clear HOoCApCpacDpcdM2. try clear HOoCApCpacDpcdM3. try clear HOoCApCpacDpcdm4. try clear HOoCApCpacDpcdm3. try clear HOoCApCpacDpcdm2. try clear HOoCApCpacDpcdm1. 

assert(HApCpacDpcdM : rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpacDpcdm : rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApCpacDpcdeq HApCpacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApacDDpcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApacDDpcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoACDeq : rk(Oo :: A :: C :: D :: nil) = 4) by (apply LOoACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApacDDpcdm3 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApacDDpcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApacDDpcdm4 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApacDDpcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpcdeq HOoACApacDDpcdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpcdmtmp;try rewrite HT2 in HOoACApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApacDDpcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}
try clear HOoACApacDDpcdM1. try clear HOoACApacDDpcdM2. try clear HOoACApacDDpcdM3. try clear HOoACApacDDpcdm4. try clear HOoACApacDDpcdm3. try clear HOoACApacDDpcdm2. try clear HOoACApacDDpcdm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDDpcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDDpcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDDpcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApacDDpcdm2 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApacDDpcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDDpcdM1. try clear HOoABCApacDDpcdM2. try clear HOoABCApacDDpcdM3. try clear HOoABCApacDDpcdm4. try clear HOoABCApacDDpcdm3. try clear HOoABCApacDDpcdm2. try clear HOoABCApacDDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm3 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpcdeq HACApacDDpcdm3).
	try assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpcdmtmp;try rewrite HT2 in HACApacDDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}
try clear HACApacDDpcdM1. try clear HACApacDDpcdM2. try clear HACApacDDpcdM3. try clear HACApacDDpcdm4. try clear HACApacDDpcdm3. try clear HACApacDDpcdm2. try clear HACApacDDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm4 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCApacDDpcdmtmp : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCApacDDpcdeq HOoCApacDDpcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApacDDpcdmtmp;try rewrite HT2 in HOoCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApacDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}
try clear HOoCApacDDpcdM1. try clear HOoCApacDDpcdM2. try clear HOoCApacDDpcdM3. try clear HOoCApacDDpcdm4. try clear HOoCApacDDpcdm3. try clear HOoCApacDDpcdm2. try clear HOoCApacDDpcdm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)OoABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDpcdm2 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpcdmtmp;try rewrite HT2 in HOoABCApacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDpcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDpcdM1. try clear HOoABCApacDpcdM2. try clear HOoABCApacDpcdM3. try clear HOoABCApacDpcdm4. try clear HOoABCApacDpcdm3. try clear HOoABCApacDpcdm2. try clear HOoABCApacDpcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDpcdm3 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 3).
{
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDpcdm2 : rk(Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HACApacDpcdeq HACApacDpcdm3).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: C :: ac :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: Dp :: cd :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpcdmtmp;try rewrite HT2 in HACApacDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: Dp :: cd :: nil) (ac :: nil) 3 1 2 HACApacDpcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}
try clear HACApacDpcdM1. try clear HACApacDpcdM2. try clear HACApacDpcdM3. try clear HACApacDpcdm4. try clear HACApacDpcdm3. try clear HACApacDpcdm2. try clear HACApacDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApacDpcdm3 : rk(Ap :: ac :: Dp :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApacDDpcdmtmp : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCApacDDpcdeq HCApacDDpcdm4).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: ac :: D :: Dp :: cd :: nil) (C :: D :: cd :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: ac :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApacDDpcdmtmp;try rewrite HT2 in HCApacDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: ac :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCApacDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}
try clear HCApacDDpcdM1. try clear HCApacDDpcdM2. try clear HCApacDDpcdM3. try clear HCApacDDpcdm4. try clear HCApacDDpcdm3. try clear HCApacDDpcdm2. try clear HCApacDDpcdm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApacDpcdM3 : rk(Ap :: ac :: Dp :: cd :: nil) <= 3).
{
	try assert(HApCpacDpcdeq : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) = 3) by (apply LApCpacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpacDpcdMtmp : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HApCpacDpcdeq HApCpacDpcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) 3 3 HApCpacDpcdMtmp Hcomp Hincl);apply HT.
}


assert(HApacDpcdM : rk(Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDpcdm : rk(Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApacDpcdeq HApacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)OoABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApacDpcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDpcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoABCApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApCpacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApCpacDpcdM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacDpcdm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApCpacDpcdeq HOoABCApCpacDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpbcDpcd *)
(* dans constructLemma(), requis par LBpCpbcDpcd *)
(* dans constructLemma(), requis par LOoCBpCpbcDpcd *)
(* dans la couche 0 *)
Lemma LOoBCBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcDpcdm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpCpbcDpcdm4 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoBCDpeq : rk(Oo :: B :: C :: Dp :: nil) = 4) by (apply LOoBCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCDpmtmp : rk(Oo :: B :: C :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCDpeq HOoBCDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: Dp :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: Dp :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoBCDpmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCBpCpbcDpcdM : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpCpbcDpcdm : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpCpbcDpcdeq HOoBCBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcDpcdm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpCpbcDpcdm2 : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpCpbcDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApBpCpbcDpcdM1. try clear HOoABCApBpCpbcDpcdM2. try clear HOoABCApBpCpbcDpcdM3. try clear HOoABCApBpCpbcDpcdm4. try clear HOoABCApBpCpbcDpcdm3. try clear HOoABCApBpCpbcDpcdm2. try clear HOoABCApBpCpbcDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpCpbcDpcdm3 : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpCpbcDpcdmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpCpbcDpcdeq HOoBCBpCpbcDpcdm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcDpcdmtmp;try rewrite HT2 in HOoBCBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpCpbcDpcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpCpbcDpcdm4 : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	try assert(HOoBCBpCpbcDpcdeq : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) = 4) by (apply LOoBCBpCpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCBpCpbcDpcdmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpCpbcDpcdeq HOoBCBpCpbcDpcdm4).
	try assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcDpcdmtmp;try rewrite HT2 in HOoBCBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpCpbcDpcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}
try clear HOoBCBpCpbcDpcdM1. try clear HOoBCBpCpbcDpcdM2. try clear HOoBCBpCpbcDpcdM3. try clear HOoBCBpCpbcDpcdm4. try clear HOoBCBpCpbcDpcdm3. try clear HOoBCBpCpbcDpcdm2. try clear HOoBCBpCpbcDpcdm1. 

assert(HOoCBpCpbcDpcdM : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpCpbcDpcdm : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCBpCpbcDpcdeq HOoCBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Cp :: bc :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcDpcdm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpCpbcDpcdm2 : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpCpbcDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApBpCpbcDpcdM1. try clear HOoABCApBpCpbcDpcdM2. try clear HOoABCApBpCpbcDpcdM3. try clear HOoABCApBpCpbcDpcdm4. try clear HOoABCApBpCpbcDpcdm3. try clear HOoABCApBpCpbcDpcdm2. try clear HOoABCApBpCpbcDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpCpbcDpcdm3 : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpCpbcDpcdmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpCpbcDpcdeq HOoBCBpCpbcDpcdm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcDpcdmtmp;try rewrite HT2 in HOoBCBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpCpbcDpcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBCBpCpbcDpcdM1. try clear HOoBCBpCpbcDpcdM2. try clear HOoBCBpCpbcDpcdM3. try clear HOoBCBpCpbcDpcdm4. try clear HOoBCBpCpbcDpcdm3. try clear HOoBCBpCpbcDpcdm2. try clear HOoBCBpCpbcDpcdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HBpCpbcDpcdm2 : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoCCpeq : rk(Oo :: C :: Cp :: nil) = 2) by (apply LOoCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCBpCpbcDpcdmtmp : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoCBpCpbcDpcdeq HOoCBpCpbcDpcdm3).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: C :: Cp :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpCpbcDpcdmtmp;try rewrite HT2 in HOoCBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil) (Cp :: nil) 3 1 2 HOoCBpCpbcDpcdmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBpCpbcDpcdM3 : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) <= 3).
{
	try assert(HBpCpbceq : rk(Bp :: Cp :: bc :: nil) = 2) by (apply LBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	try assert(HCpDpcdeq : rk(Cp :: Dp :: cd :: nil) = 2) by (apply LCpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	try assert(HCpeq : rk(Cp :: nil) = 1) by (apply LCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Bp :: Cp :: bc :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: Cp :: bc :: Dp :: cd :: nil) (Bp :: Cp :: bc :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Cp :: bc :: Cp :: Dp :: cd :: nil) ((Bp :: Cp :: bc :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: Cp :: bc :: nil) (Cp :: Dp :: cd :: nil) (Cp :: nil) 2 2 1 HBpCpbcMtmp HCpDpcdMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Cp :: Dp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp :: Dp ::   de rang : 3 et 3 *)
assert(HBpCpbcDpcdm3 : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoCCpDpeq : rk(Oo :: C :: Cp :: Dp :: nil) = 3) by (apply LOoCCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCCpDpMtmp : rk(Oo :: C :: Cp :: Dp :: nil) <= 3) by (solve_hyps_max HOoCCpDpeq HOoCCpDpM3).
	try assert(HOoCBpCpbcDpcdeq : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) = 4) by (apply LOoCBpCpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCBpCpbcDpcdmtmp : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpCpbcDpcdeq HOoCBpCpbcDpcdm4).
	try assert(HCpDpeq : rk(Cp :: Dp :: nil) = 2) by (apply LCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCpDpmtmp : rk(Cp :: Dp :: nil) >= 2) by (solve_hyps_min HCpDpeq HCpDpm2).
	assert(Hincl : incl (Cp :: Dp :: nil) (list_inter (Oo :: C :: Cp :: Dp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: C :: Cp :: Dp :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Dp :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: C :: Cp :: Dp :: nil) ++ (Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpCpbcDpcdmtmp;try rewrite HT2 in HOoCBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: Dp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil) (Cp :: Dp :: nil) 4 2 3 HOoCBpCpbcDpcdmtmp HCpDpmtmp HOoCCpDpMtmp Hincl); apply HT.
}
try clear HOoCBpCpbcDpcdM1. try clear HOoCBpCpbcDpcdM2. try clear HOoCBpCpbcDpcdM3. try clear HOoCBpCpbcDpcdm4. try clear HOoCBpCpbcDpcdm3. try clear HOoCBpCpbcDpcdm2. try clear HOoCBpCpbcDpcdm1. 

assert(HBpCpbcDpcdM : rk(Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpCpbcDpcdm : rk(Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBpCpbcDpcdeq HBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: bc :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpbcDDpcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoBCDeq : rk(Oo :: B :: C :: D :: nil) = 4) by (apply LOoBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpcdm2 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpbcDDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpbcDDpcdm3 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpcdm4 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm4).
	try assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpbcDDpcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApBpbcDDpcdM1. try clear HOoABCApBpbcDDpcdM2. try clear HOoABCApBpbcDDpcdM3. try clear HOoABCApBpbcDDpcdm4. try clear HOoABCApBpbcDDpcdm3. try clear HOoABCApBpbcDDpcdm2. try clear HOoABCApBpbcDDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm2 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBCBpbcDDpcdM1. try clear HOoBCBpbcDDpcdM2. try clear HOoBCBpbcDDpcdM3. try clear HOoBCBpbcDDpcdm4. try clear HOoBCBpbcDDpcdm3. try clear HOoBCBpbcDDpcdm2. try clear HOoBCBpbcDDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm3 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpcdeq HBCBpbcDDpcdm3).
	try assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpcdmtmp;try rewrite HT2 in HBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}
try clear HBCBpbcDDpcdM1. try clear HBCBpbcDDpcdM2. try clear HBCBpbcDDpcdM3. try clear HBCBpbcDDpcdm4. try clear HBCBpbcDDpcdm3. try clear HBCBpbcDDpcdm2. try clear HBCBpbcDDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm4 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCBpbcDDpcdmtmp : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpbcDDpcdeq HOoCBpbcDDpcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpbcDDpcdmtmp;try rewrite HT2 in HOoCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpbcDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}
try clear HOoCBpbcDDpcdM1. try clear HOoCBpbcDDpcdM2. try clear HOoCBpbcDDpcdM3. try clear HOoCBpbcDDpcdm4. try clear HOoCBpbcDDpcdm3. try clear HOoCBpbcDDpcdm2. try clear HOoCBpbcDDpcdm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDpcd requis par la preuve de (?)BCBpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDpcd requis par la preuve de (?)OoBCBpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpcd requis par la preuve de (?)OoABCApBpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDpcd requis par la preuve de (?)OoBCBpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpcdeq HOoABCApBpbcDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDpcd requis par la preuve de (?)BCBpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDpcd requis par la preuve de (?)BCBpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDpcdm2 : rk(B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpcdeq HOoABCApBpbcDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApBpbcDpcdM1. try clear HOoABCApBpbcDpcdM2. try clear HOoABCApBpbcDpcdM3. try clear HOoABCApBpbcDpcdm4. try clear HOoABCApBpbcDpcdm3. try clear HOoABCApBpbcDpcdm2. try clear HOoABCApBpbcDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDpcdm3 : rk(B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDpcdeq HOoBCBpbcDpcdm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDpcdmtmp;try rewrite HT2 in HOoBCBpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBCBpbcDpcdM1. try clear HOoBCBpbcDpcdM2. try clear HOoBCBpbcDpcdM3. try clear HOoBCBpbcDpcdm4. try clear HOoBCBpbcDpcdm3. try clear HOoBCBpbcDpcdm2. try clear HOoBCBpbcDpcdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBpbcDpcdm2 : rk(Bp :: bc :: Dp :: cd :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDpcdmtmp : rk(B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDpcdeq HBCBpbcDpcdm3).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: Dp :: cd :: nil) (B :: C :: bc :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Bp :: bc :: Dp :: cd :: nil) ((B :: C :: bc :: nil) ++ (Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDpcdmtmp;try rewrite HT2 in HBCBpbcDpcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Bp :: bc :: Dp :: cd :: nil) (bc :: nil) 3 1 2 HBCBpbcDpcdmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}
try clear HBCBpbcDpcdM1. try clear HBCBpbcDpcdM2. try clear HBCBpbcDpcdM3. try clear HBCBpbcDpcdm4. try clear HBCBpbcDpcdm3. try clear HBCBpbcDpcdm2. try clear HBCBpbcDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpbcDpcdm3 : rk(Bp :: bc :: Dp :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpbcDDpcdmtmp : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCBpbcDDpcdeq HCBpbcDDpcdm4).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: bc :: D :: Dp :: cd :: nil) (C :: D :: cd :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: bc :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpbcDDpcdmtmp;try rewrite HT2 in HCBpbcDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: bc :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCBpbcDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}
try clear HCBpbcDDpcdM1. try clear HCBpbcDDpcdM2. try clear HCBpbcDDpcdM3. try clear HCBpbcDDpcdm4. try clear HCBpbcDDpcdm3. try clear HCBpbcDDpcdm2. try clear HCBpbcDDpcdm1. 

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpbcDpcdM3 : rk(Bp :: bc :: Dp :: cd :: nil) <= 3).
{
	try assert(HBpCpbcDpcdeq : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) = 3) by (apply LBpCpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpCpbcDpcdMtmp : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HBpCpbcDpcdeq HBpCpbcDpcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Bp :: bc :: Dp :: cd :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Bp :: bc :: Dp :: cd :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil) 3 3 HBpCpbcDpcdMtmp Hcomp Hincl);apply HT.
}


assert(HBpbcDpcdM : rk(Bp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpbcDpcdm : rk(Bp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBpbcDpcdeq HBpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpcd requis par la preuve de (?)OoABCApBpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpbcDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDpcdeq HOoABCApBpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpCpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpCpbcDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpbcDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApDDpcdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpcdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpDDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApacDDpcd *)
(* dans constructLemma(), requis par LOoCApacDDpcd *)
(* dans la couche 0 *)
Lemma LOoACApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApacDDpcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApacDDpcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoACDeq : rk(Oo :: A :: C :: D :: nil) = 4) by (apply LOoACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApacDDpcdM : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApacDDpcdm : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApacDDpcdeq HOoACApacDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApacDDpcdm3 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApacDDpcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApacDDpcdm4 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoACApacDDpcdeq : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) = 4) by (apply LOoACApacDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACApacDDpcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpcdeq HOoACApacDDpcdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpcdmtmp;try rewrite HT2 in HOoACApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApacDDpcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


assert(HOoCApacDDpcdM : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApacDDpcdm : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApacDDpcdeq HOoCApacDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDDpcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDDpcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDDpcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApacDDpcdm2 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApacDDpcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm3 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpcdeq HACApacDDpcdm3).
	try assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpcdmtmp;try rewrite HT2 in HACApacDDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}
try clear HACApacDDpcdM1. try clear HACApacDDpcdM2. try clear HACApacDDpcdM3. try clear HACApacDDpcdm4. try clear HACApacDDpcdm3. try clear HACApacDDpcdm2. try clear HACApacDDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm4 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoCApacDDpcdeq : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) = 4) by (apply LOoCApacDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCApacDDpcdmtmp : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCApacDDpcdeq HOoCApacDDpcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApacDDpcdmtmp;try rewrite HT2 in HOoCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApacDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HCApacDDpcdM : rk(C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApacDDpcdm : rk(C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCApacDDpcdeq HCApacDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApacDDpcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDDpcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBpbcDDpcd *)
(* dans constructLemma(), requis par LOoCBpbcDDpcd *)
(* dans la couche 0 *)
Lemma LOoBCBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpbcDDpcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoBCDeq : rk(Oo :: B :: C :: D :: nil) = 4) by (apply LOoBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCBpbcDDpcdM : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpbcDDpcdm : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpcdm2 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpbcDDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpbcDDpcdm3 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpcdm4 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	try assert(HOoBCBpbcDDpcdeq : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCBpbcDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm4).
	try assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpbcDDpcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}


assert(HOoCBpbcDDpcdM : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpbcDDpcdm : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCBpbcDDpcdeq HOoCBpbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm2 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm3 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpcdeq HBCBpbcDDpcdm3).
	try assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpcdmtmp;try rewrite HT2 in HBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}
try clear HBCBpbcDDpcdM1. try clear HBCBpbcDDpcdM2. try clear HBCBpbcDDpcdM3. try clear HBCBpbcDDpcdm4. try clear HBCBpbcDDpcdm3. try clear HBCBpbcDDpcdm2. try clear HBCBpbcDDpcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm4 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoCBpbcDDpcdeq : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) = 4) by (apply LOoCBpbcDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCBpbcDDpcdmtmp : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpbcDDpcdeq HOoCBpbcDDpcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpbcDDpcdmtmp;try rewrite HT2 in HOoCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpbcDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HCBpbcDDpcdM : rk(C :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpbcDDpcdm : rk(C :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCBpbcDDpcdeq HCBpbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpbcDDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LacDadcd *)
(* dans constructLemma(), requis par LAacDadcd *)
(* dans la couche 0 *)
Lemma LADadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCDadcd requis par la preuve de (?)ADadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDadcd requis par la preuve de (?)OoABCDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCDadcdm4 : rk(Oo :: A :: B :: C :: D :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: D ::   de rang : 4 et 4 *)
assert(HADadcdm2 : rk(A :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABCDeq : rk(Oo :: A :: B :: C :: D :: nil) = 4) by (apply LOoABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCDMtmp : rk(Oo :: A :: B :: C :: D :: nil) <= 4) by (solve_hyps_max HOoABCDeq HOoABCDM4).
	assert(HOoABCDadcdmtmp : rk(Oo :: A :: B :: C :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCDadcdeq HOoABCDadcdm4).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (Oo :: A :: B :: C :: D :: nil) (A :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: D :: ad :: cd :: nil) (Oo :: A :: B :: C :: D :: A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: D :: A :: D :: ad :: cd :: nil) ((Oo :: A :: B :: C :: D :: nil) ++ (A :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCDadcdmtmp;try rewrite HT2 in HOoABCDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: D :: nil) (A :: D :: ad :: cd :: nil) (A :: D :: nil) 4 2 4 HOoABCDadcdmtmp HADmtmp HOoABCDMtmp Hincl); apply HT.
}
try clear HOoABCDadcdM1. try clear HOoABCDadcdM2. try clear HOoABCDadcdM3. try clear HOoABCDadcdm4. try clear HOoABCDadcdm3. try clear HOoABCDadcdm2. try clear HOoABCDadcdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HADadcdM3 : rk(A :: D :: ad :: cd :: nil) <= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D :: ad :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: ad :: cd :: nil) (A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (cd :: nil) (nil) 2 1 0 HADadMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadcdm3 : rk(A :: D :: ad :: cd :: nil) >= 3).
{
	try assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: cd :: nil) (A :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: cd :: nil) (A :: D :: ad :: cd :: nil) 3 3 HADcdmtmp Hcomp Hincl);apply HT.
}


assert(HADadcdM : rk(A :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HADadcdm : rk(A :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HADadcdeq HADadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDadcdM1. try clear HOoABCApacDadcdM2. try clear HOoABCApacDadcdM3. try clear HOoABCApacDadcdm4. try clear HOoABCApacDadcdm3. try clear HOoABCApacDadcdm2. try clear HOoABCApacDadcdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDadcdm2 : rk(A :: ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	try assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDadcdm3 : rk(A :: ac :: D :: ad :: cd :: nil) >= 3).
{
	try assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil) 3 3 HADcdmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAacDadcdM3 : rk(A :: ac :: D :: ad :: cd :: nil) <= 3).
{
	try assert(HAacDcdeq : rk(A :: ac :: D :: cd :: nil) = 3) by (apply LAacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAacDcdMtmp : rk(A :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HAacDcdeq HAacDcdM3).
	try assert(HADadcdeq : rk(A :: D :: ad :: cd :: nil) = 3) by (apply LADadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadcdMtmp : rk(A :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HADadcdeq HADadcdM3).
	try assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hincl : incl (A :: D :: cd :: nil) (list_inter (A :: ac :: D :: cd :: nil) (A :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: D :: cd :: A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: D :: cd :: A :: D :: ad :: cd :: nil) ((A :: ac :: D :: cd :: nil) ++ (A :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: ac :: D :: cd :: nil) (A :: D :: ad :: cd :: nil) (A :: D :: cd :: nil) 3 3 3 HAacDcdMtmp HADadcdMtmp HADcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HAacDadcdM : rk(A :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacDadcdm : rk(A :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAacDadcdeq HAacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour acDadcd requis par la preuve de (?)acDadcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CacDadcd requis par la preuve de (?)acDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ACacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDadcdM1. try clear HOoABCApacDadcdM2. try clear HOoABCApacDadcdM3. try clear HOoABCApacDadcdm4. try clear HOoABCApacDadcdm3. try clear HOoABCApacDadcdm2. try clear HOoABCApacDadcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	try assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadcdm2 : rk(C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	try assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: nil) 2 2 2 HACacDadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadcdm3 : rk(C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACacDadcdeq HACacDadcdm3).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil) (D :: ad :: nil) 3 2 2 HACacDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCacDadcdM3 : rk(C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	try assert(HCacDadeq : rk(C :: ac :: D :: ad :: nil) = 3) by (apply LCacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacDadMtmp : rk(C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HCacDadeq HCacDadM3).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: D :: ad :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: D :: ad :: C :: D :: cd :: nil) ((C :: ac :: D :: ad :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCacDadMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour acDadcd requis par la preuve de (?)acDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDadcd requis par la preuve de (?)acDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDadcdm2 : rk(A :: ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	try assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}
try clear HACacDadcdM1. try clear HACacDadcdM2. try clear HACacDadcdM3. try clear HACacDadcdm4. try clear HACacDadcdm3. try clear HACacDadcdm2. try clear HACacDadcdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour acDadcd requis par la preuve de (?)acDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HacDadcdm2 : rk(ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAacDadcdmtmp : rk(A :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HAacDadcdeq HAacDadcdm2).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: ac :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAacDadcdmtmp;try rewrite HT2 in HAacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (ac :: D :: ad :: cd :: nil) (D :: ad :: nil) 2 2 2 HAacDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : D :: cd ::  de rang :  2 et 2 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HacDadcdm3 : rk(ac :: D :: ad :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCacDadcdmtmp : rk(C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HCacDadcdeq HCacDadcdm3).
	try assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (C :: D :: cd :: nil) (ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: D :: cd :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ac :: D :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCacDadcdmtmp;try rewrite HT2 in HCacDadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ac :: D :: ad :: cd :: nil) (D :: cd :: nil) 3 2 2 HCacDadcdmtmp HDcdmtmp HCDcdMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HacDadcdM3 : rk(ac :: D :: ad :: cd :: nil) <= 3).
{
	try assert(HAacDadcdeq : rk(A :: ac :: D :: ad :: cd :: nil) = 3) by (apply LAacDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAacDadcdMtmp : rk(A :: ac :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HAacDadcdeq HAacDadcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (ac :: D :: ad :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (ac :: D :: ad :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil) 3 3 HAacDadcdMtmp Hcomp Hincl);apply HT.
}


assert(HacDadcdM : rk(ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HacDadcdm : rk(ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HacDadcdeq HacDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LApacDpadcd *)
(* dans constructLemma(), requis par LApDpadcd *)
(* dans constructLemma(), requis par LCApDDpadcd *)
(* dans constructLemma(), requis par LOoCApDDpadcd *)
(* dans la couche 0 *)
Lemma LOoACApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApDDpadcdm2 : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApDDpadcdm3 : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApDDpadcdm4 : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoACDeq : rk(Oo :: A :: C :: D :: nil) = 4) by (apply LOoACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}


assert(HOoACApDDpadcdM : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApDDpadcdm : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApDDpadcdeq HOoACApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApDDpadcdm3 : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApDDpadcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApDDpadcdm4 : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoACApDDpadcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoACApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACApDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpadcdeq HOoACApDDpadcdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpadcdmtmp;try rewrite HT2 in HOoACApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApDDpadcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


assert(HOoCApDDpadcdM : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApDDpadcdm : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApDDpadcdeq HOoCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApDDpadcdm2 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApDDpadcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap :: Dp ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HCApDDpadcdm3 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoACApDDpadcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoACApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACApDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpadcdeq HOoACApDDpadcdm4).
	try assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hincl : incl (Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpadcdmtmp;try rewrite HT2 in HOoACApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: Dp :: nil) 4 2 3 HOoACApDDpadcdmtmp HApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApDDpadcdm4 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoCApDDpadcdeq : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoCApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCApDDpadcdmtmp : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoCApDDpadcdeq HOoCApDDpadcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApDDpadcdmtmp;try rewrite HT2 in HOoCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApDDpadcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HCApDDpadcdM : rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApDDpadcdm : rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCApDDpadcdeq HCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpadcdm2 : rk(Ap :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: ad :: cd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HApDpadcdM3 : rk(Ap :: Dp :: ad :: cd :: nil) <= 3).
{
	try assert(HApDpadeq : rk(Ap :: Dp :: ad :: nil) = 2) by (apply LApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Dp :: ad :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Dp :: ad :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Dp :: ad :: cd :: nil) ((Ap :: Dp :: ad :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Dp :: ad :: nil) (cd :: nil) (nil) 2 1 0 HApDpadMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApDpadcdm3 : rk(Ap :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCApDDpadcdeq : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LCApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApDDpadcdmtmp : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCApDDpadcdeq HCApDDpadcdm4).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: D :: Dp :: ad :: cd :: nil) (C :: D :: cd :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: Dp :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApDDpadcdmtmp;try rewrite HT2 in HCApDDpadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil) (cd :: nil) 4 1 2 HCApDDpadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}


assert(HApDpadcdM : rk(Ap :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDpadcdm : rk(Ap :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HApDpadcdeq HApDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: Dp :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApacDDpadcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpadcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApacDDpadcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoACDeq : rk(Oo :: A :: C :: D :: nil) = 4) by (apply LOoACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}
try clear HOoACDM1. try clear HOoACDM2. try clear HOoACDM3. try clear HOoACDm4. try clear HOoACDm3. try clear HOoACDm2. try clear HOoACDm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApacDDpadcdm3 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApacDDpadcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApacDDpadcdm4 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApacDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpadcdeq HOoACApacDDpadcdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpadcdmtmp;try rewrite HT2 in HOoACApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApacDDpadcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}
try clear HOoACApacDDpadcdM1. try clear HOoACApacDDpadcdM2. try clear HOoACApacDDpadcdM3. try clear HOoACApacDDpadcdm4. try clear HOoACApacDDpadcdm3. try clear HOoACApacDDpadcdm2. try clear HOoACApacDDpadcdm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDDpadcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDDpadcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDDpadcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApacDDpadcdm2 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApacDDpadcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDDpadcdM1. try clear HOoABCApacDDpadcdM2. try clear HOoABCApacDDpadcdM3. try clear HOoABCApacDDpadcdm4. try clear HOoABCApacDDpadcdm3. try clear HOoABCApacDDpadcdm2. try clear HOoABCApacDDpadcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm3 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpadcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm3).
	try assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpadcdmtmp;try rewrite HT2 in HACApacDDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm4 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCApacDDpadcdmtmp : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoCApacDDpadcdeq HOoCApacDDpadcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApacDDpadcdmtmp;try rewrite HT2 in HOoCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApacDDpadcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}
try clear HOoCApacDDpadcdM1. try clear HOoCApacDDpadcdM2. try clear HOoCApacDDpadcdM3. try clear HOoCApacDDpadcdm4. try clear HOoCApacDDpadcdm3. try clear HOoCApacDDpadcdm2. try clear HOoCApacDDpadcdm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDpadcdm2 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadcdmtmp;try rewrite HT2 in HOoABCApacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDpadcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDpadcdM1. try clear HOoABCApacDpadcdM2. try clear HOoABCApacDpadcdM3. try clear HOoABCApacDpadcdm4. try clear HOoABCApacDpadcdm3. try clear HOoABCApacDpadcdm2. try clear HOoABCApacDpadcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDpadcdm3 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDpadcdm2 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpadcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDpadcdeq HACApacDpadcdm3).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: C :: ac :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpadcdmtmp;try rewrite HT2 in HACApacDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (ac :: nil) 3 1 2 HACApacDpadcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}
try clear HACApacDpadcdM1. try clear HACApacDpadcdM2. try clear HACApacDpadcdM3. try clear HACApacDpadcdm4. try clear HACApacDpadcdm3. try clear HACApacDpadcdm2. try clear HACApacDpadcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApacDpadcdm3 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApacDDpadcdmtmp : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCApacDDpadcdeq HCApacDDpadcdm4).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: D :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApacDDpadcdmtmp;try rewrite HT2 in HCApacDDpadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (cd :: nil) 4 1 2 HCApacDDpadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApacDpadcdM3 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) <= 3).
{
	try assert(HApacDpcdeq : rk(Ap :: ac :: Dp :: cd :: nil) = 3) by (apply LApacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApacDpcdMtmp : rk(Ap :: ac :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HApacDpcdeq HApacDpcdM3).
	try assert(HApDpadcdeq : rk(Ap :: Dp :: ad :: cd :: nil) = 3) by (apply LApDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpadcdMtmp : rk(Ap :: Dp :: ad :: cd :: nil) <= 3) by (solve_hyps_max HApDpadcdeq HApDpadcdM3).
	try assert(HApDpcdeq : rk(Ap :: Dp :: cd :: nil) = 3) by (apply LApDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApDpcdmtmp : rk(Ap :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HApDpcdeq HApDpcdm3).
	assert(Hincl : incl (Ap :: Dp :: cd :: nil) (list_inter (Ap :: ac :: Dp :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ac :: Dp :: ad :: cd :: nil) (Ap :: ac :: Dp :: cd :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ac :: Dp :: cd :: Ap :: Dp :: ad :: cd :: nil) ((Ap :: ac :: Dp :: cd :: nil) ++ (Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: ac :: Dp :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil) (Ap :: Dp :: cd :: nil) 3 3 3 HApacDpcdMtmp HApDpadcdMtmp HApDpcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HApacDpadcdM : rk(Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDpadcdm : rk(Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HApacDpadcdeq HApacDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LApacDDpadcd *)
(* dans constructLemma(), requis par LCApacDDpadcd *)
(* dans constructLemma(), requis par LOoCApacDDpadcd *)
(* dans la couche 0 *)
Lemma LOoACApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApacDDpadcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpadcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApacDDpadcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoACDeq : rk(Oo :: A :: C :: D :: nil) = 4) by (apply LOoACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}
try clear HOoACDM1. try clear HOoACDM2. try clear HOoACDM3. try clear HOoACDm4. try clear HOoACDm3. try clear HOoACDm2. try clear HOoACDm1. 

assert(HOoACApacDDpadcdM : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApacDDpadcdm : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApacDDpadcdeq HOoACApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApacDDpadcdm3 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApacDDpadcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApacDDpadcdm4 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	try assert(HOoACApacDDpadcdeq : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoACApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoACApacDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpadcdeq HOoACApacDDpadcdm4).
	try assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpadcdmtmp;try rewrite HT2 in HOoACApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApacDDpadcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}


assert(HOoCApacDDpadcdM : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApacDDpadcdm : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApacDDpadcdeq HOoCApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDDpadcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDDpadcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDDpadcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApacDDpadcdm2 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	try assert(HApeq : rk(Ap :: nil) = 1) by (apply LAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApacDDpadcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm3 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpadcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm3).
	try assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpadcdmtmp;try rewrite HT2 in HACApacDDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm4 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoCApacDDpadcdeq : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoCApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCApacDDpadcdmtmp : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoCApacDDpadcdeq HOoCApacDDpadcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApacDDpadcdmtmp;try rewrite HT2 in HOoCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApacDDpadcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HCApacDDpadcdM : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApacDDpadcdm : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCApacDDpadcdeq HCApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApacDDpadcd requis par la preuve de (?)ApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApacDDpadcd requis par la preuve de (?)ApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApacDDpadcd requis par la preuve de (?)OoApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApacDDpadcd requis par la preuve de (?)OoApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApacDDpadcd requis par la preuve de (?)OoABApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApacDDpadcd requis par la preuve de (?)OoABApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApacDDpadcdm2 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApacDDpadcdm3 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApacDDpadcd requis par la preuve de (?)OoApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApacDDpadcdm2 : rk(Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApacDDpadcdmtmp : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApacDDpadcdeq HOoABApacDDpadcdm3).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacDDpadcdmtmp;try rewrite HT2 in HOoABApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApacDDpadcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABApacDDpadcdM1. try clear HOoABApacDDpadcdM2. try clear HOoABApacDDpadcdM3. try clear HOoABApacDDpadcdm4. try clear HOoABApacDDpadcdm3. try clear HOoABApacDDpadcdm2. try clear HOoABApacDDpadcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApacDDpadcdm3 : rk(Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HOoApaceq : rk(Oo :: Ap :: ac :: nil) = 3) by (apply LOoApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApacmtmp : rk(Oo :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoApaceq HOoApacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: ac :: nil) (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: ac :: nil) (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 3 3 HOoApacmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApacDDpadcd requis par la preuve de (?)ApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDDpadcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDDpadcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDDpadcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDDpadcd requis par la preuve de (?)ApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDDpadcdm2 : rk(Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpadcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm3).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: C :: ac :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpadcdmtmp;try rewrite HT2 in HACApacDDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil) (ac :: nil) 3 1 2 HACApacDDpadcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HApacDDpadcdm3 : rk(Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoApacDDpadcdmtmp : rk(Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoApacDDpadcdeq HOoApacDDpadcdm3).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: D :: Dp :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApacDDpadcdmtmp;try rewrite HT2 in HOoApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil) (D :: Dp :: nil) 3 2 2 HOoApacDDpadcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}
try clear HOoApacDDpadcdM1. try clear HOoApacDDpadcdM2. try clear HOoApacDDpadcdM3. try clear HOoApacDDpadcdm4. try clear HOoApacDDpadcdm3. try clear HOoApacDDpadcdm2. try clear HOoApacDDpadcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: cd ::  de rang :  2 et 2 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApacDDpadcdm4 : rk(Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCApacDDpadcdeq : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LCApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApacDDpadcdmtmp : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCApacDDpadcdeq HCApacDDpadcdm4).
	try assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: D :: cd :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApacDDpadcdmtmp;try rewrite HT2 in HCApacDDpadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil) (D :: cd :: nil) 4 2 2 HCApacDDpadcdmtmp HDcdmtmp HCDcdMtmp Hincl); apply HT.
}


assert(HApacDDpadcdM : rk(Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDDpadcdm : rk(Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HApacDDpadcdeq HApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac :: ad :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour acadcd requis par la preuve de (?)acadcd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CacDadcd requis par la preuve de (?)acadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ACacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDadcdM1. try clear HOoABCApacDadcdM2. try clear HOoABCApacDadcdM3. try clear HOoABCApacDadcdm4. try clear HOoABCApacDadcdm3. try clear HOoABCApacDadcdm2. try clear HOoABCApacDadcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	try assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadcdm2 : rk(C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	try assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: nil) 2 2 2 HACacDadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadcdm3 : rk(C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACacDadcdeq HACacDadcdm3).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil) (D :: ad :: nil) 3 2 2 HACacDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCacDadcdM3 : rk(C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	try assert(HCacDadeq : rk(C :: ac :: D :: ad :: nil) = 3) by (apply LCacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacDadMtmp : rk(C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HCacDadeq HCacDadM3).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: D :: ad :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: D :: ad :: C :: D :: cd :: nil) ((C :: ac :: D :: ad :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCacDadMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour acadcd requis par la preuve de (?)acadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Hacadcdm2 : rk(ac :: ad :: cd :: nil) >= 2).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCacDadcdmtmp : rk(C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HCacDadcdeq HCacDadcdm3).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: D :: cd :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ac :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCacDadcdmtmp;try rewrite HT2 in HCacDadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ac :: ad :: cd :: nil) (cd :: nil) 3 1 2 HCacDadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}


(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HacadcdM2 : rk(ac :: ad :: cd :: nil) <= 2).
{
	try assert(HacDadcdeq : rk(ac :: D :: ad :: cd :: nil) = 3) by (apply LacDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HacDadcdMtmp : rk(ac :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HacDadcdeq HacDadcdM3).
	try assert(HApacDpadcdeq : rk(Ap :: ac :: Dp :: ad :: cd :: nil) = 3) by (apply LApacDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApacDpadcdMtmp : rk(Ap :: ac :: Dp :: ad :: cd :: nil) <= 3) by (solve_hyps_max HApacDpadcdeq HApacDpadcdM3).
	try assert(HApacDDpadcdeq : rk(Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApacDDpadcdmtmp : rk(Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HApacDDpadcdeq HApacDDpadcdm4).
	assert(Hincl : incl (ac :: ad :: cd :: nil) (list_inter (ac :: D :: ad :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ac :: D :: Dp :: ad :: cd :: nil) (ac :: D :: ad :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ac :: D :: ad :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil) ((ac :: D :: ad :: cd :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApacDDpadcdmtmp;try rewrite HT2 in HApacDDpadcdmtmp.
	assert(HT := rule_3 (ac :: D :: ad :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (ac :: ad :: cd :: nil) 3 3 4 HacDadcdMtmp HApacDpadcdMtmp HApacDDpadcdmtmp Hincl);apply HT.
}


assert(HacadcdM : rk(ac :: ad :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Hacadcdeq HacadcdM3).
assert(Hacadcdm : rk(ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min Hacadcdeq Hacadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbcadcd *)
(* dans constructLemma(), requis par LACabacbcadcd *)
(* dans la couche 0 *)
Lemma LABCabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCabacbcadcdm4 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	try assert(HABCadeq : rk(A :: B :: C :: ad :: nil) = 4) by (apply LABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCadmtmp : rk(A :: B :: C :: ad :: nil) >= 4) by (solve_hyps_min HABCadeq HABCadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: ad :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: ad :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HABCadmtmp Hcomp Hincl);apply HT.
}


assert(HABCabacbcadcdM : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabacbcadcdm : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcadcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApabacbcadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabacbcadcdM1. try clear HOoABCApabacbcadcdM2. try clear HOoABCApabacbcadcdM3. try clear HOoABCApabacbcadcdm4. try clear HOoABCApabacbcadcdm3. try clear HOoABCApabacbcadcdm2. try clear HOoABCApabacbcadcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabacbcadcdm4 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	try assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	try assert(HABCabacbcadcdeq : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) = 4) by (apply LABCabacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm4).
	try assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabacbcadcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}
try clear HABCabacbcadcdM1. try clear HABCabacbcadcdM2. try clear HABCabacbcadcdM3. try clear HABCabacbcadcdm4. try clear HABCabacbcadcdm3. try clear HABCabacbcadcdm2. try clear HABCabacbcadcdm1. 

assert(HACabacbcadcdM : rk(A :: C :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabacbcadcdm : rk(A :: C :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACabacbcadcdeq HACabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour abacbc requis par la preuve de (?)abacbcadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abacbc requis par la preuve de (?)abacbc pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)abacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApabacbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApabacbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 3 HOoABCApabacbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABCabacbcM1. try clear HABCabacbcM2. try clear HABCabacbcM3. try clear HABCabacbcm4. try clear HABCabacbcm3. try clear HABCabacbcm2. try clear HABCabacbcm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour abacbc requis par la preuve de (?)abacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcm2 : rk(ab :: ac :: bc :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcmtmp : rk(A :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HACabacbceq HACabacbcm3).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ac :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcmtmp;try rewrite HT2 in HACabacbcmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: nil) (ac :: nil) 3 1 2 HACabacbcmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HabacbcM2 : rk(ab :: ac :: bc :: nil) <= 2).
{
	try assert(HAabacbceq : rk(A :: ab :: ac :: bc :: nil) = 3) by (apply LAabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabacbcMtmp : rk(A :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HAabacbceq HAabacbcM3).
	try assert(HApCpabacbceq : rk(Ap :: Cp :: ab :: ac :: bc :: nil) = 3) by (apply LApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpabacbcMtmp : rk(Ap :: Cp :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HApCpabacbceq HApCpabacbcM3).
	try assert(HAApCpabacbceq : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LAApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApCpabacbcmtmp : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HAApCpabacbceq HAApCpabacbcm4).
	assert(Hincl : incl (ab :: ac :: bc :: nil) (list_inter (A :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: ab :: ac :: bc :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: ac :: bc :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: ab :: ac :: bc :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpabacbcmtmp;try rewrite HT2 in HAApCpabacbcmtmp.
	assert(HT := rule_3 (A :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: ac :: bc :: nil) 3 3 4 HAabacbcMtmp HApCpabacbcMtmp HAApCpabacbcmtmp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcadcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApabacbcadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabacbcadcdM1. try clear HOoABCApabacbcadcdM2. try clear HOoABCApabacbcadcdM3. try clear HOoABCApabacbcadcdm4. try clear HOoABCApabacbcadcdm3. try clear HOoABCApabacbcadcdm2. try clear HOoABCApabacbcadcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABCabacbcadcdM1. try clear HABCabacbcadcdM2. try clear HABCabacbcadcdM3. try clear HABCabacbcadcdm4. try clear HABCabacbcadcdm3. try clear HABCabacbcadcdm2. try clear HABCabacbcadcdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcadcdm2 : rk(ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcadcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcadcdeq HACabacbcadcdm3).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: C :: ac :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadcdmtmp;try rewrite HT2 in HACabacbcadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ac :: nil) 3 1 2 HACabacbcadcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 5 4 et 4*)
assert(HabacbcadcdM3 : rk(ab :: ac :: bc :: ad :: cd :: nil) <= 3).
{
	assert(HabacbcMtmp : rk(ab :: ac :: bc :: nil) <= 2) by (solve_hyps_max Habacbceq HabacbcM2).
	try assert(Hacadcdeq : rk(ac :: ad :: cd :: nil) = 2) by (apply Lacadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HacadcdMtmp : rk(ac :: ad :: cd :: nil) <= 2) by (solve_hyps_max Hacadcdeq HacadcdM2).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (ab :: ac :: bc :: nil) (ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (ab :: ac :: bc :: ad :: cd :: nil) (ab :: ac :: bc :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ac :: bc :: ac :: ad :: cd :: nil) ((ab :: ac :: bc :: nil) ++ (ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: ac :: bc :: nil) (ac :: ad :: cd :: nil) (ac :: nil) 2 2 1 HabacbcMtmp HacadcdMtmp Hacmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HabacbcM1. try clear HabacbcM2. try clear HabacbcM3. try clear Habacbcm4. try clear Habacbcm3. try clear Habacbcm2. try clear Habacbcm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : ac :: ad ::  de rang :  2 et 2 	 A : A :: C :: ac :: ad ::   de rang : 3 et 3 *)
assert(Habacbcadcdm3 : rk(ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	try assert(HACacadeq : rk(A :: C :: ac :: ad :: nil) = 3) by (apply LACacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacadMtmp : rk(A :: C :: ac :: ad :: nil) <= 3) by (solve_hyps_max HACacadeq HACacadM3).
	try assert(HACabacbcadcdeq : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) = 4) by (apply LACabacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACabacbcadcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACabacbcadcdeq HACabacbcadcdm4).
	try assert(Hacadeq : rk(ac :: ad :: nil) = 2) by (apply Lacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacadmtmp : rk(ac :: ad :: nil) >= 2) by (solve_hyps_min Hacadeq Hacadm2).
	assert(Hincl : incl (ac :: ad :: nil) (list_inter (A :: C :: ac :: ad :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: C :: ac :: ad :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ad :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: C :: ac :: ad :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadcdmtmp;try rewrite HT2 in HACabacbcadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: ad :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ac :: ad :: nil) 4 2 3 HACabacbcadcdmtmp Hacadmtmp HACacadMtmp Hincl); apply HT.
}
try clear HacadM1. try clear HacadM2. try clear HacadM3. try clear Hacadm4. try clear Hacadm3. try clear Hacadm2. try clear Hacadm1. try clear HACabacbcadcdM1. try clear HACabacbcadcdM2. try clear HACabacbcadcdM3. try clear HACabacbcadcdm4. try clear HACabacbcadcdm3. try clear HACabacbcadcdm2. try clear HACabacbcadcdm1. 

assert(HabacbcadcdM : rk(ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habacbcadcdm : rk(ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min Habacbcadcdeq Habacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApabacbcadcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcadcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDadcd requis par la preuve de (?)OoABCDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCDadcdm4 : rk(Oo :: A :: B :: C :: D :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCDadcdM : rk(Oo :: A :: B :: C :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDadcdm : rk(Oo :: A :: B :: C :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCDadcdeq HOoABCDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ACacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDadcdM1. try clear HOoABCApacDadcdM2. try clear HOoABCApacDadcdM3. try clear HOoABCApacDadcdm4. try clear HOoABCApacDadcdm3. try clear HOoABCApacDadcdm2. try clear HOoABCApacDadcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	try assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadcdm2 : rk(C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	try assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: nil) 2 2 2 HACacDadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadcdm3 : rk(C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACacDadcdeq HACacDadcdm3).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil) (D :: ad :: nil) 3 2 2 HACacDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCacDadcdM3 : rk(C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	try assert(HCacDadeq : rk(C :: ac :: D :: ad :: nil) = 3) by (apply LCacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacDadMtmp : rk(C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HCacDadeq HCacDadM3).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: D :: ad :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: D :: ad :: C :: D :: cd :: nil) ((C :: ac :: D :: ad :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCacDadMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HCacDadcdM : rk(C :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCacDadcdm : rk(C :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCacDadcdeq HCacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApacDadcdM1. try clear HOoABCApacDadcdM2. try clear HOoABCApacDadcdM3. try clear HOoABCApacDadcdm4. try clear HOoABCApacDadcdm3. try clear HOoABCApacDadcdm2. try clear HOoABCApacDadcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	try assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	try assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HACacDadcdM : rk(A :: C :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDadcdm : rk(A :: C :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACacDadcdeq HACacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApacDadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApacDpadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDpadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApDDpadcdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpadcdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApacDDpadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDDpadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par LbcDbdcd *)
(* dans constructLemma(), requis par LBbcDbdcd *)
(* dans la couche 0 *)
Lemma LBDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDbdcdm2 : rk(B :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: nil) (B :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: nil) (B :: D :: bd :: cd :: nil) 2 2 HBDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBDbdcdM3 : rk(B :: D :: bd :: cd :: nil) <= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: D :: bd :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: D :: bd :: cd :: nil) (B :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (cd :: nil) (nil) 2 1 0 HBDbdMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDbdcdm3 : rk(B :: D :: bd :: cd :: nil) >= 3).
{
	try assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: D :: bd :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}


assert(HBDbdcdM : rk(B :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBDbdcdm : rk(B :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBDbdcdeq HBDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApbcDbdcdM1. try clear HOoABCApbcDbdcdM2. try clear HOoABCApbcDbdcdM3. try clear HOoABCApbcDbdcdm4. try clear HOoABCApbcDbdcdm3. try clear HOoABCApbcDbdcdm2. try clear HOoABCApbcDbdcdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDbdcdm2 : rk(B :: bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	try assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDbdcdm3 : rk(B :: bc :: D :: bd :: cd :: nil) >= 3).
{
	try assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBbcDbdcdM3 : rk(B :: bc :: D :: bd :: cd :: nil) <= 3).
{
	try assert(HBbcDcdeq : rk(B :: bc :: D :: cd :: nil) = 3) by (apply LBbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBbcDcdMtmp : rk(B :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBbcDcdeq HBbcDcdM3).
	try assert(HBDbdcdeq : rk(B :: D :: bd :: cd :: nil) = 3) by (apply LBDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdcdMtmp : rk(B :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBDbdcdeq HBDbdcdM3).
	try assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hincl : incl (B :: D :: cd :: nil) (list_inter (B :: bc :: D :: cd :: nil) (B :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: D :: cd :: B :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: D :: cd :: B :: D :: bd :: cd :: nil) ((B :: bc :: D :: cd :: nil) ++ (B :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: bc :: D :: cd :: nil) (B :: D :: bd :: cd :: nil) (B :: D :: cd :: nil) 3 3 3 HBbcDcdMtmp HBDbdcdMtmp HBDcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HBbcDbdcdM : rk(B :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBbcDbdcdm : rk(B :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBbcDbdcdeq HBbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour bcDbdcd requis par la preuve de (?)bcDbdcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CbcDbdcd requis par la preuve de (?)bcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BCbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApbcDbdcdM1. try clear HOoABCApbcDbdcdM2. try clear HOoABCApbcDbdcdM3. try clear HOoABCApbcDbdcdm4. try clear HOoABCApbcDbdcdm3. try clear HOoABCApbcDbdcdm2. try clear HOoABCApbcDbdcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	try assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	try assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm2 : rk(C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	try assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm3 : rk(C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm3).
	try assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCbcDbdcdM3 : rk(C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	try assert(HCbcDbdeq : rk(C :: bc :: D :: bd :: nil) = 3) by (apply LCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcDbdMtmp : rk(C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HCbcDbdeq HCbcDbdM3).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: D :: bd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: D :: bd :: C :: D :: cd :: nil) ((C :: bc :: D :: bd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCbcDbdMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCDM1. try clear HCDM2. try clear HCDM3. try clear HCDm4. try clear HCDm3. try clear HCDm2. try clear HCDm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour bcDbdcd requis par la preuve de (?)bcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)bcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDbdcdm2 : rk(B :: bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	try assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}
try clear HBCbcDbdcdM1. try clear HBCbcDbdcdM2. try clear HBCbcDbdcdM3. try clear HBCbcDbdcdm4. try clear HBCbcDbdcdm3. try clear HBCbcDbdcdm2. try clear HBCbcDbdcdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour bcDbdcd requis par la preuve de (?)bcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HbcDbdcdm2 : rk(bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBbcDbdcdmtmp : rk(B :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBbcDbdcdeq HBbcDbdcdm2).
	try assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBbcDbdcdmtmp;try rewrite HT2 in HBbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 2 2 2 HBbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: cd ::  de rang :  2 et 2 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HbcDbdcdm3 : rk(bc :: D :: bd :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCbcDbdcdmtmp : rk(C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HCbcDbdcdeq HCbcDbdcdm3).
	try assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (C :: D :: cd :: nil) (bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: D :: cd :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: bc :: D :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCbcDbdcdmtmp;try rewrite HT2 in HCbcDbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (bc :: D :: bd :: cd :: nil) (D :: cd :: nil) 3 2 2 HCbcDbdcdmtmp HDcdmtmp HCDcdMtmp Hincl); apply HT.
}


(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HbcDbdcdM3 : rk(bc :: D :: bd :: cd :: nil) <= 3).
{
	try assert(HBbcDbdcdeq : rk(B :: bc :: D :: bd :: cd :: nil) = 3) by (apply LBbcDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBbcDbdcdMtmp : rk(B :: bc :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBbcDbdcdeq HBbcDbdcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (bc :: D :: bd :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (bc :: D :: bd :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil) 3 3 HBbcDbdcdMtmp Hcomp Hincl);apply HT.
}


assert(HbcDbdcdM : rk(bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HbcDbdcdm : rk(bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HbcDbdcdeq HbcDbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par LBpbcDpbdcd *)
(* dans constructLemma(), requis par LBpDpbdcd *)
(* dans constructLemma(), requis par LCBpDDpbdcd *)
(* dans constructLemma(), requis par LOoCBpDDpbdcd *)
(* dans la couche 0 *)
Lemma LOoBCBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpDDpbdcdm4 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoBCDeq : rk(Oo :: B :: C :: D :: nil) = 4) by (apply LOoBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}


assert(HOoBCBpDDpbdcdM : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpDDpbdcdm : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpDDpbdcd requis par la preuve de (?)OoCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpDDpbdcd requis par la preuve de (?)OoCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpDDpbdcd requis par la preuve de (?)OoCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpDDpbdcdm2 : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDDpbdcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApBpDDpbdcdM1. try clear HOoABCApBpDDpbdcdM2. try clear HOoABCApBpDDpbdcdM3. try clear HOoABCApBpDDpbdcdm4. try clear HOoABCApBpDDpbdcdm3. try clear HOoABCApBpDDpbdcdm2. try clear HOoABCApBpDDpbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpDDpbdcdm3 : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpDDpbdcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpDDpbdcdm4 : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	try assert(HOoBCBpDDpbdcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoBCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm4).
	try assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpDDpbdcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}


assert(HOoCBpDDpbdcdM : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpDDpbdcdm : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoCBpDDpbdcdeq HOoCBpDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpDDpbdcdm2 : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpDDpbdcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Bp :: Dp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HCBpDDpbdcdm3 : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	try assert(HOoBCBpDDpbdcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoBCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm4).
	try assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hincl : incl (Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Dp :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil) (Bp :: Dp :: nil) 4 2 3 HOoBCBpDDpbdcdmtmp HBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpDDpbdcdm4 : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoCBpDDpbdcdeq : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCBpDDpbdcdmtmp : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpDDpbdcdeq HOoCBpDDpbdcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpDDpbdcdmtmp;try rewrite HT2 in HOoCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpDDpbdcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HCBpDDpbdcdM : rk(C :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpDDpbdcdm : rk(C :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCBpDDpbdcdeq HCBpDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpDpbdcd requis par la preuve de (?)BpDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpDpbdcd requis par la preuve de (?)BpDpbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpDpbdcd requis par la preuve de (?)BpDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpDpbdcdm2 : rk(Bp :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: Dp :: nil) (Bp :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Dp :: nil) (Bp :: Dp :: bd :: cd :: nil) 2 2 HBpDpmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 5*)
assert(HBpDpbdcdM3 : rk(Bp :: Dp :: bd :: cd :: nil) <= 3).
{
	try assert(HBpDpbdeq : rk(Bp :: Dp :: bd :: nil) = 2) by (apply LBpDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: Dp :: bd :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: Dp :: bd :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Dp :: bd :: cd :: nil) ((Bp :: Dp :: bd :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: Dp :: bd :: nil) (cd :: nil) (nil) 2 1 0 HBpDpbdMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpDpbdcdm3 : rk(Bp :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCBpDDpbdcdeq : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCBpDDpbdcdmtmp : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCBpDDpbdcdeq HCBpDDpbdcdm4).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: D :: Dp :: bd :: cd :: nil) (C :: D :: cd :: Bp :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: Dp :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpDDpbdcdmtmp;try rewrite HT2 in HCBpDDpbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCBpDDpbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}


assert(HBpDpbdcdM : rk(Bp :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpDpbdcdm : rk(Bp :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBpDpbdcdeq HBpDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpbcDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: bc :: Dp :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpbcDDpbdcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoBCDeq : rk(Oo :: B :: C :: D :: nil) = 4) by (apply LOoBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}
try clear HOoBCDM1. try clear HOoBCDM2. try clear HOoBCDM3. try clear HOoBCDm4. try clear HOoBCDm3. try clear HOoBCDm2. try clear HOoBCDm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpbdcdm2 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpbcDDpbdcdm3 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpbdcdm4 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm4).
	try assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpbcDDpbdcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm2 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpbdcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBCBpbcDDpbdcdM1. try clear HOoBCBpbcDDpbdcdM2. try clear HOoBCBpbcDDpbdcdM3. try clear HOoBCBpbcDDpbdcdm4. try clear HOoBCBpbcDDpbdcdm3. try clear HOoBCBpbcDDpbdcdm2. try clear HOoBCBpbcDDpbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm3 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpbdcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm3).
	try assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpbdcdmtmp;try rewrite HT2 in HBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm4 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCBpbcDDpbdcdmtmp : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpbcDDpbdcdeq HOoCBpbcDDpbdcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpbcDDpbdcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}
try clear HOoCBpbcDDpbdcdM1. try clear HOoCBpbcDDpbdcdM2. try clear HOoCBpbcDDpbdcdM3. try clear HOoCBpbcDDpbdcdm4. try clear HOoCBpbcDDpbdcdm3. try clear HOoCBpbcDDpbdcdm2. try clear HOoCBpbcDDpbdcdm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoBCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoABCApBpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDpbdcd requis par la preuve de (?)OoBCBpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDpbdcdm2 : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApBpbcDpbdcdM1. try clear HOoABCApBpbcDpbdcdM2. try clear HOoABCApBpbcDpbdcdM3. try clear HOoABCApBpbcDpbdcdm4. try clear HOoABCApBpbcDpbdcdm3. try clear HOoABCApBpbcDpbdcdm2. try clear HOoABCApBpbcDpbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDpbdcdm3 : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDpbdcdeq HOoBCBpbcDpbdcdm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBCBpbcDpbdcdM1. try clear HOoBCBpbcDpbdcdM2. try clear HOoBCBpbcDpbdcdM3. try clear HOoBCBpbcDpbdcdm4. try clear HOoBCBpbcDpbdcdm3. try clear HOoBCBpbcDpbdcdm2. try clear HOoBCBpbcDpbdcdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBpbcDpbdcdm2 : rk(Bp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDpbdcdmtmp : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDpbdcdeq HBCBpbcDpbdcdm3).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (B :: C :: bc :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Bp :: bc :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDpbdcdmtmp;try rewrite HT2 in HBCBpbcDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil) (bc :: nil) 3 1 2 HBCBpbcDpbdcdmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}
try clear HBCBpbcDpbdcdM1. try clear HBCBpbcDpbdcdM2. try clear HBCBpbcDpbdcdM3. try clear HBCBpbcDpbdcdm4. try clear HBCBpbcDpbdcdm3. try clear HBCBpbcDpbdcdm2. try clear HBCBpbcDpbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpbcDpbdcdm3 : rk(Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpbcDDpbdcdmtmp : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCBpbcDDpbdcdeq HCBpbcDDpbdcdm4).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: D :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpbcDDpbdcdmtmp;try rewrite HT2 in HCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCBpbcDDpbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBpbcDpbdcdM3 : rk(Bp :: bc :: Dp :: bd :: cd :: nil) <= 3).
{
	try assert(HBpbcDpcdeq : rk(Bp :: bc :: Dp :: cd :: nil) = 3) by (apply LBpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpbcDpcdMtmp : rk(Bp :: bc :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HBpbcDpcdeq HBpbcDpcdM3).
	try assert(HBpDpbdcdeq : rk(Bp :: Dp :: bd :: cd :: nil) = 3) by (apply LBpDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpbdcdMtmp : rk(Bp :: Dp :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBpDpbdcdeq HBpDpbdcdM3).
	try assert(HBpDpcdeq : rk(Bp :: Dp :: cd :: nil) = 3) by (apply LBpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpDpcdmtmp : rk(Bp :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBpDpcdeq HBpDpcdm3).
	assert(Hincl : incl (Bp :: Dp :: cd :: nil) (list_inter (Bp :: bc :: Dp :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: bc :: Dp :: bd :: cd :: nil) (Bp :: bc :: Dp :: cd :: Bp :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: bc :: Dp :: cd :: Bp :: Dp :: bd :: cd :: nil) ((Bp :: bc :: Dp :: cd :: nil) ++ (Bp :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: bc :: Dp :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil) (Bp :: Dp :: cd :: nil) 3 3 3 HBpbcDpcdMtmp HBpDpbdcdMtmp HBpDpcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HBpbcDpbdcdM : rk(Bp :: bc :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpbcDpbdcdm : rk(Bp :: bc :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBpbcDpbdcdeq HBpbcDpbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par LBpbcDDpbdcd *)
(* dans constructLemma(), requis par LCBpbcDDpbdcd *)
(* dans constructLemma(), requis par LOoCBpbcDDpbdcd *)
(* dans la couche 0 *)
Lemma LOoBCBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpbcDDpbdcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoBCDeq : rk(Oo :: B :: C :: D :: nil) = 4) by (apply LOoBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}
try clear HOoBCDM1. try clear HOoBCDM2. try clear HOoBCDM3. try clear HOoBCDm4. try clear HOoBCDm3. try clear HOoBCDm2. try clear HOoBCDm1. 

assert(HOoBCBpbcDDpbdcdM : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpbcDDpbdcdm : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpbdcdm2 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpbcDDpbdcdm3 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpbdcdm4 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	try assert(HOoBCBpbcDDpbdcdeq : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoBCBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm4).
	try assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpbcDDpbdcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}


assert(HOoCBpbcDDpbdcdM : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpbcDDpbdcdm : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoCBpbcDDpbdcdeq HOoCBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm2 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	try assert(HBpeq : rk(Bp :: nil) = 1) by (apply LBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpbdcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm3 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpbdcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm3).
	try assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpbdcdmtmp;try rewrite HT2 in HBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm4 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	try assert(HOoCBpbcDDpbdcdeq : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoCBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoCBpbcDDpbdcdmtmp : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpbcDDpbdcdeq HOoCBpbcDDpbdcdm4).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpbcDDpbdcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}


assert(HCBpbcDDpbdcdM : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpbcDDpbdcdm : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCBpbcDDpbdcdeq HCBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BpbcDDpbdcd requis par la preuve de (?)BpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBpbcDDpbdcd requis par la preuve de (?)BpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBpbcDDpbdcd requis par la preuve de (?)OoBpbcDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpbcDDpbdcd requis par la preuve de (?)OoBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpbcDDpbdcd requis par la preuve de (?)OoBBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCApBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpbcDDpbdcd requis par la preuve de (?)OoBCApBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpbcDDpbdcdm4 : rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpbcDDpbdcdmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpbcDDpbdcd requis par la preuve de (?)OoBBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpbcDDpbdcdm2 : rk(Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApBpbcDDpbdcdeq HOoBCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: Ap :: Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoBCApBpbcDDpbdcdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}
try clear HOoBCApBpbcDDpbdcdM1. try clear HOoBCApBpbcDDpbdcdM2. try clear HOoBCApBpbcDDpbdcdM3. try clear HOoBCApBpbcDDpbdcdm4. try clear HOoBCApBpbcDDpbdcdm3. try clear HOoBCApBpbcDDpbdcdm2. try clear HOoBCApBpbcDDpbdcdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpbcDDpbdcd requis par la preuve de (?)OoBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  2 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpbcDDpbdcdm2 : rk(Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpbcDDpbdcdmtmp : rk(Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2) by (solve_hyps_min HOoBBpbcDDpbdcdeq HOoBBpbcDDpbdcdm2).
	try assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: nil) 2 2 2 HOoBBpbcDDpbdcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}
try clear HOoBBpbcDDpbdcdM1. try clear HOoBBpbcDDpbdcdM2. try clear HOoBBpbcDDpbdcdM3. try clear HOoBBpbcDDpbdcdm4. try clear HOoBBpbcDDpbdcdm3. try clear HOoBBpbcDDpbdcdm2. try clear HOoBBpbcDDpbdcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpbcDDpbdcdm3 : rk(Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoBpbceq : rk(Oo :: Bp :: bc :: nil) = 3) by (apply LOoBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBpbcmtmp : rk(Oo :: Bp :: bc :: nil) >= 3) by (solve_hyps_min HOoBpbceq HOoBpbcm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: bc :: nil) (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: bc :: nil) (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 3 3 HOoBpbcmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpbcDDpbdcd requis par la preuve de (?)BpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	try assert(HOoeq : rk(Oo :: nil) = 1) by (apply LOo with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoBBpeq : rk(Oo :: B :: Bp :: nil) = 2) by (apply LOoBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	try assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpbcDDpbdcd requis par la preuve de (?)BpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBpbcDDpbdcdm2 : rk(Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpbdcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm3).
	try assert(Hbceq : rk(bc :: nil) = 1) by (apply Lbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: C :: bc :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpbdcdmtmp;try rewrite HT2 in HBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil) (bc :: nil) 3 1 2 HBCBpbcDDpbdcdmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBpbcDDpbdcdm3 : rk(Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	try assert(HOoDDpeq : rk(Oo :: D :: Dp :: nil) = 2) by (apply LOoDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBpbcDDpbdcdmtmp : rk(Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBpbcDDpbdcdeq HOoBpbcDDpbdcdm3).
	try assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: D :: Dp :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil) (D :: Dp :: nil) 3 2 2 HOoBpbcDDpbdcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}
try clear HOoBpbcDDpbdcdM1. try clear HOoBpbcDDpbdcdM2. try clear HOoBpbcDDpbdcdM3. try clear HOoBpbcDDpbdcdm4. try clear HOoBpbcDDpbdcdm3. try clear HOoBpbcDDpbdcdm2. try clear HOoBpbcDDpbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: cd ::  de rang :  2 et 2 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpbcDDpbdcdm4 : rk(Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCBpbcDDpbdcdeq : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LCBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCBpbcDDpbdcdmtmp : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCBpbcDDpbdcdeq HCBpbcDDpbdcdm4).
	try assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: D :: cd :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpbcDDpbdcdmtmp;try rewrite HT2 in HCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil) (D :: cd :: nil) 4 2 2 HCBpbcDDpbdcdmtmp HDcdmtmp HCDcdMtmp Hincl); apply HT.
}


assert(HBpbcDDpbdcdM : rk(Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpbcDDpbdcdm : rk(Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBpbcDDpbdcdeq HBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lbcbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(bc :: bd :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour bcbdcd requis par la preuve de (?)bcbdcd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CbcDbdcd requis par la preuve de (?)bcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BCbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApbcDbdcdM1. try clear HOoABCApbcDbdcdM2. try clear HOoABCApbcDbdcdM3. try clear HOoABCApbcDbdcdm4. try clear HOoABCApbcDbdcdm3. try clear HOoABCApbcDbdcdm2. try clear HOoABCApbcDbdcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	try assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	try assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm2 : rk(C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	try assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm3 : rk(C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm3).
	try assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCbcDbdcdM3 : rk(C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	try assert(HCbcDbdeq : rk(C :: bc :: D :: bd :: nil) = 3) by (apply LCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcDbdMtmp : rk(C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HCbcDbdeq HCbcDbdM3).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: D :: bd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: D :: bd :: C :: D :: cd :: nil) ((C :: bc :: D :: bd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCbcDbdMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCDM1. try clear HCDM2. try clear HCDM3. try clear HCDm4. try clear HCDm3. try clear HCDm2. try clear HCDm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour bcbdcd requis par la preuve de (?)bcbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Hbcbdcdm2 : rk(bc :: bd :: cd :: nil) >= 2).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCbcDbdcdmtmp : rk(C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HCbcDbdcdeq HCbcDbdcdm3).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: D :: cd :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: bc :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCbcDbdcdmtmp;try rewrite HT2 in HCbcDbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (bc :: bd :: cd :: nil) (cd :: nil) 3 1 2 HCbcDbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}


(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HbcbdcdM2 : rk(bc :: bd :: cd :: nil) <= 2).
{
	try assert(HbcDbdcdeq : rk(bc :: D :: bd :: cd :: nil) = 3) by (apply LbcDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HbcDbdcdMtmp : rk(bc :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HbcDbdcdeq HbcDbdcdM3).
	try assert(HBpbcDpbdcdeq : rk(Bp :: bc :: Dp :: bd :: cd :: nil) = 3) by (apply LBpbcDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpbcDpbdcdMtmp : rk(Bp :: bc :: Dp :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBpbcDpbdcdeq HBpbcDpbdcdM3).
	try assert(HBpbcDDpbdcdeq : rk(Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBpbcDDpbdcdmtmp : rk(Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBpbcDDpbdcdeq HBpbcDDpbdcdm4).
	assert(Hincl : incl (bc :: bd :: cd :: nil) (list_inter (bc :: D :: bd :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: bc :: D :: Dp :: bd :: cd :: nil) (bc :: D :: bd :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (bc :: D :: bd :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil) ((bc :: D :: bd :: cd :: nil) ++ (Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpbcDDpbdcdmtmp;try rewrite HT2 in HBpbcDDpbdcdmtmp.
	assert(HT := rule_3 (bc :: D :: bd :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil) (bc :: bd :: cd :: nil) 3 3 4 HbcDbdcdMtmp HBpbcDpbdcdMtmp HBpbcDDpbdcdmtmp Hincl);apply HT.
}


assert(HbcbdcdM : rk(bc :: bd :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Hbcbdcdeq HbcbdcdM3).
assert(Hbcbdcdm : rk(bc :: bd :: cd ::  nil) >= 1) by (solve_hyps_min Hbcbdcdeq Hbcbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BCbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApbcDbdcdM1. try clear HOoABCApbcDbdcdM2. try clear HOoABCApbcDbdcdM3. try clear HOoABCApbcDbdcdm4. try clear HOoABCApbcDbdcdm3. try clear HOoABCApbcDbdcdm2. try clear HOoABCApbcDbdcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	try assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	try assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm2 : rk(C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HBCbceq : rk(B :: C :: bc :: nil) = 2) by (apply LBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	try assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm3 : rk(C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm3).
	try assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HCbcDbdcdM3 : rk(C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	try assert(HCbcDbdeq : rk(C :: bc :: D :: bd :: nil) = 3) by (apply LCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCbcDbdMtmp : rk(C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HCbcDbdeq HCbcDbdM3).
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	try assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: D :: bd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: D :: bd :: C :: D :: cd :: nil) ((C :: bc :: D :: bd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCbcDbdMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HCDM1. try clear HCDM2. try clear HCDM3. try clear HCDm4. try clear HCDm3. try clear HCDm2. try clear HCDm1. 

assert(HCbcDbdcdM : rk(C :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCbcDbdcdm : rk(C :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCbcDbdcdeq HCbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}
try clear HOoABCApbcDbdcdM1. try clear HOoABCApbcDbdcdM2. try clear HOoABCApbcDbdcdM3. try clear HOoABCApbcDbdcdm4. try clear HOoABCApbcDbdcdm3. try clear HOoABCApbcDbdcdm2. try clear HOoABCApbcDbdcdm1. 

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	try assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}


(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	try assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}


assert(HBCbcDbdcdM : rk(B :: C :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDbdcdm : rk(B :: C :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApbcDbdcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDbdcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpbcDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoABCApBpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpbcDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpDDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpbcDDpbdcd *)
(* dans la couche 0 *)
Lemma LOoABCApBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApBpbcDDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpbcDDpbdcd requis par la preuve de (?)OoBCApBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpbcDDpbdcdm4 : rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApBpbcDDpbdcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoABCApBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	try assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpbcDDpbdcdmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}


assert(HOoBCApBpbcDDpbdcdM : rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpbcDDpbdcdm : rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCApBpbcDDpbdcdeq HOoBCApBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcDadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCabacbcDadbdcdm4 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HABCDeq : rk(A :: B :: C :: D :: nil) = 4) by (apply LABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HABCDeq HABCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HABCDmtmp Hcomp Hincl);apply HT.
}
try clear HABCDM1. try clear HABCDM2. try clear HABCDM3. try clear HABCDm4. try clear HABCDm3. try clear HABCDm2. try clear HABCDm1. 

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm2 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabacbcDadbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm3 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabacbcDadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm4 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm4).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: D :: ad :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: D :: ad :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (D :: ad :: nil) 4 2 2 HABCabacbcDadbdcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcDadbdcdm2 : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 3 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabacbcDadbdcdM1. try clear HOoABCApabacbcDadbdcdM2. try clear HOoABCApabacbcDadbdcdM3. try clear HOoABCApabacbcDadbdcdm4. try clear HOoABCApabacbcDadbdcdm3. try clear HOoABCApabacbcDadbdcdm2. try clear HOoABCApabacbcDadbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcDadbdcdm3 : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcDadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm2 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (ab :: nil) 3 1 2 HABCabacbcDadbdcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}
try clear HABCabacbcDadbdcdM1. try clear HABCabacbcDadbdcdM2. try clear HABCabacbcDadbdcdM3. try clear HABCabacbcDadbdcdm4. try clear HABCabacbcDadbdcdm3. try clear HABCabacbcDadbdcdm2. try clear HABCabacbcDadbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm3 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcDadbdcdmtmp : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcDadbdcdeq HACabacbcDadbdcdm3).
	try assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: C :: ac :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcDadbdcdmtmp;try rewrite HT2 in HACabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (C :: ac :: nil) 3 2 2 HACabacbcDadbdcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}
try clear HACabacbcDadbdcdM1. try clear HACabacbcDadbdcdM2. try clear HACabacbcDadbdcdM3. try clear HACabacbcDadbdcdm4. try clear HACabacbcDadbdcdm3. try clear HACabacbcDadbdcdm2. try clear HACabacbcDadbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm4 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCabacbcDadbdcdmtmp : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBCabacbcDadbdcdeq HBCabacbcDadbdcdm4).
	try assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (B :: D :: bd :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabacbcDadbdcdmtmp;try rewrite HT2 in HBCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (D :: bd :: nil) 4 2 2 HBCabacbcDadbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}
try clear HBCabacbcDadbdcdM1. try clear HBCabacbcDadbdcdM2. try clear HBCabacbcDadbdcdM3. try clear HBCabacbcDadbdcdm4. try clear HBCabacbcDadbdcdm3. try clear HBCabacbcDadbdcdm2. try clear HBCabacbcDadbdcdm1. 

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadbdcd requis par la preuve de (?)ABCabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadbdcd requis par la preuve de (?)OoABCApabacbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}
try clear HOoABCM1. try clear HOoABCM2. try clear HOoABCM3. try clear HOoABCm4. try clear HOoABCm3. try clear HOoABCm2. try clear HOoABCm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ABCabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcadbdcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: nil) 4 1 3 HOoABCApabacbcadbdcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}
try clear HOoABCApabacbcadbdcdM1. try clear HOoABCApabacbcadbdcdM2. try clear HOoABCApabacbcadbdcdM3. try clear HOoABCApabacbcadbdcdm4. try clear HOoABCApabacbcadbdcdm3. try clear HOoABCApabacbcadbdcdm2. try clear HOoABCApabacbcadbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadbdcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadbdcdeq HABCabacbcadbdcdm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadbdcdmtmp;try rewrite HT2 in HABCabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABCabacbcadbdcdM1. try clear HABCabacbcadbdcdM2. try clear HABCabacbcadbdcdM3. try clear HABCabacbcadbdcdm4. try clear HABCabacbcadbdcdm3. try clear HABCabacbcadbdcdm2. try clear HABCabacbcadbdcdm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcadbdcdm2 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcadbdcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcadbdcdeq HACabacbcadbdcdm3).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: C :: ac :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadbdcdmtmp;try rewrite HT2 in HACabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil) (ac :: nil) 3 1 2 HACabacbcadbdcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}
try clear HACabacbcadbdcdM1. try clear HACabacbcadbdcdM2. try clear HACabacbcadbdcdM3. try clear HACabacbcadbdcdm4. try clear HACabacbcadbdcdm3. try clear HACabacbcadbdcdm2. try clear HACabacbcadbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Habacbcadbdcdm3 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HCDcdeq : rk(C :: D :: cd :: nil) = 2) by (apply LCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCabacbcDadbdcdmtmp : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCabacbcDadbdcdeq HCabacbcDadbdcdm4).
	try assert(Hcdeq : rk(cd :: nil) = 1) by (apply Lcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (C :: D :: cd :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCabacbcDadbdcdmtmp;try rewrite HT2 in HCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCabacbcDadbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}
try clear HCabacbcDadbdcdM1. try clear HCabacbcDadbdcdM2. try clear HCabacbcDadbdcdM3. try clear HCabacbcDadbdcdm4. try clear HCabacbcDadbdcdm3. try clear HCabacbcDadbdcdm2. try clear HCabacbcDadbdcdm1. 

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HabacbcadbdcdM3 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) <= 3).
{
	try assert(Habadbdeq : rk(ab :: ad :: bd :: nil) = 2) by (apply Labadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HabadbdMtmp : rk(ab :: ad :: bd :: nil) <= 2) by (solve_hyps_max Habadbdeq HabadbdM2).
	try assert(Habacbcadcdeq : rk(ab :: ac :: bc :: ad :: cd :: nil) = 3) by (apply Labacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HabacbcadcdMtmp : rk(ab :: ac :: bc :: ad :: cd :: nil) <= 3) by (solve_hyps_max Habacbcadcdeq HabacbcadcdM3).
	try assert(Habadeq : rk(ab :: ad :: nil) = 2) by (apply Labad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habadmtmp : rk(ab :: ad :: nil) >= 2) by (solve_hyps_min Habadeq Habadm2).
	assert(Hincl : incl (ab :: ad :: nil) (list_inter (ab :: ad :: bd :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (ab :: ac :: bc :: ad :: bd :: cd :: nil) (ab :: ad :: bd :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ad :: bd :: ab :: ac :: bc :: ad :: cd :: nil) ((ab :: ad :: bd :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: ad :: bd :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ab :: ad :: nil) 2 3 2 HabadbdMtmp HabacbcadcdMtmp Habadmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}
try clear HabadM1. try clear HabadM2. try clear HabadM3. try clear Habadm4. try clear Habadm3. try clear Habadm2. try clear Habadm1. 

assert(HabacbcadbdcdM : rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habacbcadbdcdm : rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min Habacbcadbdcdeq Habacbcadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadbdcd requis par la preuve de (?)OoABCApabacbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}


assert(HOoABCApabacbcadbdcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcadbdcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCabacbcDadbdcd *)
(* dans constructLemma(), requis par LBCabacbcDadbdcd *)
(* dans la couche 0 *)
Lemma LABCabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}
try clear HOoABCM1. try clear HOoABCM2. try clear HOoABCM3. try clear HOoABCm4. try clear HOoABCm3. try clear HOoABCm2. try clear HOoABCm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcDadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCabacbcDadbdcdm4 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HABCDeq : rk(A :: B :: C :: D :: nil) = 4) by (apply LABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HABCDeq HABCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HABCDmtmp Hcomp Hincl);apply HT.
}
try clear HABCDM1. try clear HABCDM2. try clear HABCDM3. try clear HABCDm4. try clear HABCDm3. try clear HABCDm2. try clear HABCDm1. 

assert(HABCabacbcDadbdcdM : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabacbcDadbdcdm : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}
try clear HOoABCM1. try clear HOoABCM2. try clear HOoABCM3. try clear HOoABCm4. try clear HOoABCm3. try clear HOoABCm2. try clear HOoABCm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcDadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm2 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabacbcDadbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm3 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	try assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabacbcDadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm4 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HADadeq : rk(A :: D :: ad :: nil) = 2) by (apply LADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	try assert(HABCabacbcDadbdcdeq : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LABCabacbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm4).
	try assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: D :: ad :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: D :: ad :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (D :: ad :: nil) 4 2 2 HABCabacbcDadbdcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}


assert(HBCabacbcDadbdcdM : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCabacbcDadbdcdm : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCabacbcDadbdcdeq HBCabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}
try clear HOoABCM1. try clear HOoABCM2. try clear HOoABCM3. try clear HOoABCm4. try clear HOoABCm3. try clear HOoABCm2. try clear HOoABCm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcDadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcDadbdcdm2 : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 3 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcDadbdcdm3 : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcDadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm2 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	try assert(Habeq : rk(ab :: nil) = 1) by (apply Lab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (ab :: nil) 3 1 2 HABCabacbcDadbdcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm3 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcDadbdcdmtmp : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcDadbdcdeq HACabacbcDadbdcdm3).
	try assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: C :: ac :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcDadbdcdmtmp;try rewrite HT2 in HACabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (C :: ac :: nil) 3 2 2 HACabacbcDadbdcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}
try clear HACabacbcDadbdcdM1. try clear HACabacbcDadbdcdM2. try clear HACabacbcDadbdcdM3. try clear HACabacbcDadbdcdm4. try clear HACabacbcDadbdcdm3. try clear HACabacbcDadbdcdm2. try clear HACabacbcDadbdcdm1. 

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm4 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HBDbdeq : rk(B :: D :: bd :: nil) = 2) by (apply LBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	try assert(HBCabacbcDadbdcdeq : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LBCabacbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HBCabacbcDadbdcdmtmp : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBCabacbcDadbdcdeq HBCabacbcDadbdcdm4).
	try assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (B :: D :: bd :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabacbcDadbdcdmtmp;try rewrite HT2 in HBCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (D :: bd :: nil) 4 2 2 HBCabacbcDadbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}


assert(HCabacbcDadbdcdM : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCabacbcDadbdcdm : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCabacbcDadbdcdeq HCabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	try assert(HOoABCeq : rk(Oo :: A :: B :: C :: nil) = 4) by (apply LOoABC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}
try clear HOoABCM1. try clear HOoABCM2. try clear HOoABCM3. try clear HOoABCm4. try clear HOoABCm3. try clear HOoABCm2. try clear HOoABCm1. 

assert(HOoABCApabacbcDadbdcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcDadbdcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abacbc requis par la preuve de (?)abacbc pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)abacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HOoAApeq : rk(Oo :: A :: Ap :: nil) = 2) by (apply LOoAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	try assert(HOoABCApabacbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}


(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	try assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	try assert(HOoABCApabacbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	try assert(HAeq : rk(A :: nil) = 1) by (apply LA with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 3 HOoABCApabacbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}


(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	try assert(HABabeq : rk(A :: B :: ab :: nil) = 2) by (apply LABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	try assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}
try clear HABCabacbcM1. try clear HABCabacbcM2. try clear HABCabacbcM3. try clear HABCabacbcm4. try clear HABCabacbcm3. try clear HABCabacbcm2. try clear HABCabacbcm1. 

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour abacbc requis par la preuve de (?)abacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcm2 : rk(ab :: ac :: bc :: nil) >= 2).
{
	try assert(HACaceq : rk(A :: C :: ac :: nil) = 2) by (apply LACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcmtmp : rk(A :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HACabacbceq HACabacbcm3).
	try assert(Haceq : rk(ac :: nil) = 1) by (apply Lac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ac :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcmtmp;try rewrite HT2 in HACabacbcmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: nil) (ac :: nil) 3 1 2 HACabacbcmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}


(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HabacbcM2 : rk(ab :: ac :: bc :: nil) <= 2).
{
	try assert(HAabacbceq : rk(A :: ab :: ac :: bc :: nil) = 3) by (apply LAabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAabacbcMtmp : rk(A :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HAabacbceq HAabacbcM3).
	try assert(HApCpabacbceq : rk(Ap :: Cp :: ab :: ac :: bc :: nil) = 3) by (apply LApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HApCpabacbcMtmp : rk(Ap :: Cp :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HApCpabacbceq HApCpabacbcM3).
	try assert(HAApCpabacbceq : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LAApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ;try assumption).
	assert(HAApCpabacbcmtmp : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HAApCpabacbceq HAApCpabacbcm4).
	assert(Hincl : incl (ab :: ac :: bc :: nil) (list_inter (A :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: ab :: ac :: bc :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: ac :: bc :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: ab :: ac :: bc :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpabacbcmtmp;try rewrite HT2 in HAApCpabacbcmtmp.
	assert(HT := rule_3 (A :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: ac :: bc :: nil) 3 3 4 HAabacbcMtmp HApCpabacbcMtmp HAApCpabacbcmtmp Hincl);apply HT.
}


assert(HabacbcM : rk(ab :: ac :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Habacbceq HabacbcM3).
assert(Habacbcm : rk(ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min Habacbceq Habacbcm1).
intuition.
Qed.

